title,heading,content,source,tokens,id
Configure Developer Portal Self-Sign-Up,Configure Developer Portal Self-Sign-Up,Choreo allows you to configure self-sign-up to enable users to access your Developer Portal via a self-sign-up page.This page walks you through the steps to configure self-sign-up to the Developer Portal.,https://wso2.com/choreo/docs/administer/configure-developer-portal-self-sign-up/,48,D0
Manage Applications,Step 2: Generate keys - Access token for production - part 1,"Depending on your use case, you can generate an access token using one of the two grant types available in Choreo: Client Credentials and Token Exchange.!!! note We recommend you use the Token Exchange grant type to obtain an access token for production use and use the Client Credentials grant type for testing purposes.Token Exchange grant type requires you to pass a subject_token as a parameter in the token invocation call. You can obtain a subject token (id token) by using the open_id scope. Follow the steps below to generate an access token from the IdP along with the subject token:Register the IdP in Choreo by following the steps in the section add an external IdP. Generate a token from the registered IdP with the openId scope and retrieve the id_token from the token response. {""access_token"":""<access__token>"",""refresh_token"":""<refresh_token>"",""scope"":""openid"",""id_token"":""<id_token>"",""token_type"":""Bearer"",""expires_in"":3600} Sign in to Choreo Developer Portal at https://devportal.choreo.dev. Alternatively, click the Developer Portal link on the Choreo Console header. Click Applications. In the left pane, click OAuth 2.0 Tokens. Expand the Advanced Configurations section and review the options. {.cInlineImage-half} Grant Types: The grant types used to generate the access token.",https://wso2.com/choreo/docs/consume/manage-application/,307,D1
DevOps Portal,DevOps Portal,The Choreo Console allows you to observe the basic deployment process of a Dockerfile-based component. The Choreo DevOps Portal provides a low-level Kubernetes view of the underlying data plane resources for advanced developers who want to carry out a detailed diagnosis of Choreo components. Most advanced features on the DevOps Portal are only available for private data planes.,https://wso2.com/choreo/docs/devops/devops-portal/,77,D2
Connect with Protected Third Party Applications,Connect with Protected Third Party Applications,"
When your Choreo component connects with protected third-party applications, the firewalls of these applications might block the requests of the Choreo component. To address this, you can add the following public IP ranges of Choreo that it assigns to Choreo components as client IPs to the allow list:20.22.170.144/28
20.22.170.176/28You need to add these IP ranges to the allow list when you develop components that connect to external databases (e.g., MySQL, MSSQL, PGSQL, Oracle DB, etc.) via connectors (e.g., MySQL DB connector). Doing so allows Choreo to create a secure connection.",https://wso2.com/choreo/docs/reference/connect-with-protected-third-party-applications/,148,D3
Migrate Applications to the Latest Version,Migrate Applications to the Latest Version,"The previous version of Choreo allowed you to create APIs, services, and integrations. The current version introduces the concept of creating Choreo projects with components.This section explains how to migrate the APIs, services, and integrations you created in the previous version as components to the current version.!!! attention
You need to complete the migration before the 1st of February 2022.!!! note
You can only migrate APIs, services, and integrations created before 2022.!!! infoIf you want to continue using the **previous version**, you can access it **until the 1st of February 2022** via the following URLs:
- **Choreo Console**: [https://console.deprecated.choreo.dev/](https://console.deprecated.choreo.dev/)
- **Dev Portal**: [https://devportal.deprecated.choreo.dev/](https://devportal.deprecated.choreo.dev/)
The **API access** and **API token management** remains **unchanged**.
To access the APIs, services and integrations you added in the previous version, you can use the same endpoints as before.To migrate your APIs, services, and integrations from the previous version to the current version, follow the steps below:",https://wso2.com/choreo/docs/reference/migrate-applications-to-the-latest-version/,274,D4
Quick Start Guide,Quick Start Guide,"Choreo is a full lifecycle cloud-native developer platform that enables your developers to create, deploy,  run, and govern APIs, integrations, and microservices on Kubernetes.This guide walks you through the following:Developing, deploying, testing, and publishing a REST API.
Consuming the published REST API via an external application.
Releasing a new version of the REST API with added functionality.Let's consider a use case where a web application developer designs an application that allows you to maintain reading lists. A user can create a private reading list by adding books. The user can also view and delete them when required. A Choreo developer develops a REST API for this web application to consume. The two developers will create two versions of the solution in two iterations. The second version of the application will add data persistence as a new feature.The following diagram summarizes the use case:{.cInlineImage-full}Let's get started!",https://wso2.com/choreo/docs/get-started/quick-start-guide/,199,D5
Anonymous Access,Anonymous Access,"
Choreo supports anonymous access to allow (evaluation) users to try out Choreo without having to sign in. An anonymous account is valid for seven days from the time of initial access.!!! info
- Anonymous access is solely for evaluation purposes and is not recommended for production use.
- An anonymous account expires after seven days from initial access. Therefore, we do not recommend anonymous access to Choreo on a shared computer as shared computers could posess risks such as leakage of code, credentials, and confidential information.Because Choreo discards all data of anonymous user accounts after seven days, you can sign in to Choreo using Google or GitHub to get all your data transferred to the new user account.
Once you sign in, you can continue using Choreo with your current services, integrations, and other data.",https://wso2.com/choreo/docs/reference/anonymous-access/,173,D6
Preview Features,Preview Features,"
Preview features offer early access to functionality that is not finalized by the Choreo team. You can enable if you would like to try them out during the early stages of their development.!!! info
You cannot enable preview features when you try Choreo anonymously.To enable Choreo features that are released as preview features, follow these steps:Expand the profile menu and click Feature Preview.
{.cInlineImage-full}
In the Feature Preview dialog, enable the required features.
{.cInlineImage-full}",https://wso2.com/choreo/docs/reference/preview-features/,113,D7
Connect Your GitHub Repository to Choreo,Connect Your GitHub Repository to Choreo,"Choreo allows you to connect your own GitHub repository to maintain the source code of a component when you create any Choreo components. You can create a Choreo component using a Ballerina project or a service written in any language in a Docker container. By connecting your GitHub repository, you enable collaborative development for Choreo components. Furthermore, this lets developers keep the source repository within their control and adhere to enterprise-specific best practices and development guidelines such as checking pull requests, code analysis, styling preferences, etc.This tutorial walks you through the steps to connect your own GitHub repository when creating a component. In this tutorial, you will connect your GitHub repository and use the REST API implementation in your GitHub repository to create a REST API in Choreo.",https://wso2.com/choreo/docs/develop/manage-repository/connect-your-own-github-repository-to-choreo/,155,D8
Deploy a Containerized Choreo Component,Deploy a Containerized Choreo Component,"Choreo allows you to deploy an application written in a wide range of language frameworks (for example, Java, Go, NodeJs, Python, PHP, etc.) on shared or private data planes when you create any of the following components:REST APIs
Scheduled tasks
Manual triggersThis guide walks you through the steps to deploy a sample containerized REST API component in Choreo.",https://wso2.com/choreo/docs/deploy/deploy-a-containerized-choreo-component/,82,D9
Root Cause Analysis,Root Cause Analysis,Choreo provides insightful observability features to drill down to the request level and confirm the root cause for anomalies you detect. This guide describes how you can detect anomalies and perform root cause analysis on a service deployed in Choreo.,https://wso2.com/choreo/docs/observe-and-analyze/observe/root-cause-analysis/,47,D10
Programmatic Access to Insights API,Programmatic Access to Insights API,"
The Insights page in the Choreo Console displays data fetched from the Insights API exposed over the Internet. However, in some scenarios, you may need to fetch data from external systems and implement custom dashboards to display this data.Choreo provides a secure and user-friendly method to achieve this requirement. The steps are outlined below:
h2 -> Become a member of the Choreo System organization
Access the Developer Portal of the Choreo System organization via https://devportal.choreo.dev/choreosystem and proceed to sign in using your credentials.
Click on Applications.
To get access to the Choreo System organization, click Request Access.
{.cInlineImage-full}Once you request access, you are automatically added as a member of the Choreo System organization.Verify this by checking whether the Choreo System organization appears in your list of organizations.{.cInlineImage-full}
h2 -> Create an application and generate keys
To create an application and generate keys, follow the steps below:Click on the Applications link to create a new application in the Choreo System organization.
{.cInlineImage-full}
Enter a suitable name and create the application.
{.cInlineImage-half}
To subscribe to the Insights API via the newly created application, click Subscriptions in the left navigator, and then click Add for the Insights API.
{.cInlineImage-full}
To generate credentials for the application, click  Production Keys -> OAuth 2.0 Tokens in the left navigator, and then click Generate Credentials. This generates a consumer key and secret for the created application.
{.cInlineImage-full}
Specify a suitable token expiry time and click Update.
{.cInlineImage-full}
Execute the following curl command to generate an access token:
curl --location --request POST 'https://sts.choreo.dev/oauth2/token' \
--header 'Authorization: Basic <BASE64_ENCODED_CONSUMER_KEY_AND_CONSUMER_SECRET_OF_YOUR_APP_HERE>' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'grant_type=client_credentials' \
--data-urlencode 'orgHandle=<YOUR_ORG_HANDLE_HERE>' \
--data-urlencode 'scope=apim:api_manage'
!!! info
To get your organization handle name, you must sign in to https://console.choreo.dev, go to Settings, and click Copy Handle.
This token can then be used to access the Insights API exposed via https://choreocontrolplane.choreo.dev/93tu/insights/1.0.0/query-api.
A sample curl command to invoke the Insights API is shown below.
curl --location --request POST 'https://choreocontrolplane.choreo.dev/93tu/insights/1.0.0/query-api' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer <TOKEN_HERE>' \
--data-raw '{""query"":""query ($org: OrgFilter!) {listEnvironments(org: $org){id\n name}}"",""variables"":{""org"":{""orgId"":""<ORG_UUID_HERE>""}}}'
!!! tip
When the token expires, you can generate a new token programmatically by making an API call to the token endpoint via the client credentials grant.
 If a token theft occurs, the relevant token can be revoked by making an API call to the revoke-endpoint.
 ![Endpoints](../../assets/img/insights/endpoints.png){.cInlineImage-full}",https://wso2.com/choreo/docs/observe-and-analyze/analyze/programmatic-access-choreo-insights-api/,875,D11
Webhook,Webhook,Explore how you can create event-driven integrations with Choreo Webhooks.,https://wso2.com/choreo/docs/develop/components/webhook/,18,D12
Configure Enterprise Login,Configure Enterprise Login,Choreo's Enterprise Login feature allows your users residing in an external IdP (Identity Provider) to login into Choreo seamlessly without changing their credentials.This guide takes you through the steps you need to follow to configure an enterprise login for your organization in Choreo.,https://wso2.com/choreo/docs/administer/configure-enterprise-login/,57,D13
Get Started with Choreo iPaaS,Get Started with Choreo iPaaS,"
Choreo iPaaS provides integration capabilities to connect different systems, applications, or services to exchange data and information. You can create integrations between a variety of technologies, including APIs, messaging systems, and integration platforms. The goal of integration is to create a seamless user experience and improve the efficiency and effectiveness of business operations.Choreo provides Integrations developed in Ballerina and integrations based on WSO2 Micro Integrator.For more information, see the following topics:Develop Integrations with Ballerina
Develop Integrations with the Micro Integrator",https://wso2.com/choreo/docs/ipaas/get-started-with-choreo-ipaas/,115,D14
Pricing,Pricing,"

h2 -> Introduction
Choreo is a Digital Platform as a Service that helps you develop integration solutions faster by reducing the coding effort with a low-code development platform.The pricing for your Choreo deployment is mainly determined based on the following:The number of components
You can deploy up to five free components ((i.e., any combination of component types), and pay for each additional component.
Infrastructure cost
The infrastructure cost consists of the charges to Choreo by the cloud platform for vCPU, RAM, storage, ingress, egress, and network. Choreo provides $100 worth of infrastructure free of charge to each organization.
If the infrastructure cost of an organization on the Free plan exceeds $100, Choreo will limit some of the services it provides to it (e.g., some components might be deactivated).
If the infrastructure cost of an organization on the Pay As You Go plan exceeds $100, it can pay the additional infrastructure charges to the cloud platform vendor.
If the infrastructure cost of an organization on the Enterprise plan exceeds $100, it can pay the additional infrastructure charges to the Choreo Sales Team.
h2 -> Plans
Choreo currently supports the following payment plans:FreeThe free tier allows you to create up to five free components. These five components can be any combination of component types.Choreo allocates up to a maximum of 2x vCPUs and 4 GB RAM infrastructure resources to your component workloads.You can enjoy the free tier with limitations and then move on to the Pay-As-You-Go plan if you want to create over five components.Pay As You GoThis plan requires you to pay the following:$150 per component (except for the first five components) on a monthly basis.
Any additional infrastructure costs incurred (i.e., if the infrastructure cost is over $100).This plan does not require you to pay an annual fee. You can create up to 30 components (i.e., any combination of component types).If the number of components you need to create exceeds 30 or if your annual spend exceeds $50,000, we recommend that you change your pricing plan to Enterprise.EnterpriseThis plan allows you to pay an annual subscription of $50,000 or more (as agreed) and create up to 50 components (i.e., any combination of component types). If you need to create over 50 components, contact the Choreo sales team.The following table summarizes the cost of each plan:
h3 -> Features
This section summarizes the features supported for each plan:
h4 -> Developer and operational
Choreo supports the following developer and operational features for all the plans:Managing the source code via a GitHub repository
Continuous integrations (CI)
Continuous delivery (CD)
Deployments to cloud platforms are supported for the three plans as follows:
Free
Pay As You Go
Enterprise
Azure
AzureAWSGCPVMWareOpenShiftTanzuAny Kubernetes cluster
AzureAWSGCPVMWareOpenShiftTanzuAny Kubernetes cluster
h4 -> Integration and automation
Choreo supports the following integration and automation components for all the plans:Triggers
Scheduled jobsIn addition, Choreo supports 500+ out-of-the-box connectors for integration and automation for all the plans.
h4 -> AI-assisted development
Choreo supports the following AI-assisted development features for all the plans:Performance predictions
Intelligent data mapping
Smart code assistance
Anomaly detection
h4 -> API management
Choreo supports the following API management features for all the plans:
h4 -> Monitoring and observability
Choreo supports monitoring and observability features for each plan as follows:
h4 -> Security
Choreo supports the following security features for all the plans:SSO for API Developer Portal
Enterprise login
Container manifest scanning
Container static scanning
Run-time container security
h3 -> Support
Community support is available for all three plans. In addition, paid support is available for Pay As You Go and Enterprise plans.",https://wso2.com/choreo/docs/reference/pricing/,864,D15
Configure Automatic Deployment,Configure Automatic Deployment,"Automatic deployment allows you to trigger a build every time you edit your component implementation and commit changes.When multiple developers collaborate to develop a component, each developer may edit the design many times. In such scenarios, it can be cumbersome to deploy the component manually for each edit. Automatic deployment eliminates this need by automatically running the build for each commit that applies a change to the component design.!!! note
Choreo allows you to configure automatic deployment only when you save the component implementation in a GitHub repository that you own and manage because Choreo-managed repositories are not accessible to external users.This tutorial walks you through the steps to enable automatic deployment for a component. In this tutorial, you will:Configure automatic deployment for a REST API.
Commit updates to the REST API implementation and observe automatic builds.",https://wso2.com/choreo/docs/deploy/configure-automatic-deployment/,164,D16
Create Your First Integration as an API,Create Your First Integration as an API,"An integration component integrates APIs, microservices, applications, and data in different languages and formats.Consider a scenario where a developer has created an integration in WSO2 Integration Studio and wants to use it for API-led integration by exposing it in Choreo. In this tutorial, you will learn how to do the following actions to address this requirement:Expose an integration created in WSO2 Integration Studio as an API in Choreo by connecting the GitHub repository in which it resides to Choreo.
Deploy the Integration component to the development environment.
Test the Integration component.
Observe statistics for the Integration component.
Publish the Integration component and try it out in the production environment.For this tutorial, let's use a basic sample application to expose a proxy service developed in the WSO2 Integration Studio.!!! tip ""Before you begin!""
To try this tutorial, you can use a sample integration designed via WSO2 Integration Studio.To do this, fork the choreo-examples GitHub repository.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-integration-as-an-api/,209,D17
Marketplace,Marketplace,"
The Marketplace is an interface provided by Choreo that allows the reuse of APIs by publishing them as connectors. It offers a range of default connectors and triggers that you can use to design your Cloud-native applications. You can purchase them, acquire them via a Freemium account, or find them free of charge. Similarly, you can publish an API or a trigger you developed to be purchased, acquired via Freemium or used free of charge by other Choreo users.By enabling the reuse of APIs, Choreo addresses the need of modern businesses to focus more on developing applications with unique functionality, and save resources by acquiring the components they need from another party who has already developed them instead of creating them from scratch.Let's explore the Marketplace.
h2 -> Access the Marketplace
To access the Marketplace, open the Choreo Console and click Marketplace in the left navigator.The Marketplace opens displaying the pre-built connectors designed and published by Choreo.{.cInlineImage-full}If you want to view the triggers published by Choreo, click on the Triggers tab.{.cInlineImage-full}If you want to filter the connectors and triggers published by your organization, click My Organization under Filter By.In addition to the connectors and triggers by Choreo displayed above, you can find a range of connectors and triggers designed and published by other vendors. Let's proceed to the next sections to find the connectors and triggers that meet the requirements of the applications you build.
h2 -> Filter by category
If you want to filter connectors and triggers by a specific domain, click on the required category (e.g., Finance), and then click on the required subcategory (e.g., Accounting).The results appear filtered by this selection as shown below.{.cInlineImage-full}
h2 -> Filter by price
To filter connectors and triggers based on whether they are free, acquirable via Freemium, or paid, select the required checkbox under{.cInlineImage-full}
h2 -> Search for connectors/triggers
You can search for the required connector via the **Search field at the top of the page.
h2 -> View connector/trigger details
Once you populate the Marketplace page by filtering or searching for connectors and triggers, you can view the following for each connector/trigger in the list:A brief description of the functionality
A label indicating the category
A label indicating whether the connector/trigger is free, acquirable via Freemium, or paid
The vendor
The date on which it was published
The number of instances the connector/trigger is usedYou can also sort the list by the newest or the most used connectors/triggers.If you want to view more information about a specific connector on the list, click on it. This directs you to an overview page with information about versions and compatibility, and links for reporting issues, accessing API documentation, contacting the vendor, etc.
h2 -> Use a connector in your component design
When you design your components in the low-code view, you can search and add the connectors displayed in the Marketplace as follows:Open the component you are designing in the VS Code Editor and add a connector.
{.cInlineImage-half}
Search for the connector you need to add (e.g., World Bank), and click on it to add it.
{.cInlineImage-half}If the connector is not available by default, you need to visit the vendor portal, make a payment/provide your Freemium account details if required, and access the required authorization tokens beforehand.e.g., If you need to use the Azure SQL DB connector, you need to create an Azure account and obtain an authorization token.
h2 -> Update a connector
If you want to introduce a change to your component and update the connector you published for it, you need to explicitly republish the connector. To learn more on how to update a connector, see Use a Connector in Your Component.",https://wso2.com/choreo/docs/marketplace/,836,D18
Configure Alerts,Configure Alerts,"
This section shows how you can configure alerts for your API manager deployments. These alerts allow you to proactively monitor your API ecosystem and take corrective measures for any abnormalities you find.You can configure alerts for each environment within your organization. You can configure and add new, modify, or delete alerts per API. Optionally, you can specify a list of emails for each alert configuration.Alerts are subject to a suppression policy to ensure that you do not receive duplicate alert notifications within a specific time interval. A 10-minute suppression window is applied by default, and it is not configurable at present. Note that the suppression policy is applicable per alert configuration.!!! info
- The maximum number of alerts that can be configured is 20 for each organization, environment, and tenant combination.
- Adding an email to an alert configuration is optional. The maximum number of emails per alert configuration is limited to 5.The alert can be a latency alert or a traffic alert.
h2 -> Latency alerts
Configure latency alerts to be notified if the response latency of APIs is greater than a predefined threshold. This is useful when you have APIs that should honor SLAs and when you want to know about slow APIs proactively.To configure a new latency alert, follow the steps below:In the Insights page, click Alert Configuration to open the Alert Configuration page.
{.cInlineImage-full}
The Latency tab is open by default.
Verify that you are in the correct organization, and select the required environment.
In the API Name field, select the API for which you want to configure the alert.
!!! Info
Only the APIs that you have invoked at least once are listed here. For other APIs, you need to give the API name in the required format as instructed in the UI.
In the Metric field, select the required metric against which you want to evaluate the alert configuration.
!!! tip
The list includes all available options. If there are multiple metrics, you can select the required metric. If there is only one metric to select, that metric is selected by default, and the field is disabled.
In the Latency field, specify the threshold in milliseconds.
!!! info
When the 95th percentile of the selected metric exceeds the threshold provided here, alerts are triggered.
If required, specify the list of emails that should be notified when the alert is generated in the Emails field.
Click Add.Once an alert is successfully added, the alert configuration  is displayed in the table in the lower section of the page. Each configuration can be edited and removed using this table. If multiple emails are configured, they are displayed in a comma-separated list.
h2 -> Traffic alerts
Configure Traffic alerts to identify if the request count of APIs is greater than a predefined threshold. This is useful when you have APIs that are using backends with traffic limits or monetized backends that require your system to proactively scale depending on the incoming traffic.To configure a new traffic alert, follow the steps below:In the Insights page, click Alert Configuration to open the Alert Configuration page.
Click Traffic to open the Traffic tab.
Verify that you are in the correct organization, and select the required environment.
In the API Name field, select the API for which you want to configure the alert.
!!! Info
Only the APIs that you have invoked at least once are listed here. For other APIs, you need to give the API name in the required format as instructed in the UI.
In the Metric field, select the required metric against which you want to evaluate the alert configuration.
!!! tip
The list includes all available options. If there are multiple metrics, you can select the required metric. If there is only one metric to select, that metric is selected by default, and the field is disabled.
In the Threshold field, specify the threshold number of requests per minute.
If required, specify the list of emails that should be notified when the alert is generated in the Emails field.
Click Add.When added successfully, the alert configuration is displayed in the table in the lower section of the page. Each configuration can be edited and removed using this table. If multiple emails are configured, they are displayed in a comma-separated list.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/configure-alerts/,883,D19
Develop Integrations with the Micro Integrator,Develop Integrations with the Micro Integrator,"Choreo iPaaS offers a platform for developing and deploying integrations with ease. With the Integration Studio, developers can create integrations using WSO2 Synapse and deploy them in a Micro Integrator (MI) runtime. Choreo iPaaS provides a centralized management system for integrations, making deployment and maintenance simple.",https://wso2.com/choreo/docs/ipaas/micro-integrator/develop-integrations-with-integration-studio/,68,D20
Define Configurable Variables,Define a configurable with a default value,"When you add a configurable to your component in the Web Editor, you can enter a specific value as the configurable value instead of ? as shown below.configurable <VARIABLE_TYPE> <VARIABLE_NAME> = <DEFAULT_VALUE>e.g., If you want to add a configurable named password of which the value should be in string format with secret as the default value, you can add the configurable statement as follows:configurable string password = ""secret"";",https://wso2.com/choreo/docs/develop/explore-code-editor/define-configurable-variables/,105,D21
Deploy Your Component,Deploy Your Component,"
Deploying your component on Choreo makes it invokable. Once you have designed, tested, and committed the REST API, you can deploy it.To deploy a component, follow the steps below:Click the Deploy icon.
Automatic Deployment is enabled by default. If you want do not want Choreo to automatically deploy the component after each commit that edits its implementation, you can disable automatic deployment,
Then in the Build Area card, click Deploy Manually.
!!! info
Choreo requires you to perform the first deployment of each component manually so that you can provide values for any configurable variables that the implementation may include.
{.cInlineImage-full}
You can view the progress of the deployment from the console.
{.cInlineImage-full}Once you deploy the component, the Development card indicates that it is active.{.cInlineImage-full}Now you can test your deployed component to check if it is working as expected.",https://wso2.com/choreo/docs/deploy/deploy-your-component/,207,D22
What is Choreo?,What is Choreo?,"
Today, with the growth of the global API ecosystem, APIs have become an essential part of modern engineering. Therefore, it has become necessary for organizations to participate in this global API supply chain by consuming and producing APIs. The adoption of cloud and microservices-based distributed architecture has also become increasingly significant, causing more and more organizations to rapidly evolve and look for innovative ways to build their digital business ecosystem. This has led to the need for a state-of-the-art iPaaS that can address the complex challenges that organizations face when connecting applications, systems, and data to build integrations and expose those integrated services to internal and external consumers in a future-proof manner.Choreo, a versatile and comprehensive platform for low-code, cloud-native engineering, provides the following advantages:An AI-assisted, low-code application development environment that can help developers build enterprise-class integrations faster while ensuring best practices and secure coding guidelines.
Developers can switch between a visual low-code and typical code environment and select the experience that best supports a given situation.
Even without expert-level coding skills, Choreo's low-code environment empowers developers to build applications with ease. It also provides capabilities to collaborate and improve these applications as needed.
Its low-code application development platform auto-generates editable and version-controlled code and maintains it in GitHub. This makes it possible to apply the engineering rigor required for enterprise applications on low-code.
API management capabilities to develop APIs and get them to production. Choreo’s API Publisher Portal allows API developers to design, publish, and manage the lifecycle of APIs whereas the API Developer Portal allows consumers to consume APIs.
Realistic DevOps with versions, environments, CI/CD pipelines, and automation tests.
Deep observability to trace your executions from the code statement level to the machine on which those run.",https://wso2.com/choreo/docs/get-started/what-is-choreo/,389,D23
Develop Integrations with Ballerina,Develop Integrations with Ballerina,"
Ballerina is a programming language for developing integration. It provides a comprehensive collection of features and tools for building and deploying integrations. Being a modern and cloud-native language, it is simple, efficient, expressive, and offers a clean syntax. Ballerina provides a range of built-in libraries and tools that enables applications to connect with a variety of services and data sources, including APIs, databases, and messaging systems. It also supports deployment on various platforms, including cloud and on-premises environments.WSO2 Ballerina-based integrations provide several advantages over traditional integration solutions. The following are a few of them:Ballerina provides a unified programming model for integrating different systems and services. Therefore, developers need to learn only one language and one set of tools. This makes it easier to build and deploy integrations.
Ballerina provides a range of security and performance features that make it easier to ensure the security and reliability of integrations.
Ballerina provides a cloud-native deployment model making it easier to deploy and manage integrations on the cloud.
h2 -> Integration types
Choreo supports the following types of integrations:Integration as an API: These integrations are exposed as APIs using HTTP.
Event-triggered Integration: Integrations that are triggered by external events.
Scheduled Integration: Integrations that are triggered automatically at scheduled time intervals
Manually-triggered Integration: Integrations that you need to trigger manually.
h2 -> Develop with VS Code Studio
Visual Studio Code (VS Code) is a versatile code editor that provides a rich user interface for developing integrations
using Ballerina. Ballerina is a modern programming language designed specifically for integration, and the Ballerina
extension for VS Code adds a range of features and tools that help developers create high-quality integrations.With the Ballerina extension for VS Code, developers can take advantage of Ballerina-specific features, including syntax
highlighting, code completion, error checking, and debugging. The integrated debugger provides an easy-to-use interface
for identifying and resolving issues with your integrations. The built-in terminal also provides a convenient way to run
commands and test your integrations.The Ballerina extension for VS Code also provides a range of user interface elements, including visual diagrams and code
snippets, which make it easier for developers to create and manage their integrations. The visual diagrams provide a
visual representation of your integrations, making it easier to see how different systems and services are connected.",https://wso2.com/choreo/docs/ipaas/ballerina/develop-integrations-with-ballerina/,532,D24
Create a Policy,Create a Policy,"You can use policies to enforce some business logic on the Request, Response, or Fault flow of an API invocation. Using policies, you can make API invocations undergo slight behavioral modifications before reaching the backend. Similarly, you can modify the API response that a client receives. In Choreo, you can add an API Policy only to an API Proxy.A policy can be implemented as a Ballerina project and attached to an API Proxy. To create a policy, follow the steps given below:",https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,100,D25
Create Your First Webhook,Create Your First Webhook,"Choreo’s low-code editor allows developers to easily design (and then implement) high-quality webhooks. To explore this capability, let's consider a scenario where a team of software engineers in an organization wants to be notified via email whenever someone creates a GitHub issue with the bug label in a specific repository.In this tutorial, you will address this requirement by doing the following:Create a webhook component by connecting to your GitHub repository that includes the implementation of the webhook that addresses the described requirement.
Deploy the webhook you created to the development environment.
Modify the webhook implementation to connect the webhook implementation to GitHub, enabling it to act in response to selected GitHub-related events.
Test the webhook.
Promote the webhook to the production environment.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-webhook/,164,D26
Connect to an External Identity Provider,Connect to an External Identity Provider,"Choreo uses an in-built Identity Provider (IdP) by default to manage OAuth 2.0 clients and generate tokens required to authenticate Choreo APIs. Choreo also allows users with administrator privileges to configure an external authorization server as an IdP via the Choreo Console (for example, Okta). As an administrator, you can add one or more external identity providers to your Choreo organization and obtain a JSON Web Token (JWT) from the identity provider to exchange for a Choreo access token to invoke APIs. This capability allows you to expose your APIs to users who reside in an external user store.",https://wso2.com/choreo/docs/administer/connect-to-an-external-identity-provider/,132,D27
Subscribe to an API,Subscribe to an API,"
Subscribing an API to an application allows Choreo to authenticate the APIs requests with the application keys. You have to subscribe to a published API to an application to invoke it using the application credentials.Alternatively, you can generate credentials for an API without an explicit subscription to an application. However, this will not let you control advanced configuration such as access token expiry time, revoke token expiry time, ID token expiry time, and enabling access to the API without a secret. Generating keys in the API is recommended for testing or short-term usage but not for long-term production usage.This guide takes you through the steps to subscribe to APIs in Choreo.Let's get started!Sign in to Choreo Developer Portal at https://devportal.choreo.dev. Alternatively, click on the Developer Portal link on the Choreo console header.
{.cInlineImage-half}
Click Applications.
Select and click on the application you want to subscribe to from the list.
Click Subscriptions from the left panel.
Click + Add APIs.
Select the usage plan and click Add to subscribe to an API.  You can subscribe to multiple APIs. You can change the usage plan after subscription as well.
{.cInlineImage-half}You can now invoke the API using the application keys.",https://wso2.com/choreo/docs/consume/manage-subscription/,282,D28
Developer Portal,Developer Portal,"
Application Programming Interfaces (APIs) are designed and built by API developers to make them available for repeated consumption for API consumers. The Choreo developer portal makes it easier for consumers to find and connect to thousands of APIs. Typically, an application developer who may be internal or external to your organization would want to consume the APIs published on the developer portal to develop software. The developer portal makes it easy for consumers to find, consume APIs, and manage subscriptions to these APIs.{.cInlineImage-full}
h2 -> Consume API
API Consumption is the process of discovering the API, subscribing to the API, generating the necessary keys, and finally invoking the API. Choreo's developer portal makes it easy for consumers to consume APIs to develop their software with an accelerated time-to-market.Choreo, by default, adopts OAuth 2.0 authentication. To consume an API in Choreo, a consumer needs to generate an OAuth 2.0 access token. The developer portal allows users to generate an access token per application: a logical grouping of subscriptions.Choreo also allows consumers to test the API in the developer portal through its interactive OpenAPI console. Consumers could then use a test key generated in the developer portal and invoke the API and evaluate the response.
h2 -> Discover APIs
APIs need to be discoverable for consumers to find the API that best matches their requirements. The Choreo developer portal makes it easy for consumers to discover APIs with comprehensive search functionality and contextual categorization based on tags.For an API to be visible on the developer portal, the API publisher needs to publish the API to the developer portal. API visibility (public or private) is also controlled by the API Publisher when the API is published. Choreo displays visible APIs on the developer portal in the order of creation, with the most recent at the top by default.{.cInlineImage-full}
h2 -> Subscribe to APIs
Consuming an API on the Choreo developer portal involves subscribing to the API. API subscriptions are grouped logically by applications. To invoke an API, you need to generate an access token. A consumer can generate an access token per application. Therefore, for an API consumer to invoke an API: the consumer needs to subscribe to the API through an application and generate a key for the application.{.cInlineImage-full}
h3 -> Applications
An application is a logical representation of a physical application such as a mobile app, web app, device, etc. An API subscription is created, authenticated, and managed through an application.{.cInlineImage-full}
h3 -> Authentication
The subscription process is authenticated in Choreo using OAuth 2.0 by default. The authentication keys are generated, by Choreo, for each application per gateway environment (Production or Sandbox). It is important to note that the API consumer should use the correct access token for the respective gateway environment when invoking the API.{.cInlineImage-full}
h3 -> Business plans
Developers need to select a business plan for each API subscription. The business plan determines the number of requests allowed for the API per minute. Therefore, this is also the rate limit that applies to a subscription.{.cInlineImage-full}
h2 -> Test APIs
Before using an API for development, the API consumer may want to test its capabilities. Choreo provides in-built capabilities to test the APIs using the in-built OpenAPI console. The in-built OpenAPI console is an interactive UI where you can easily test your API Proxy in the environments you deploy them in by selecting the required environment. Choreo, by default, uses OAuth 2.0 authentication. Therefore, the OpenAPI console gives you the option to generate your test keys to test the APIs. Once you meet the prerequisites, you can test the different resources you defined by specifying parameters if needed.{.cInlineImage-full}",https://wso2.com/choreo/docs/consume/developer-portal/,826,D29
Organization,Organization,"
An organization in Choreo is a logical grouping of users and users' resources. A first-time user can create an organization and be a member of it when signing in to Choreo. Users or resources in one organization cannot access another organization's resources unless an admin of this other organization invites them and adds them as a member of that organization. A user cannot create more than one organization.
h2 -> Switch organizations
If you are a member of more than one organization, you can switch from one organization to another. To do this, select the required organization from the Organization list in the header bar.{.cInlineImage-half}
h2 -> Inviting members
The organization admin can invite members by assigning them roles in the organization. The invited members receive the invitation as an email notification. By accepting the invitation, the members add themselves to the organization. They are then able to access the resources of that organization.
h2 -> Roles
Choreo roles are defined as follows:API Publisher: An API Publisher can discover, create, publish, delete, test, and manage an API.
API Subscriber:  An API Subscriber is a developer in a particular organization. An API subscriber can subscribe to an application, manage subscriptions, manage applications, generate API keys, and manage API keys.
Admin: An admin is responsible for all administration tasks, including IDP creation, user management, customizing the dev portal, managing projects, enabling analytics, managing domains, etc.
Billing Admin:  Is responsible for billing administration that includes viewing tiers, creating and viewing organizations, managing invoices, viewing and creating subscriptions, and viewing and creating payment methods.
Developer: A Developer focuses on developing components and solutions in Choreo. Developers can create, build, test, and manage any component type in Choreo: API, services, triggers, scheduled jobs, and Webhooks.
Env Manager: Manages deployment environments.
External API Subscriber: External API Subscribers are API consumers who have access only to the API Developer Portal. They join an organization with the sole purpose of consuming APIs.
h2 -> Theme preference
An Admin can customize the developer portal via Theme Preference. You can customize the logos,  the color palette, the typography, and the footer links.",https://wso2.com/choreo/docs/administer/organization/,484,D30
Manage Connectors,Manage Connectors,"
A connector in Choreo is a component you or another party have:Designed and developed in Choreo.
Exposed as an API in Choreo.
Published as a connector in the Choreo MarketplaceA connector lets you share your APIs privately or publicly, promoting the reuse of APIs. Developers can use them when they design their components in the low-code view. A connector lets you share your APIs privately or publicly, promoting the reuse of APIs. Developers can use them when they design their components in the low-code view. Choreo allows you to create new connectors and maintain them easily.
h2 -> Use a connector in your component design
When you design your components in the low-code view, you can search and add the connectors displayed in the Marketplace as follows:Open the component you are designing in the Web Editor and add a connector.
{.cInlineImage-small}
Search for the connector you need to add (e.g., World Bank), and click on it to add it.
{.cInlineImage-small}If the connector is not available by default, you need to visit the vendor portal, make a payment or provide your Freemium account details if required, and access the required authorization tokens beforehand.e.g., If you need to use the Azure SQL DB connector, create an Azure account and obtain an authorization token.
h2 -> Update a connector
If you want to introduce a change to your component and update the connector you published for it, you need to explicitly republish the connector.
h3 -> Update a private connector
To update a private connector, you can republish the same connector version as follows:Sign in to the Choreo Console at https://console.choreo.dev.
Navigate to your component and click  Manage.
Click Lifecycle from the left pane.
Click Republish Connector.
h3 -> Update a public connector
Public connectors are immutable. Therefore, we cannot modify and republish the already published connector version. You have to create a new component version to be able to publish a new connector version from it as follows:Create a new GitHub branch for the new connector patch version in your GitHub repository. If you are using a Choreo-managed repo, follow the steps below:
Sign in to the Choreo Console at https://console.choreo.dev.
Navigate to your component and click Overview from the left pane.
Click the Edit Code button and navigate to the Web Editor to create a new branch through the terminal using the following commands:
    git checkout -b <branch-name>
    git push origin <branch-name>
On the Choreo console, click Deploy on the left pane.
Expand the API version dropdown and click + Create New.
Select the branch you created in step 1 as the Associated Branch and provide a new version, for example, 1.0.x. Click Create to create a new patch version of the component.
Continue to deploy the component by clicking Deploy on the Build Area pane.
Click Manage on the left pane.
Click Lifecycle on the left pane.
Select the new version from the API Version drop-down.
{.cInlineImage-small}
Publish the API as a new connector.
Select the old API version from the API Version drop-down.
Click Deprecate and deprecate the previous API version.",https://wso2.com/choreo/docs/develop/advanced-topics/manage-connectors/,733,D31
Create Your First REST API Proxy,Create Your First REST API Proxy,"This tutorial introduces REST API proxies.An API Proxy exposes an existing API on Choreo and intercepts the requests to the REST API. It API Proxy acts as a managed API to which you can apply security, rate-limiting, etc.In this tutorial, you will learn how to do the following:Expose an existing API by creating a REST API proxy
Deploy the REST API proxy
Test the REST API proxy to verify its functionality
Manage your REST API proxy by adding rate limiting and security policies, thereby leveraging the platform's API management capabilities.!!!tip ""Before you begin...""
Familiarize yourself with REST API Proxies in Choreo. REST API ProxiesLet's begin!",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-rest-api-proxy/,146,D32
Map Data,Map Data - Map Data,"The data mapping feature of Choreo allows you to convert and transform one data format to another, change the structure of the data, or perform both.
You can configure a data mapping for a component when you develop it in the Web Editor.This guide walks you through a simple use case where you will input student data in a specific structure and convert and transform the student data to a different format.Let's Start!",https://wso2.com/choreo/docs/develop/explore-code-editor/map-data/,85,D33
Lifecycle,Lifecycle,"
Managing the API lifecycle is one of the main factors in API management. An API lifecycle has predefined states. These states represent the different stages the API transitions from creation to retirement. Choreo has six lifecycle states: created, pre-released, published, blocked, deprecated, and retired.
h2 -> API lifecycle states
The following lifecycle states are available in the default API lifecycle and applicable for APIs.
h2 -> Manage API lifecycle
The lifecycle of an API can be managed by the users with publishing privileges, using the Choreo Console.Follow the instructions below to manage the API lifecycle appropriately:Sign in to the Choreo Console at https://console.choreo.dev/.
Select and click on the API component you want to test from the components list.
in the left panel, click the Manage icon to open the test view.
In the left pane, click Lifecycle.
Click on the lifecycle state change buttons to change the lifecycle state.",https://wso2.com/choreo/docs/manage/lifecycle/,215,D34
Performance Analysis,Performance Analysis,"The Performance Analyzer tool is an AI-based tool that generates intelligent estimations of the performance of integration-based services and APIs based on historical data. The Performance Analyzer tool allows developers to obtain forecasts at development time using advanced machine learning techniques and mathematical performance models.Traditionally, performance analysis includes performance debugging which involves measuring the performance of services by load testing them. The Performance Analyzer allows you to measure performance at the application development stage, significantly reducing the time and cost spent on performance debugging.A component may have more than one execution path serving requests. The Performance Analyzer tool can analyze all the execution paths and determine the performance-critical path: the path that is estimated to take the longest time to process a single request.",https://wso2.com/choreo/docs/observe-and-analyze/performance-analysis/,148,D35
View API Insights,View API Insights,This section explains how you can view insights about the APIs deployed in your organization.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/view-api-insights/,16,D36
Observability Overview,Observability Overview,"Observability in Choreo provides the capability to visualize and monitor the performance of services deployed on Choreo. Choreo has in-built support for viewing the overall status, latencies, throughput data,  diagnostic data, and logs. Hence, you can use Choreo Observability to detect and troubleshoot anomalies in your services efficiently.",https://wso2.com/choreo/docs/observe-and-analyze/observe/observability-overview/,73,D37
Configure a Custom Domain for APIs,Configure a Custom Domain for APIs,"
A custom domain for your site is essential for effective branding, discoverability, and credibility. Choreo allows you to configure a custom domain for the APIs you deploy in it.To understand how to configure a custom domain for your APIs, see the following sections:
h2 -> Prerequisite
To configure a custom domain for your APIs, you must first register a custom domain with a domain registrar service as follows:Sign in to the Choreo Console at https://console.choreo.dev/ using a Google, GitHub, or Microsoft account.
If you are a new user, create an organization. Enter a unique organization name. For example, Stark Industries Ltd.
{.cInlineImage-small}
To expose the custom domain to which your APIs need to be exposed, register it with a domain registrar service (for example, ClouDNS).
To register the custom domain, you need to create a DNS record of the CNAME type via the domain registrar service, associating it with the Choreo gateway access domain (i.e., customdns.e1-us-east-azure.choreoapis.dev).
Optionally, create TLS certificates and keys to enable TLS for the custom domain. You can also use the let's encrypt option. This option allows Choreo to create and manage the certificates on your behalf.
h2 -> Configure a custom domain for your APIs
To configure a custom domain for your APIs, follow the steps given below:In the left navigation menu, click Settings.
Click the Domains tab and in the Gateway sub-tab, click + Add Custom Domain.
Enter your domain name and click Verify.
{.cInlineImage-half}
Once Choreo verifies the custom domain successfully, click Next.
You can add the TLS certificates you created for the custom domain. Alternatively, you can click the Let's Encrypt option to let Choreo generate and manage the certificates for you. For this scenario, let's click the Let's Encrypt option.
Click Add to save the custom domain.
The Settings page displays the custom domain in the Domains/Gateway sub-tab.
{.cInlineImage-threeQuarters}That's it! You have successfully configured a custom domain for your API Gateway. The API endpoint of the APIs you create will now include the custom domain as shown in the image below:{.cInlineImage-threeQuarters}",https://wso2.com/choreo/docs/administer/configure-a-custom-domain-for-apis/,519,D38
Choreo Insights API,Choreo Insights API,"Choreo Insights API is a GraphQL API that allows you to fetch data in a flexibly by defining the criteria with precision. This guide explains the different ways in which you can fetch data via this API.Allowed operations: Queries
Schema-defined types: Objects, Inputs, Enums, and Scalars##Try outYou can try out the Choreo Insights API with your data via GraphQL Explorer.!!! warning
You cannot work with the GraphQL Explorer with the Safari web browser at present due to this issue in the browser.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,116,D39
Policies,Policies,"
Policies are units of business logic that a user can apply to slightly change the  Request, Response, or Error flow of an API invocation before reaching the backend or the client. For example, you can modify the response of an API invocation by adding a policy to the Response flow to transform the payload from JSON to  XML and to add a header in the response.Choreo includes a default set of policies covering most of the common use cases. You can attach one or more policies to the component implementation easily through the Choreo Console. Furthermore, you can attach multiple policies, swap, and rearrange them conveniently.In Choreo, once you attach a mediation policy to a proxy, the deployment, internally, is a two-step process.Deployment initiation
If the component to which you attached the mediation policy is new, the system creates and commits a new repository with the mediation service code based on the attached policies. This new service is referred to as the interceptor application.
Deploying the API
Once the deployment initiation is complete, you can provide any configurations required and proceed to deploy. In this step, Choreo builds the generated interceptor application and pushes the Docker image to the Docker registry. Finally, Choreo deploys the interceptor application with the mediation service and the API Proxy.Depending on the flow to which the mediation policy is attached, the API invocation will undergo the respective behavioral modification as follows:In the request path, the requests that pass through the gateway reach the relevant component, and Choreo executes any attached policies to the resource's request path before sending it to the backend.
In the response path, the response messages from the backend are first received by the interceptor component, and Choreo executes any mediation policies attached to the Response flow or the Error flow. Then the response is forwarded to the client.
In the event an error occurrs during the execution of policies or due to an internal error, the Error flow is executed and an error response is sent to the client.
h2 -> Monitoring and troubleshooting the deployment
You can check logs at each stage of the deployment in the console that opens on the right of the page. To open this console, click on a build from the Build and Deployment History in the Build Area.
h4 -> Code Generation
This is the stage where the interceptor application is generated based on the mediation policies. In this stage, if there are any errors, the user can view them in the console. If the error is due to a user error, for example, an error related to the API definition, etc., based on the logs the user can fix the issue and retrigger a build.
h4 -> Build
The build stage builds the interceptor application as a Docker image and deploys it in the respective environment. For logs related to the build, you can refer build logs of both Ballerina and Docker.Any errors that occur in this stage are not due to user error. If an error occurs, you need to retry the deployment.",https://wso2.com/choreo/docs/develop/api-policies/policies/,626,D40
Test an API,Test an API,"
Before using your API in production, you can test it using the integrated console in Choreo. Once you deploy your API in the required environment, an API consumer can use the application credentials, generate an OAuth 2.0 token, and invoke the API to test its functionality by providing values for the required parameters.This guide will take you through the steps to test an API in Choreo.Sign in to Choreo Developer Portal at https://devportal.choreo.dev. Alternatively, click Developer Portal  on the Choreo Console header.
{.cInlineImage-half}
Click APIs.
Select an API you want to test and click Try Out on the card. In this case, skip step 4. Alternatively, you can click on the API and follow step 4.
In the left pane, click Try Out.
Select the required environment from the Environment list.
{.cInlineImage-half}
From the Subscribed Application list, select the application you used to subscribe the API to. To learn how to subscribe to an application, see Manage Subscriptions.
Click Get Test Key on the Access Token field to generate a test access token. To learn more about access tokens and generating tokens for production usage, see Manage Applications.
Next, expand a resource you want to test by clicking on it.
{.cInlineImage-half}
Click Try it Out to enable the resource to be tested.
Fill in values for the required parameters and click Execute.
{.cInlineImage-half}
Once Choreo executes the request, you can view the response in the Choreo Console.",https://wso2.com/choreo/docs/consume/test-api/,350,D41
Generate Custom Reports,Generate Custom Reports,"
Choreo insights allow you to generate custom reports to view the information that is important to you to make timely decisions for the betterment of your business. With custom reports, you can generate reports for a set of metrics of your choice and aggregate results by specific fields. Once generated, the metrics can be filtered out using any selected group-by filters. Custom reports support three visualizations: overtime charts, pie charts, and tables.
h2 -> Metrics
Choreo Insights allow you to retrieve data for the following metrics:Successful Hit Count
Response Cache Hits
Request Mediation Latency
Response Mediation Latency
Backend Latency
Total Latency
API Errors
Target Errors
h2 -> Group-by
Group-by fields specify how to group the metric data. e.g., You can select Successful Hit Count in the Metrics field and API Name under Group-by to retrieve the successful hit count grouped by the API name.Choreo Insights allow you to group metric data by the following fields:API Name
API Version
API Resource Template
API Method
API Creator
Application
Application Owner
Destination
User Agent
PlatformTo generate a custom report, follow the steps below:In the left navigation menu, click Custom Reports.
{.cInlineImage-full}
Select metric(s) from the Metrics drop-down selector.
{.cInlineImage-full}
Select a minimum of 1 and a maximum of 3 group-by field(s) from the Group By drop down selector.
Set the order of the group-by filters by drag and drop to determine the grouping order of the selected metric(s).
Once you determine the order of the group-by fields, you can set values for each group-by field from the respective dropdown.
{.cInlineImage-full}
Click Generate.
{.cInlineImage-full}
h2 -> Download Reports
Choreo Insights allow you to download report data related to each chart as a PDF or a CSV file.To do this, click the Download icon on the top right of the relevant chart and select the required file format.
{.cInlineImage-full}",https://wso2.com/choreo/docs/observe-and-analyze/analyze/generate-custom-reports/,469,D42
Forecast Performance Metrics,Forecast Performance Metrics,"The Performance Analyzer tool is an AI-based tool that generates intelligent estimations of the performance of integration-based services and APIs based on historical data. The Performance Analyzer tool allows developers to obtain forecasts at development time using advanced machine learning techniques and mathematical performance models.Traditionally, performance analysis includes performance debugging which involves measuring the performance of services by load testing them. The Performance Analyzer allows you to measure performance at the application development stage, significantly reducing the time and cost spent on performance debugging.A component may have more than one execution path serving requests. The Performance Analyzer tool can analyze all the execution paths and determine the performance-critical path: the path that is estimated to take the longest time to process a single request.",https://wso2.com/choreo/docs/develop/run-and-test/forecast-performance-metrics/,148,D43
Create Your First Event-triggered Integration,Create Your First Event-triggered Integration,"Choreo allows you to deploy, test, manage, and observe integration components that integrate APIs, microservices, applications, and data in different languages and formats.To explore this capability, let's consider a scenario where a team of software engineers in an organization wants to be notified via email whenever someone creates a GitHub issue with the bug label in a specific GitHub repository.In this tutorial, you will address this requirement by doing the following:Create an Event-triggered Integration component by connecting to your GitHub repository where the webhook implementation that addresses the described requirement resides.
Deploy the event-triggered integration you created to the development environment.
Update the implementation of the event-triggered integration, enabling it to listen to selected GitHub events and act in response.
Test the event-triggered integration.
Promote the event-triggered Integration to the production environment.",https://wso2.com/choreo/docs/ipaas/ballerina/create-your-first-event-triggered-integration/,182,D44
Scheduled Tasks,Scheduled Tasks,Learn how to use scheduled tasks to execute routine tasks at specified time intervals.,https://wso2.com/choreo/docs/develop/components/scheduled-tasks/,15,D45
Customize the Developer Portal,Customize the Developer Portal,"
The Developer Portal allows API consumers to find and consume APIs with ease. You can change the look and feel of your Developer Portal by changing the theme to match your brand. Doing so will help you give a better developer experience to your users.To customize the Developer Portal theme, follow the steps given below:!!! Note
- To customize the Developer Portal theme for an organization, you need to be an admin user of that organization.
- You cannot undo a change and restore or revert to a previous version of the theme. However, you can reset it to the default theme.Sign in to the Choreo Console at https://console.choreo.dev/ using a Google, GitHub, or Microsoft account.
In the left pane, click Settings.
In the API Management tab, click Devportal Theme.
{.cInlineImage-threeQuarters}
Once you access the theme, you can customize the Home page, color theme, font, header and footer, logos, etc., by expanding the relevant sections.
Make a change to the theme. For example, let's change the title on the Home page and the color theme.
To update the title on the Home page, expand the Home Page section, and in the Title field, change the default text (for example, to Try our APIs!).
To update the color theme, expand the Color Palette section, and change the colors as required (for example, change the background color to #C3C5CD and the primary color of the buttons to #086634).
Click Preview to view a preview of the Developer Portal with the changes you made. Based on the changes given in the examples, the preview appears as follows.
{.cInlineImage-threeQuarters}
Click Save to save your changes as a draft theme.
To apply the changes to the Developer Portal, toggle the Go Live switch. To confirm that you want to go live with the changes, click Enable in the message that appears.
If you want to make further changes to the Developer Portal theme after going live with the previous changes, follow the steps given below:
Make the required changes and click Save.
If you want to apply the latest changes to the Developer Portal, click Confirm in the Proceed to Go Live message. If not, click Cancel.
!!! info
 If you did not apply the latest changes to the Developer Portal, you can publish them later or discard them.<br/>![Publish or discard Developer Portal changes](../assets/img/administration/devportal-theme/publish-or-discard-developer-portal-changes.png){.cInlineImage-threeQuarters}
Sign in to the Choreo Developer Portal at https://devportal.choreo.dev.The Home page will appear as it did in the preview.
h2 -> Reset the Developer Portal theme
To reset the Developer Portal theme to the default theme, follow the steps given below:Sign in to the Choreo Console at https://console.choreo.dev/ using a Google, GitHub, or Microsoft account.
In the left pane, click Settings.
In the Organization tab, click Devportal Theme, and then click Reset to Default.",https://wso2.com/choreo/docs/administer/customize-the-developer-portal/,680,D46
REST API Proxy,REST API Proxy,Learn how you can expose an existing API through a REST API Proxy in Choreo and go on to manage it leveraging the full API Management capabilities of Choreo.,https://wso2.com/choreo/docs/develop/components/api-proxy/,34,D47
Handle Non-Ballerina Files in Choreo,Handle Non-Ballerina Files in Choreo,"
You can add and use non-Ballerina files such as .pem, .txt, etc. in the integration solution you are developing in Choreo. You can add these files to the web editor (Choreo low-code editor) or keep them in your GitHub repository.If you run and test this solution with non-Ballerina files in the web editor, you get the expected outcome as the files are available in the environment. However, at build time, Choreo only copies the Cloud.toml and the Ballerina target/jar files to the Docker container. The target/jar does not by default include the non-Ballerina files you add into Choreo. Therefore, Choreo does not copy the non-Ballerina files to the Docker container unless explicitly mentioned in the Cloud.toml file. This may lead to a no such file or directory error at runtime.To avoid the error no such file or directory and to copy the non-Ballerina files to the Docker container, follow the guidelines below:
h2 -> Troubleshoot the no such file or directory error
If you are using the Web Editor, commit and push the non-Ballerina files from the web editor to the GitHub repository.
Add the file reference to the Cloud.toml.For example, if you added a file data.txt at /config/workspace/data/data.txt add the following entry to the Cloud.toml file.[[container.copy.files]]
sourceFile=""./data/data.txt""
target=""/home/ballerina/data/data.txt""!!! note
- sourceFile: the file's relative path to the repository root. (For example, dir1/file1.json and not /config/workspace/dir1/file1.json)
- target: the target is where Choreo copies the artifacts in the Docker container. The target must always have the path prefix /home/ballerina/.",https://wso2.com/choreo/docs/develop/explore-code-editor/handle-non-ballerina-files-in-choreo/,422,D48
Test your REST API,Test your REST API,"
!!! note
If you are on the Deployment tab, click Test in the Development card and continue from step 4 onward.Sign in to the Choreo Console at https://console.choreo.dev/.
In the component list, find the API component that you want to test and click it.
To open the test view, click the Test on the left navigation menu.
Click Try it out.
Enter any parameter values if necessary.
Click Execute.
You can view the response body under Responses.
{.cInlineImage-full}Congratulations! You have now successfully created and tested a REST API in Choreo!",https://wso2.com/choreo/docs/test/open-api-console/,137,D49
Customize the Developer Portal Domain,Customize the Developer Portal Domain,"
A custom domain for your site is essential for effective branding, discoverability, and credibility. Choreo allows you to configure a custom domain for your organization's developer portal.Follow the steps below to configure the custom domain for the Developer Portal:
h2 -> Prerequisites
Sign in to the Choreo Console at https://console.choreo.dev/ using a Google/ GitHub/ Microsoft account.
If you are a new user, create an organization. Enter a unique organization name. For example, ""Stark Industries"".
{.cInlineImage-small}
Obtain a custom domain through a domain registrar.
Through your DNS administrator, create a CNAME type DNS record and associate it with the Choreo Developer Portal custom access domain: customdns.devportal.choreo.dev.
Optionally, create TLS certificates and keys to enable TLS for the custom domain. For testing purposes, you can also opt to use the let's encrypt option. This option allows Choreo to create and manage the certificates on your behalf.
h2 -> Configure a custom domain for your Choreo Developer Portal
Click Settings on the left navigation menu.
Click the Domains tab and then click on the Developer Portal tab.
Click Add Custom Domain.
Enter your domain name and click Verify. Once Choreo verifies the custom domain successfully, click Next.
Add the TLS certificates you created for the custom domain and click Add. Alternatively, you can click the Let's Encrypt option to let Choreo generate and manage the certificates for you. However, we recommend you use Let's Encrypt for testing only.That's it! You have successfully configured a custom domain for your organization's Choreo Developer Portal.",https://wso2.com/choreo/docs/administer/customize-developer-portal-domain/,366,D50
Permissions,Permissions,"
Permissions allow you to attach scopes that enable fine-grained access control to your API resources. You can create a scope entry by giving a scope name. You can then select and apply these scopes to the individual resources in your API. On the identity provider, a scope will have a role mapped to it. A role specifies the permissions associated with it. When you invoke the API resource with a specific scope, the access to your API resource is controlled based on the permissions associated with the role.
",https://wso2.com/choreo/docs/manage/api-management/,104,D51
Settings,Settings,"
The Choreo Console allows you to define security, rate-limiting, and visibility settings for an API. You can configure the following settings:Access mode - Configure API access as internal or external.
API Visibility - Configure API visibility as private or public.
CORS configuration - Enables CORS configurations and provides necessary CORS headers.
Application level security - This determines the type of security used to safeguard this API.  You can secure your APIs with OAuth 2.0, any other available security scheme, or both. If the OAuth 2.0 option is selected, that API will need a valid OAuth 2.0 token for successful invocation.
Operations Configuration - Configure rate limiting to your API in Choreo per API operation.
",https://wso2.com/choreo/docs/manage/api-management/,161,D52
Properties,Properties,"
You can view and edit the API properties (i.e., the business owner's name and email and the technical owner's name and email) from the Choreo Console.""",https://wso2.com/choreo/docs/manage/api-management/,37,D53
Consumers,Consumers,"
The Consumers pane shows us the applications that have subscribed to your API. You can manage access to your API by blocking or unblocking these applications through the Choreo Console. The Consumers pane lists the applications, and for each application, it shows the usage tier, owner, and status: blocked or unblocked.
",https://wso2.com/choreo/docs/manage/api-management/,66,D54
REST APIs,REST APIs,"Explore how you can easily design, develop, and manage REST APIs in Choreo to implement your business API strategy.",https://wso2.com/choreo/docs/develop/components/rest-api/,24,D55
Lifecycle,Lifecycle,"
Choreo allows you to manage the lifecycle of the API through the Choreo Console. A state represents the stage of an API in the process from creation to retirement. You can apply any of the six API lifecycle states (i.e.,Created, Pre-released, Published, Blocked, Deprecated, and Retired) while adhering to their respective lifecycle flows.When you publish an API, you can also publish a connector for that API to make it available on the Choreo Marketplace.
",https://wso2.com/choreo/docs/manage/api-management/,109,D56
Create Your First Event-Triggered Integration,Create Your First Event-Triggered Integration,"Event-triggered integrations can help automate business processes and reduce manual work. Choreo allows you to create and manage event-triggered integrations without a complex infrastructure setup.Consider a scenario where a developer has already created an integration using WSO2 Integration Studio and wants to deploy it on Choreo to create an event-triggered integration. This tutorial walks you through the steps to accomplish this requirement.In this tutorial, you will do the following:Create an event-triggered integration component in Choreo by connecting a GitHub repository with a sample application developed using WSO2 Integration Studio.
!!! info
The sample application listens to a RabbitMQ topic and logs incoming messages.
Deploy the integration component to the development environment in Choreo.
Test the integration component.!!! tip ""Before you begin""
- Fork the sample application GitHub repository. For this tutorial, you need the simple-rabbitmq-listener in the choreo-sample repository.- Use an existing RabbitMQ instance or start a new [RabbitMQ](https://www.rabbitmq.com/download.html) instance on a server that can be accessed via the internet. Obtain the `username`, `hostname`, `password`, and `vhost` from the RabbitMQ instance to use later as environment variables.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-event-triggered-integration/,277,D57
Manage Applications,Manage Applications,"An application in Choreo is a logical representation of a physical application such as a mobile app, web app, device, etc. To consume an API in Choreo, you need to create an application that maps to your physical application and then subscribes to the required API over a usage policy plan that gives you a usage quota. A single application can have multiple subscriptions to APIs. Using the consumer key and consumer secret, you can generate an access token that you can use to invoke all the APIs subscribed to the same application.This section will walk you through the steps to create an application in Choreo.Let's get started!",https://wso2.com/choreo/docs/consume/manage-application/,129,D58
Overview,Overview,"
The overview of the Manage page gives you a bird's eye view of how you currently manage your API component. You can view the lifecycle status of your component, the number of consumers, the security scheme configured, and the usage plan applied to the API. The Overview pane also lists the environment(s) of the API.
",https://wso2.com/choreo/docs/manage/api-management/,69,D59
Documents,Documents,"
API documentation is vital in helping API consumers understand the functionality of your API and is beneficial to marketing the API. The Choreo Console allows you to add a document on the fly by entering a name and the API contents. You can also preview the document and verify if it is suitable for publishing.
",https://wso2.com/choreo/docs/manage/api-management/,62,D60
Create Your First Integration,Create Your First Integration,"An integration component integrates APIs, microservices, applications, and data in different languages and formats.Consider a scenario where a developer has created an integration in WSO2 Integration Studio and wants to use it for API-led integration by exposing it in Choreo. In this tutorial, you will learn how to do the following actions to address this requirement:Expose an integration created in WSO2 Integration Studio as an API in Choreo by connecting the GitHub repository in which it resides to Choreo.
Deploy the Integration component to the development environment.
Test the Integration component.
Observe statistics for the Integration component.
Publish the Integration component and try it out in the production environment.For this tutorial, let's use a basic sample application to expose a proxy service developed in the WSO2 Integration Studio.!!! tip ""Before you begin!""
To try this tutorial, you can use a sample integration designed via WSO2 Integration Studio.To do this, fork the choreo-examples GitHub repository.",https://wso2.com/choreo/docs/ipaas/micro-integrator/create-your-first-integration/,209,D61
Manage,Manage,"
Choreo's API Management capabilities allow you to manage your APIs through the Choreo Console. You can manage the lifecycle, consumers, and documents, secure your backends by applying rate-limiting policies through usage plans, define permissions using scopes, configure security, rate-limiting, and visibility settings, and define any properties.
",https://wso2.com/choreo/docs/manage/api-management/,72,D62
GraphQL APIs,GraphQL APIs,"Explore how you can easily design, develop, and manage GraphQL APIs in Choreo to implement your business API strategy.",https://wso2.com/choreo/docs/develop/components/graphql-api/,25,D63
Open API Console,Open API Console,"
Choreo allows you to test your APIs using the integrated OpenAPI Console, the generated cURL command, or by integrating Postman to Choreo. Once you have created an API and deployed it, it is ready to be tested.You can follow the steps below to test your REST API using the integrated OpenAPI Console:
",https://wso2.com/choreo/docs/test/open-api-console/,69,D64
cURL,cURL,"
Choreo allows you to test your APIs using the integrated OpenAPI Console, the generated cURL command, or by integrating Postman to Choreo. Once you have created an API and deployed it, it is ready to be tested.You can follow the steps below to test your REST API using the Choreo-generated cURL command :
",https://wso2.com/choreo/docs/test/curl/,73,D65
Create Your First REST API,Create Your First REST API,"A RESTful API (Application Program Interface) uses HTTP requests to access and use data. The operations you can perform on data are GET (reading), PUT (updating), POST (creating), and DELETE (deleting).Choreo’s low-code editor allows developers to easily design (and then implement) high-quality REST APIs. To explore this capability, let's consider a scenario where an Analyst needs to retrieve the daily count of COVID-19 patients per one million population by country. In this tutorial, you will address this requirement by doing the following:Design a REST API that addresses the described requirement, test it in the Web Editor, and then commit it so that it is available in the Choreo Console.
Deploy the REST API you created to make it available for use.
Test the REST API after deploying it to check whether it works as expected.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-rest-api/,185,D66
Test your REST API,Test your REST API,"
!!! note
If you are on the Deployment tab, click Test in the Development card and continue from step 4 onward.Sign in to the Choreo Console at https://console.choreo.dev/.
From the components list, find the API component you want to test and click it.
To open the test view, click the Test on the left navigation menu and then click cURL.
Select the method, and configure the parameters, headers, and body required to invoke the API method selected.
Copy the cURL command generated under Command.You can use this copied cURL command and test the API method on a cURL client.Congratulations! You have now successfully created and tested a REST API in Choreo!",https://wso2.com/choreo/docs/test/curl/,152,D67
Alerts,Alerts,"Alerts are notifications sent by the Choreo Alert Manager when the components that run in the production environment are not functioning as expected. Whenever a critical error (e.g., out-of-memory error) occurs, the component logs an error, and the Alert Manager notifies the members of your organization with admin rights via an email. This email contains a link to the Observability tab of the component where the metrics and logs applicable to the time interval in which the error occurred are highlighted. The Alert Publisher collects and sends alerts to Alert Manager every five minutes, which then decides when to send these alerts to the users.",https://wso2.com/choreo/docs/alerts/,126,D68
Attach a Policy,Attach a Policy,"
You can attach a policy to the Request, Response, or Error flow of the  REST API Proxy as follows:Sign in to the Choreo Console at https://console.choreo.dev.
From the component list, select and click on the REST API Proxy component to which you want to attach the policy(s).
In the left navigation menu, click Develop  and then click Policies.
From the list of resources, expand the resource to which you want to attach the policy(s).
Click Attach Policy for the relevant flow (i.e., Request, Response, or Error) to which you want to attach the policy.
{.cInlineImage-threeQuarter}
From the Policy List panel on the right-hand side, select the policy you want to apply and click Add.
{.cInlineImage-small}
Click Save.
h2 -> Configuring the policy to accept environment-specific parameters
You can use policies that enable users to enter custom parameters and values. For example, Add Header policy requires the user to enter a header name and value when deploying the REST API Proxy. These parameters can be static values or environment-specific values.To add environment-specific values and policy parameters, follow the steps given below::Sign in to the Choreo Console at https://console.choreo.dev.
From the component list, select and click on the REST API Proxy component to which you want to attach policies.
In the left navigation menu, click Develop  and then click Policies.
From the list of resources, expand the resource to which you want to attach the policy(s).
Click Attach Policy for the relevant flow (i.e., Request, Response, or Error) to which you want to attach the policy.
Add a policy that enables you to accept custom parameters and values from users. For example, the Add Header policy.
![Add header](../../assets/img/api-proxies/policies/add-header.png){.cInlineImage-full}
Enter values for the required policy parameters when prompted. If you want to make a parameter a configurable variable, enter the value in ${<variableName>} format. For example, ${name}.
![Configurable values](../../assets/img/api-proxies/policies/configurable-values.png)
Click Add and then click Save.
To deploy the component, from the left navigation menu, click Deploy and then click Config & Deploy. When the interceptor application generation step is complete, you can provide the configurations.
When prompted, provide the value and click Save & Deploy.
{.cInlineImage-full}",https://wso2.com/choreo/docs/develop/api-policies/attach-policies/,572,D69
Usage Plans,Usage Plans,"
You can secure your API backends by applying rate-limiting policies through the Usage Plans pane, typically in cases such as the following:To protect your APIs from common types of security attacks, such as certain types of denial of service (DOS) attacks
To regulate traffic according to infrastructure availability
To make an API, application, or resource available to a consumer at different levels of service, usually for monetization purposeChoreo allows you to apply a usage plan on the API that is not bound to an environment or build. Choreo supports the following usage plans by default:Bronze - 1000 requests per minute.
Silver - 2000 requests per minute.
Gold - 5000 requests per minute.
Unlimited - unlimited requests per minute.
",https://wso2.com/choreo/docs/manage/api-management/,153,D70
Create Your First Event-triggered Integration,Prerequisites,"For this tutorial, let's create the event-triggered integration from a Ballerina project. To create a Ballerina project and add it to a private GitHub repository, follow the steps given below:Create a Ballerina project by following the instructions on Ballerina Site - Get Started with Ballerina.
Create a new repository in your GitHub account and commit the Ballerina.toml file and the Main.bal from your Ballerina project to its root directory or sub-directory as you prefer.",https://wso2.com/choreo/docs/ipaas/ballerina/create-your-first-event-triggered-integration/,108,D71
Alerts,Types of alert email notifications,"When an alert occurs for the first time during the alerting interval, the Choreo Alert Manager sends an alert email immediately. When there are multiple occurrences of the same type of alert for a particular component, the Choreo Alert Manager suppresses the alerts for 15 minutes and generates a single email that specifies the event count to denote how many such errors occurred during an alerting interval.",https://wso2.com/choreo/docs/alerts/,78,D72
Manage Applications,Step 2: Generate keys - Access token for production - part 2,"Keep Token Exchange and Refresh Token grant type selected. Public Client: Identify the application as a public client to allow authentication without a client secret. You can use this for applications running on a browser or mobile device. Application access token expiry time: The access token expiry time (seconds). Refresh token expiry time: The refresh token expiry time (seconds). ID token expiry time: ID token expiry time (seconds). Click Generate Credentials to generate the credentials for the application for the first time. Copy the Consumer Key value. Generate an access token by invoking the token endpoint using the Token Exchange grant type as follows: replace the <application_consumer_key> with the Consumer Key you copied at step 7 and replace <idp_id_token> with the id_token value you obtained at step 2: curl -k -X POST https://sts.choreo.dev/oauth2/token -d ""client_id=<application_consumer_key>"" -d ""subject_token_type=urn:ietf:params:oauth:token-type:jwt"" -d ""grant_type=urn:ietf:params:oauth:grant-type:token-exchange"" -d ""subject_token=<idp_id_token>"" curl -k -X POST https://sts.choreo.dev/oauth2/token -d ""client_id=ciwnWuwZfbcdzBUcnkhKvi_mcBUa"" -d ""subject_token_type=urn:ietf:params:oauth:token-type:jwt"" -d ""grant_type=urn:ietf:params:oauth:grant-type:token-exchange"" -d ""subject_token=eyJhbGciOiJFUzI1NiIsImtpZCI6IjE2In0.eyJhdWQiOiJodHRwczovL2FzLmV4YW1wbGUuY29tIiwiaXNzIjoiaHR0cHM6Ly9vcmlnaW5hbC1pc3N1ZXIuZXhhbXBsZS5uZXQiLCJleHAiOjE0NDE5MTA2MDAsIm5iZiI6MTQ0MTkwOTAwMCwic3ViIjoiYmNAZXhhbXBsZS5uZXQiLCJzY3AiOlsib3JkZXJzIiwicHJvZmlsZSIsImhpc3RvcnkiXX0.JDe7fZ267iIRXwbFmOugyCt5dmGoy6EeuzNQ3MqDek9cCUlyPhQC6cz9laKjK1bnjMQbLJqWix6ZdBI0isjsTA"" { ""access_token"": ""eyJ4NXQiOiJNV1E1TldVd1lXWmlNbU16WlRJek16ZG1NekJoTVdNNFlqUXlNalZoTldNNE5qaGtNR1JtTnpGbE1HSTNaRGxtWW1Rek5tRXlNemhoWWpCaU5tWmhZdyIsImtpZCI6Ik1XUTVOV1V3WVdaaU1tTXpaVEl6TXpkbU16QmhNV000WWpReU1qVmhOV000Tmpoa01HUm1OekZsTUdJM1pEbG1ZbVF6Tm1FeU16aGhZakJpTm1aaFl3X1JTMjU2IiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiJiNWViODFkMC01ZTMxLTQwZDgtYWY0MS03OWMwMjJlNTRhNTciLCJhdXQiOiJBUFBMSUNBVElPTl9VU0VSIiwiYXVkIjoibzRUWGxLQnowYWVJNEJ0d2NjY0V4bnVyNENVYSIsIm5iZiI6MTY2Mzg0MTM5MiwiYXpwIjoibzRUWGxLQnowYWVJNEJ0d2NjY0V4bnVyNENVYSIsInNjb3BlIjoiZGVmYXVsdCIsIm9yZ2FuaXphdGlvbiI6eyJ1dWlkIjoiZWMwZDE5OTgtZTRkNS00NjRlLWFjODgtOTg4ODM5NTYwZDVkIn0sImlzcyI6Imh0dHBzOi8vc3RzLmNob3Jlby5kZXY6NDQzL29hdXRoMi90b2tlbiIsImV4cCI6MTY2Mzg0NDk5MiwiaWRwX2NsYWltcyI6eyJhdXQiOiJBUFBMSUNBVElPTl9VU0VSIiwiYXV0aGVudGljYXRlZF9pZHAiOiJHb29nbGUiLCJuYW1lIjoid3NvMmUiLCJnaXZlbl9uYW1lIjoid3NvMiIsImZhbWlseV9uYW1lIjoid3NvMiIsImVtYWlsIjoid3NvMiJ9LCJpYXQiOjE2NjM4NDEzOTIsImp0aSI6ImM0MmRhNmM5LTYxYjEtNDUwNi1hMmYyLWY4OGE5MjQzNjk1MiJ9.M8FqUMDB1uvRTbz-AAxbl9af_72BLrSnTomGwasCzK4qRwVtV7MENLXFVzTZMW0ayBjPDQ8QeTmaky2LwAFKf0AYdGMtBYL0VLVWtBND7RCip_gxpa1k-Z5V4Cl5qcvKuLpySyE7E2QQqR9lPIHE-bm70nyWQheNMCEnPAKihyP772AEn3xRobHFGB_sidVuRAQm815GFE56NovKeBUM1YLmdnUgIrL1B9ho2q0g8aAI7959ORy9xQXLqxcYN-rd8uUnY5jWXPzxJHDDaozgHUK02IDKx0a-9Bf1Gy2Hj0DSQFRWZbPpfq7oMzCeRprqCYYkPkTjOz-LpyE9Ri-xTZNRbm7hua5PrRJjDD_EbsT8zYolRvIlwl7GcQOQuOtyxS4l_hQmb3DDmyFouv_P4Aknse4FvD8mSeXmvaTelyS5hBp0KNAoxkQBrRVgHVv_Jjyt2s9FwDhmLl4uS46x5Ca58X_wU6kEBP2hmfa98JHcfklog3gsxTm0T0JZlGs23zNqaf-ApC7NU9hWVZ6fwIX3CUzZNZmhF4caNrLJEqUnuxB5fHrHiwMNnoXf3WAILHj5gJPZo9OG18yymIdbRjHYrpD1ZQihIkPBTeMXwfRWIMDfBD3ezDKajktKqM8w1E-sFuGLHWyCqREN4XWA_jcZ6766BtTareAfKH171Ok"", ""refresh_token"": ""a23h07f9-6ce5-3b7a-9d12-00e7f82f4f46"", ""issued_token_type"": ""urn:ietf:params:oauth:token-type:jwt"", ""scope"": ""default"", ""token_type"": ""Bearer"", ""expires_in"": 3600 } !!! tip Save the refresh token and access token since you won't be able to view it again.",https://wso2.com/choreo/docs/consume/manage-application/,2002,D73
Create Your First REST API Proxy,Step 1: Create a REST API Proxy,"You can create a REST API proxy in one of the following methods:In this tutorial, you will be providing a URL to an OpenAPI definition of a sample API.Sign in to the Choreo Console at https://console.choreo.dev.
Click + Create Project. Enter a unique name and a description for the project, and click Create.
On the REST API Proxy card, click Create.
Click Try with Sample URL to create an API proxy for a sample API.
Enter API proxy details as follows:
Field
Value
Name
HR API
Base Path
<DEFAULT_VALUE>/ abc-hr
Version
1.0.0
Target
https://samples.choreoapps.dev/company/hr
Click Create.The API proxy opens on a separate page.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-rest-api-proxy/,172,D74
Create Your First Integration,Step 1: Create,"Let's add the integration by following the steps given below:Sign in to the Choreo Console at https://console.choreo.dev/.
On the Home page, click on the project in which you want to create the integration. Alternatively, you can click + Create Project and add a new project.
If your project has one or more components, click + Create. If not, proceed to the next step.
On the Integration as an API card, click Create to start creating a micro integrator REST API.
Enter a name and a description for the micro integrator REST API. For example, you can enter MI Hello World as the name and MI Hello World REST API as the description.
To the micro integrator REST API as a publicly accessible API, leave the selection in the Access Mode list unchanged.
Click Next.
Authorize Choreo to connect to your GitHub account by clicking Authorize with GitHub.
If you have not already authorized Choreo applications, click Authorize Choreo Apps when prompted.
Enter information related to the GitHub repository you want to connect as follows:
Field
Value
GitHub Account
Select your GitHub account.
GitHub Repository
Select your fork of the choreo-examples GitHub repository.
Branch
main
Under Build Preset, click Micro Integrator.
!!! info
The build preset specifies the type of build that Choreo needs to run for the component (for example, Choreo needs to run a micro integrator build for components developed via the WSO2 Integration Studio, a Ballerina build for a component added via a Ballerina project, etc.,).
Enter information related to the MI Hello World project as follows:
Field
Value
Path
ipaas/micro-integrator/simple-proxy
OpenAPI File Path
ipaas/micro-integrator/simple-proxy/openapi.yaml
Click Create.The micro integrator REST API opens on a separate page.",https://wso2.com/choreo/docs/ipaas/micro-integrator/create-your-first-integration/,419,D75
Develop Integrations with the Micro Integrator,Integration types,"Choreo supports the following types of MI (Micro Integrator) integrations:!!! info
MI integration refers to an integration you develop using WSO2 Synapse.Integration as an API: These integrations are exposed as APIs using HTTP.
Event-triggered Integration: Integrations that are triggered by external events.
Scheduled Integration: Integrations that are triggered automatically at scheduled time intervals
Manually-triggered Integration: Integrations that you need to trigger manually.",https://wso2.com/choreo/docs/ipaas/micro-integrator/develop-integrations-with-integration-studio/,102,D76
DevOps Portal,Access the DevOps Portal,"You can access the DevOps Portal in one of the following ways:Via https://devops.choreo.dev/
Clicking DevOps Portal in the top menu of the Choreo Console
{.cInlineImage-full}When you open the DevOps Portal, it displays the deployment insights and the recently created components of the currently selected project as shown below:{.cInlineImage-threeQuarter}If you hold the pointer over the Deployment Insights graph, it displays the number of components you have deployed to each environment up to the date you are pointing. This count applies to the currently selected organization and project.You can select the required organization and the project for which you need to view this data by selecting the required values in the Organization and Project lists.",https://wso2.com/choreo/docs/devops/devops-portal/,162,D77
Manage Applications,Step 1: Create an application,"Follow the steps below to create an application on Choreo:Sign in to Choreo Developer Portal at https://devportal.choreo.dev. Alternatively, click the Developer Portal link on the Choreo Console header.
{.cInlineImage-half}
Click Applications and then, click +Create.
Enter the application name and select the usage policy. Optionally, add the application description.
Click Create.You are redirected to the application overview page. You can view the throttling tier, the token type, workflow status, and the application owner of the API.",https://wso2.com/choreo/docs/consume/manage-application/,124,D78
Choreo Insights API,Query,The query root of the Choreo Insights GraphQL API.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,14,D79
Performance Analysis,Advantages of using the Performance Analyzer,"Making accurate performance estimations before releasing an application you have developed is important due to the following reasons:You can identify the performance-critical path of a component at development time.
The forecasts you obtain for individual connector actions help identify any bottlenecks in each execution path.
You can detect any performance anti-patterns and low-quality code in your component implementation that impacts the overall performance.
When you create service-level agreements (SLAs) for your application, an accurate performance forecast allows you to provide valuable insights relating to the scalability of the application and the ways to optimize its performance.
You can avoid missing significant performance characteristics when combining multiple applications, including external applications.
You can correctly assess the cost and feasibility of running the application in a production environment.
You can reduce the time and cost spent on debugging performance issues by eliminating or minimizing iterative load testing efforts.",https://wso2.com/choreo/docs/observe-and-analyze/performance-analysis/,181,D80
Observability Overview,Dashboard,"Choreo Observability dashboard gives you more than one way to monitor your services. This section introduces the dashboards.
h3 -> Dashboard overview
The following diagram shows the Observability dashboard:{.cInlineImage-full}!!! note
The observability dashboard for non-Ballerina components doed not display the low-code diagram. Therefore, the functionality within the low-code diagram is available only to Ballerina components.The Observability dashboard allows you to:Observe the throughput and latencies of requests served over a given period.
View the logs generated over a given period.
Compare metrics side-by-side for better diagnosis.
Observe the flame graph (Diagnostics view) generated over a given period (not available for non-Ballerina components).
View the low-code diagram (not available for non-Ballerina components).
Trace requests (not available for non-Ballerina components).!!! info
By default, automatic refreshing is turned off for the Observability view. You can configure the Observability view to be automatically refreshed at a specified time interval via this field.
![../../assets/img/observability/options-bar.png]!!! note
The Observability view is private and is only visible to the service owner.
h3 -> Throughput and latency graphs
The throughput graph shows the throughput of requests per hour for a selected timestamp.{.cInlineImage-full}!!! note
The low-code diagram is not available for non-ballerina components.By default, Choreo renders this graph for the data generated within the past 24 hours. You can change the default time window by selecting the time range and zone from the options bar. To expand the graph, click and drag the cursor over the period you want to drill down.You can view the Choreo service logs in the Logs view below the graph. Clicking on either graph updates the Logs view to contain the corresponding log entries generated at that time. You can use these logs to identify the reasons for any latency and throughput anomalies you detect using the graph.The following figure shows an example of this:{.cInlineImage-full}
h3 -> Diagnostics view
The Diagnostics view provides the capability to view errors, throughput, latencies, CPU usage, memory usage, and logs simultaneously for a particular event. You can detect and analyze errors and anomalies in detail via the Diagnostics view.By default, the time range selected for the Throughput & Latency graphs is the same time range used for the Diagnostics view.{.cInlineImage-full}A bin is a horizontal section of the graph for a particular period. A bin consists of the following items:Date/Time: The timestamp for the log entries as they started to appear.
Logs:  List of log entries and their respective log count that occurred within the bins time frame. These log entries appear according to precedence. The error logs are listed first, followed by the info logs. Each bin shows a maximum of five log entries sorted by the log count.
Error: The number of HTTP errors that occurred at the selected time.
TP: Throughput of the requests at the selected time (req/s).
Latency: Latency of the request at the selected time (ms).
CPU: CPU usage at the selected time (millicores).
Memory: Memory usage at the selected time (MiB).",https://wso2.com/choreo/docs/observe-and-analyze/observe/observability-overview/,720,D81
Scheduled Tasks,What is a scheduled task?,"A scheduled task performs a routine action at scheduled time intervals. Following are examples of scenarios where you can schedule tasks:Logging a session time-out message for a user at a specific time interval
Publishing a summary of GitHub issues (i.e., with details such as the number of GitHub issues in each status) as a message in a group chat window of a team every day at a specific time
Periodically checking whether an application is active or not",https://wso2.com/choreo/docs/develop/components/scheduled-tasks/,94,D82
Forecast Performance Metrics,Advantages of using the Performance Analyzer,"Making accurate performance estimations before releasing an application you have developed is important due to the following reasons:You can identify the performance-critical path of a component at development time.
The forecasts you obtain for individual connector actions help identify any bottlenecks in each execution path.
You can detect any performance anti-patterns and low-quality code in your component implementation that impacts the overall performance.
When you create service-level agreements (SLAs) for your application, an accurate performance forecast allows you to provide valuable insights relating to the scalability of the application and the ways to optimize its performance.
You can avoid missing significant performance characteristics when combining multiple applications, including external applications.
You can correctly assess the cost and feasibility of running the application in a production environment.
You can reduce the time and cost spent on debugging performance issues by eliminating or minimizing iterative load testing efforts.",https://wso2.com/choreo/docs/develop/run-and-test/forecast-performance-metrics/,181,D83
Define Configurable Variables,Define configurable values as you develop,"As you develop your component, you may identify a parameter for which the value needs to be configurable and for which you have not already defined the required configurable. Then you can access the configurable variable template while defining/editing the required statement. For example, if you are adding a variable and you want its value to be configurable, you can follow these steps:Update the name and the type of the variable as required. For example, you can enter string as the variable type and password as the variable name.
{.cInlineImage-half}
To enter the variable value as a configurable, click <add-expression> and then click the Configurable icon.
{.cInlineImage-half}
The template for the configurable variable appears. You can update the configurable type, name, and value as required.",https://wso2.com/choreo/docs/develop/explore-code-editor/define-configurable-variables/,176,D84
Quick Start Guide,Prerequisites,"Before you try out this guide, complete the following:Create a GitHub repository to save the REST API implementation. For this guide, you can fork https://github.com/wso2/choreo-examples/tree/version-1.
If you are logging in to Choreo Console for the first time, create an organization as follows:
In https://wso2.com/choreo/, click Try Choreo Now.
Sign in to Choreo using your Google, GitHub, or Microsoft account.
Enter a unique organization name. For example, Stark Industries.
{.cInlineImage-small}
Read and accept the privacy policy and terms of use before you proceed.
Click Create to add the new organization.
You will be viewing the Home page of the Choreo Console.
Create a new project as follows:
On the Home page of the Choreo Console, click + Create Project.
Enter a unique name and a description for the project, and click Create.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,215,D85
Map Data,Map Data - Step 1: Add a REST API,"First, let's add a new REST API. To do this, follow the steps given below:Sign in to the Choreo Console at https://console.choreo.dev.
On the Home page, scroll to the Create from a sample section. On the Echo Service template, click Get Started.
The REST API created via the template opens on a separate page.3. Click Edit Code.
Let's start fresh by cleaning up the default implementation to implement our data mapping. To clean up, remove the default resource of the REST API by clicking its Delete icon.
{.cInlineImage-half}Now you can add a data mapping to this REST API and design a REST API implementation that includes the data mapping.",https://wso2.com/choreo/docs/develop/explore-code-editor/map-data/,152,D86
Deploy a Containerized Choreo Component,Prerequisites,"To deploy a containerized component, you need a GitHub account with a repository that contains a Dockerfile. For this tutorial, you can fork and use the choreo-sample-apps repository.The Choreo GitHub App requires the following permission:Read access to issues and metadata
Read and write access to code, pull requests, and repository hooksYou can revoke access if you do not want Choreo to have access to your GitHub account. Choreo needs write access only to send pull requests to a user repository. Choreo does not directly push any changes to a repository.Let's get started!",https://wso2.com/choreo/docs/deploy/deploy-a-containerized-choreo-component/,124,D87
Create Your First REST API,Step 1: Create,"In this section, let's create the API that retrieves COVID-19-related statistics.
h3 -> Step 1.1: Create a project and add a REST API component
Sign in to the Choreo Console at https://console.choreo.dev/.
On the Home** page, click the + Create Project.
{.cInlineImage-small}
Enter a unique name and a description for the project. For this tutorial, let's enter the following values:
Field
Value
Name
COVID-19Stats
Description
Get statistics relating to COVID-19
Click Create. This takes you to the Components page.
h3 -> Step 1.2: Add a REST API component
Let's create a new REST API component as follows:On the Components page, click Create on the REST API card.
{.cInlineImage-small}
Enter a unique name and a description for the API. For this tutorial, let's enter the following values:
Field
Value
Name
Statistics
Description
COVID-19 Statistics
Click Next.
Provide authorization for Choreo to connect to your GitHub account by clicking  Authorize with GitHub.
If you have not already authorized Choreo applications, click Authorize Choreo Apps when prompted.
Select a GitHub account, a repository that includes the implementation, the relevant branch, and the build preset (i.e., Ballerina or Dockerfile).
Enter the following values based on the preset you selected above:
Ballerina preset
Path: Enter a valid path relative to the root of your repository that points to the implementation of the REST API. If you have not designed and implemented your REST API yet, you can connect an empty GitHub repository or a sub-folder and proceed to create the component.
!!! info
You can create a component by connecting an empty GitHub repository for the Ballerina preset. However, you can only deploy it after developing and pushing a Ballerina implementation for the relevant component type.
Dockerfile preset:
Dockerfile path: Enter a valid path relative to the root of your repository that points to the Dockerfile. The path must include - Dockerfile. Choreo validates the Dockerfile path and checks if the given file name contains the word Dockerfile ignoring cases.
Docker context path: Enter a valid path relative to the root of your repository that points to the Docker project.
OpenAPI file path (Optional): Enter a valid path relative to the root of your repository that points to the OpenAPI schema. Choreo validates the input to check if the given file name has one of the following extensions: *.yaml, *.yml, or *.json.
Next, click Create.
h3 -> Step 1.2: Design the REST API
Designing the REST API involves specifying how the REST API should function by adding and configuring the required connectors and statements. You can do this by editing the low-code diagram of the REST API or by editing its code.You can implement your REST API in Ballerina or any other language and containerize it. You can use the Ballerina VS code extension to develop the REST API in Ballerina. Learn more.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-rest-api/,678,D88
Create Your First Webhook,Step 2: Deploy,"Let's deploy your webhook to the development environment to make it invokable:In the Choreo Console, click Deploy for your Webhook component, and click Config & Deploy.
{.cInlineImage-threeQuarter}
In the Configure & Deploy pane, enter the following information:
In the toEmail field, enter the email address to which you want the webhook to send the notification emails.
In the webhookSecret field, enter any value.
!!! note
You must save this value for later use.
Click Deploy.
Choreo starts deploying the webhook. You can monitor the progress of the deployment in the Console pane that opens on the right of the page.Once Choreo completes the deployment, the Deploy page displays the Active deployment status for the webhook as shown in the image below:{.cInlineImage-threeQuarter}!!! notes
- The Invoke URL shows the URL via which GitHub can invoke the webhook.
- You can update the security header of the webhook by clicking the refresh icon within the Security Header field.
{.cInlineImage-small}
- The Configurables field shows the number of times you have updated the webhook secret. You will see 2 keys configured text displayed in this field as shown in the image if you specified a different webhook secret when you tested the webhook in the Web Editor. If you want to edit the webhook secret again, follow these steps:
1. Click the edit icon within the Configurables field.
{.cInlineImage-small}
2. In the Configure & Deploy panel, enter a webhook secret different from the one you specified previously.
3. Click Deploy.You can now connect the webhook to the required GitHub repository.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-webhook/,375,D89
Create Your First Integration as an API,Step 1: Create,"Let's add the integration by following the steps given below:Sign in to the Choreo Console at https://console.choreo.dev/.
On the Home page, click on the project in which you want to create the integration. Alternatively, you can click + Create Project and add a new project.
If your project has one or more components, click + Create. If not, proceed to the next step.
On the Integration as an API card, click Create to start creating a micro integrator REST API.
Enter a name and a description for the micro integrator REST API. For example, you can enter MI Hello World as the name and MI Hello World REST API as the description.
To the micro integrator REST API as a publicly accessible API, leave the selection in the Access Mode list unchanged.
Click Next.
Authorize Choreo to connect to your GitHub account by clicking Authorize with GitHub.
If you have not already authorized Choreo applications, click Authorize Choreo Apps when prompted.
Enter information related to the GitHub repository you want to connect as follows:
Field
Value
GitHub Account
Select your GitHub account.
GitHub Repository
Select your fork of the choreo-examples GitHub repository.
Branch
main
Under Build Preset, click Micro Integrator.
!!! info
The build preset specifies the type of build that Choreo needs to run for the component (for example, Choreo needs to run a micro integrator build for components developed via the WSO2 Integration Studio, a Ballerina build for a component added via a Ballerina project, etc.,).
Enter information related to the MI Hello World project as follows:
Field
Value
Path
ipaas/micro-integrator/simple-proxy
OpenAPI File Path
ipaas/micro-integrator/simple-proxy/openapi.yaml
Click Create.The micro integrator REST API opens on a separate page.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-integration-as-an-api/,419,D90
Configure Developer Portal Self-Sign-Up,Prerequisites,"Sign in to the Choreo Console at https://console.choreo.dev/ using your Google, GitHub, or Microsoft account.
If you are a new user, create an organization with a unique organization name. For example, ""Stark Industries"".
{.cInlineImage-small}",https://wso2.com/choreo/docs/administer/configure-developer-portal-self-sign-up/,64,D91
Configure Automatic Deployment,Step 1: Connect your own GitHub repository for a REST API,"First, let's create a REST API and store the source code in your GitHub repository.For instructions, see Connect Your Own GitHub Repository to Choreo",https://wso2.com/choreo/docs/deploy/configure-automatic-deployment/,32,D92
Migrate Applications to the Latest Version,Step 1: Migrate your applications,"!!! note
In this section, applications refer to APIs, services, and integrations in the previous version of Choreo.To migrate your applications:Access Choreo via console.choreo.dev. Enter your current credentials to sign in.
You will see the following displayed on the Home page.
{.cInlineImage-full}
Click Migrate. You can continue your work in the Choreo Console while the migration process runs in the background.
Once the migration process starts, the following message is displayed.
{.cInlineImage-full}
Once you complete the migration process successfully,  you will see the following message:
{.cInlineImage-full}
!!! attention
To list the components soon after you complete the migrations process, follow the steps below:
  1. **Refresh** the page.
  2.  On the Home page, select the **`DefaultProject-{ORGANIZATION_NAME}`** project.
If the migration fails or results in being partially completed, the following messages are displayed.
{.cInlineImage-full}
{.cInlineImage-full}
If either of these messages appears, you can click Retry to re-run the migration process again.
!!! fail
If you continuously experience migration failures, contact choreo-help@wso2.com.Once you successfully migrate your applications, on the new Choreo version, you will see them as components. You can then deploy these components.",https://wso2.com/choreo/docs/reference/migrate-applications-to-the-latest-version/,323,D93
GraphQL APIs,What is a GraphQL API?,"GraphQL is a query language for APIs to fetch and persist data. A GraphQL API is a category of APIs that supports this query language.A GraphQL API is an alternative for a REST API to address the following limitations experienced by REST API consumers:A REST API may need to send multiple requests to several endpoints to retrieve all the required data. A GraphQL API can achieve this via a single query.
For example, a banking application has to fetch the phone number and the current account balance of an account holder. To achieve this, a REST API may need to send three requests to call three endpoints (e.g., /customers/<id> to fetch the initial data, /customers/<id>/contactInfo to fetch the phone number, and /customers/<id>/balances to fetch the current account balance).
A GraphQL API can retrieve all these details via one query similar to the sample given below:
query {
    customer (id: ""SIL182882762"") {
        contactInfo {
            phoneNo
        }
        balances(current)
    }
}
In this scenario, a single request by a REST API under-fetches data compared to a single request by a GraphQL API.
In some scenarios, a REST API can over-fetch data. In the same example given above, a request sent by REST API to the /customers/<id>/contactInfo can result in fetching all the contact information in the array such as the phone number, work phone number, address, email, etc., whereas the application only needs the phone number.
GraphQL allows you to avoid this by writing queries with specific data requirements.GraphQL APIs consume fewer resources (such as internet bandwidth, system memory, etc.) by avoiding over-fetching and minimizing the number of requests it sends for a given purpose. Therefore, it is economical to consume GraphQL APIs instead of REST APIs for low-energy devices such as mobile devices.",https://wso2.com/choreo/docs/develop/components/graphql-api/,451,D94
Configure Enterprise Login,Prerequisites,Make sure you have a valid email domain.,https://wso2.com/choreo/docs/administer/configure-enterprise-login/,9,D95
Create a Policy,Prerequisites,"Set up Ballerina 2201.2.0 or later.
Open the ~/.ballerina/Settings.toml file and check if you have configured an access token to the Ballerina Central. If an access token is not configured in the file, follow the steps below:
Generate a token from https://central.ballerina.io/dashboard?tab=token.
Download the generated Settings.toml file and copy it to your local ~/.ballerina directory.Alternatively, you can set the access token through the BALLERINA_CENTRAL_ACCESS_TOKEN environmental variable.export BALLERINA_CENTRAL_ACCESS_TOKEN=<access-token>",https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,147,D96
REST API Proxy,What is a REST API Proxy?,"A REST API Proxy is an API proxy that complies with the Representational State Transfer(REST) standards. The REST API proxy fronts the API and is the contact point for applications that want to consume the API. Although APIs decouples the backend and the application, an API alone cannot ensure security for the backend and the application by applying policies such as security, rate-limiting, etc. This is where a REST API Proxy comes into play. A REST API Proxy helps you manage the API by applying necessary security policies, access-control policies, and even collecting analytics. Fronting your unmanaged API by a REST API proxy gives your application the flexibility to make changes to the backend API without affecting the applications that consume them.A REST API Proxy exposes an endpoint that applications use to consume the API.",https://wso2.com/choreo/docs/develop/components/api-proxy/,163,D97
Connect Your GitHub Repository to Choreo,Prerequisites: Create a project,"Let's begin by creating a project as follows:Sign in to the Choreo Console at https://console.choreo.dev.
Click the + Create Project card from the landing page.
{.cInlineImage-small}
Enter a unique name and description for your project. In this tutorial, let's use the following values:
Field
Value
Name
COVID-19 Statistics
Description
Maintain COVID-19 Statistics
Click Create.",https://wso2.com/choreo/docs/develop/manage-repository/connect-your-own-github-repository-to-choreo/,99,D98
Create Your First Event-Triggered Integration,Step 1: Create the integration component,"Let's create the integration component by following the steps given below:Go to https://console.choreo.dev/?profile=ipaas and sign in to the Choreo Console.
On the Home page, click +Create Project.
Enter a unique name and a description for the project, and select a region.
Click Create.
Go to the Event-Triggered Integration card, click Create, and enter the following information:
Field
Value
Name
MQTT listener
Description
My sample listener
In the Access Mode field, leave the default selection (i.e., External: API is publicly accessible) unchanged.
Click Next.
To allow Choreo to access your GitHub account, click Authorize with GitHub.
!!! tip
If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials, and select the sample application GitHub repository to install the Choreo GitHub App.
In the Connect Repository dialog box, enter the following information:
Field
Description
GitHub Account
Your account
GitHub Repository
choreo-examples
Branch
main
Build Preset
Click Micro Integrator
Path
ipaas/micro-integrator/simple-rabbitmq-listener
!!! tip
- Build Preset specifies the type of build to run depending on the implementation of the component. It converts the integration code into a Docker image that can run on Choreo cloud. If an integration is developed using WSO2 Integration Studio, select Micro Integrator as the build preset. If an integration is developed using the Ballerina language, select Ballerina as the build preset.
     - **Path** specifies the location of the project to build the component. 
Click Create. This creates the component and takes you to the Deploy view, where you can proceed to deploy the component.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-event-triggered-integration/,398,D99
Root Cause Analysis,Access observability data of a component,"To visualize the observability data of a component, follow these steps:Access the Choreo Console via https://console.choreo.dev/.
On the Home page, select the project with the component that you want to observe.
{.cInlineImage-full}
Click on the component that you need to observe to open it.
To open the Observability view for the component, click Observe on the left navigation.
You can view the following:
Low-code diagram
Throughput graph
Latency graph
Logs
Diagnostic data",https://wso2.com/choreo/docs/observe-and-analyze/observe/root-cause-analysis/,120,D100
REST APIs,What is a REST API?,"A Representational State Transfer(REST) API is an Application Programming Interface(API) that complies with the constraints of REST architectural styles and principles. REST is an architectural style introduced by Dr. Roy Fielding in his doctoral dissertation in the year 2000. Dr.Roy initially designed it as a guide for the development of modern web architecture. Today, REST is widely adopted to create high-performance, stateless, and reliable APIs that various applications use.",https://wso2.com/choreo/docs/develop/components/rest-api/,92,D101
Webhook,What is a webhook?,"A webhook is a cause that activates an action. Webhooks in Choreo are no different and are user-defined callbacks.Webhooks are used by developers to implement event-driven integrations. Before event-driven solutions,  to identify an event occurrence, systems had to keep polling other systems periodically.  With event-driven solutions, systems can focus on the main business-flow, and proactively be notified when an event of interest occurs in real-time. The following are some examples of scenarios where you can create webhooks for the mentioned platforms:Sending a chat message in a group chat when an event gets added in a slack channel.
Generating an alert when a new issue gets created in a specific Git repository.
Sending a notification when an event gets scheduled in a google calendar.Webhooks are a widely used programming element to create event-driven API architectures for real-time solutions.",https://wso2.com/choreo/docs/develop/components/webhook/,191,D102
Connect to an External Identity Provider,Token exchange,"Choreo supports the token exchange grant type. This grant type allows the client to obtain a Choreo access token by providing a JWT issued by an external IdP. The token exchange grant type uses the protocol defined in the OAuth 2.0 token exchange specification. The OAuth 2.0 token exchange specification describes how you can request and obtain security tokens from OAuth 2.0 authorization servers. The following diagram depicts the token exchange flow in Choreo:{.cInlineImage-full}To exchange a JWT issued by an external IdP for a Choreo access token, you must send a request to the Choreo token endpoint with the JWT (referred to as the subject_token in the preceding diagram) in the request body. Upon successful authentication of the request, validation of the request takes place, and the corresponding IdP configuration is retrieved using the issuer. Next, the subject token is validated. Successful validation generates and returns a Choreo access token.Now that you understand the token exchange flow, you can go ahead and add an external IdP to your Choreo organization and then obtain a JWT from the external IdP to exchange for a Choreo access token.",https://wso2.com/choreo/docs/administer/connect-to-an-external-identity-provider/,251,D103
View API Insights,Access the Insights page,"To open the Insights page, access the Choreo Console at https://console.choreo.dev/, and click Insights in the left navigation menu.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/view-api-insights/,34,D104
Create Your First REST API Proxy,Step 2: Develop the REST API Proxy,"Let's develop the REST API proxy by adding an operation. To do this, follow the steps given below:In the left navigation, click Develop.
In the Resources tab, add a new resource to fetch the department ID as follows:
Select GET as the HTTP verb.
Enter /department/{departmentId} as the URI pattern.
To add the new resource, click +.
Once the resource is added, expand it, and then enter a name and a description for it as given below:
Field
Description
Operation ID
findDepartment
Description
Find a department by Department ID
Click Save.
Click API Definition. You will see the new operation you added in the OpenAPI definition.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-rest-api-proxy/,148,D105
Configure Developer Portal Self-Sign-Up,Configure self-sign-up,"Click Settings in the left navigation menu of the Choreo Console.
Click Copy Handle to copy the organization handle to the clipboard.
{.cInlineImage-half}
Go to the Asgardeo sign-up page and register using the same email address/user account you used to sign up with Choreo.
!!! tip
You must sign up to Asgardeo with the same email address/user account you used to sign in to Choreo because the organization name is reserved for that user account.
In the Organization Name field, paste the organization handle that you copied from the Settings page in Choreo.
{.cInlineImage-half}
Click Create. This creates a new organization so that you can proceed to access your workspace.
Send an email similar to the following to choreo-help@wso2.com requesting to configure enterprise IdP for the Developer Portal of your organization.
!!! tip
Be sure you mention the organization name or handle in the request.
!!! note ""Sample email""
Subject : [Stark Industries] Configure enterprise IdP for Developer Portal
 Hi CS team,
 I need to configure enterprise IdP for my organization’s Developer Portal to enable self-sign-up. Can you please do the necessary configurations to proceed?
 My organization details are as follows: 
 - Organization name: Stark Industries
 - Organization handle:  starkindustries
 Thank you
The Choreo support team will perform the necessary configurations and respond to you.
On receiving the response, sign in to your Asgardeo account and click View all applications.
{.cInlineImage-full}
You will see an application named WSO2_LOGIN_FOR_CHOREO_DEV_PORTAL.
{.cInlineImage-full}
Click on the application to edit it and enter your organization’s Developer Portal URL as the Access URL of the application. For example, https://devportal.choreo.dev/starkindustries.
Click Update.
To add user attributes, follow these steps:
Click the User Attributes tab.
Select user attributes as follows:
{.cInlineImage-half}
To add the email as a mandatory user attribute, expand Email and select the Mandatory checkbox for it.
To add the first name and the last name as optional, expand Profile and select the Requested checkbox for the First Name and the Last Name fields.
Click Update.
To add the user attributes as OpenID Connect scopes, follow these steps:
In the top navigation menu, click Manage and then click Scopes in the left navigation menu.
Click OpenID and then click + New Attribute.
Select Email, First Name, and Last Name as the attributes to associate with the OpenID scope.
Click Save and then click Save Changes.
{.cInlineImage-full}
To configure basic authentication as the sign-in method, follow these steps:
In the top navigation menu, click Develop and then click WSO2_LOGIN_FOR_CHOREO_DEV_PORTAL to edit the application details.
Click the Sign-in Method tab and then click Start with default configuration.
{.cInlineImage-full}
Click Update.
To configure self-registration, follow these steps:
In the top navigation menu, click Manage and then click Self Registration in the left navigation menu.
To enable self-registration, turn on the toggle.
Select Account verification.
Update the value of the Account verification link expiry time depending on your requirement.
Click Update.
{.cInlineImage-full}Once you complete these steps, the Choreo support team will perform the final self-sign-up configuration, and you will see a sign-up link similar to the following in your Developer Portal:{.cInlineImage-full}Users can click LOGIN/SIGN UP and then click Create an account to sign up to your Developer Portal without having to send you a request to register them.{.cInlineImage-half}",https://wso2.com/choreo/docs/administer/configure-developer-portal-self-sign-up/,867,D106
Connect to an External Identity Provider,Step 1: Add an external IdP,"To add an external IdP, follow this procedure:!!! note
You must have organization administrator privileges to add an external IdP.Sign in to the Choreo Console at https://console.choreo.dev/.
In the left navigation menu, click Settings.
Click the API Management tab. This displays the existing identity providers in your organization if you have already added any.
{.cInlineImage-full}
Click + Add Provider. This displays the identity providers supported by Choreo.
{.cInlineImage-full}
Click on the IdP you want to add. This displays a form where you must enter details to set up the IdP.
This example walks you through the steps to add Okta as the IdP. The details you need to fill in are similar for other IdPs as well.
Enter appropriate values for each of the fields and click Next. The following table describes each field in detail:
Field
Description
Name
The name of the IdP. You cannot modify the name after you add an IdP.
Description
A brief description of the IdP.
Allowed Token Audience
If the IdP is Okta:The audience of the authorization server for which the access token is necessary.
         You can update this default value via the Okta authorization server by navigating to the following path:
         Security → API → Authorization Server → Your Authorization Server → Settings → Audience
         If the IdP is Microsoft:The identifier that identifies the intended recipient of the token.
         This value should be the application ID URI of the application in Azure Active Directory (Azure AD) for which the token is requested.
     
         If the IdP is Auth0:The unique API identifier to use as the audience parameter in the authorization call.
         You can update this value in the Auth0 server by navigating to the following path:
         Applications → APIs → Your API → General Settings → Identifier
Well-Known URL
The OpenID Connect discovery endpoint URL. This returns the metadata related to the OpenID Provider's configuration.
{.cInlineImage-half}
When you specify the Well-Known URL, the values for Issuer, Token Endpoint, and JWKS Endpoint get auto-populated. You can either choose to keep the values or manually change them. The following table describes each field in detail:
Field
Description
Issuer
The issuer identifier of the IdP, which is in the `iss` claim of the JWT issued.
Token Endpoint
The token endpoint URL of the IdP from where the OAuth 2.0 client can get an access token.
JWKS Endpoint
The URL that returns the JSON Web Key (JWK) set of the IdP. This returns a collection of JWKs used to verify the signature of the JWT tokens.
 
Click Add. This adds Okta as an external IdP to your Choreo Organization.Now that you have added an external IdP, you can obtain a JWT from that IdP and exchange it for a Choreo access token to invoke APIs.",https://wso2.com/choreo/docs/administer/connect-to-an-external-identity-provider/,715,D107
Create a Policy,Step 1: Initializing a Ballerina project,"A mediation policy is a Ballerina project. You can use the template provided by Choreo to initialize a mediation policy project with all the required configurations.Let's create a Ballerina project for the mediation policy using the mediation.template as the project template by issuing the following command:Format:```
   bal new -t choreo/mediation.template:1.0.0 <policy-name> 
```Example:```
   bal new -t choreo/mediation.template:1.0.0 validateHeader 
```The Ballerina project you generated above has the following content:{.cInlineImage-small}You can modify the Ballerina.toml and the Package.md files of the generated project as required. For example, you can update the org, the package, the package version, API documentation content, keywords, etc.{.cInlineImage-small}",https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,199,D108
Create Your First Webhook,Step 3: Connect the webhook to the GitHub repository,"To allow the webhook to read the labels of the required GitHub repository, you need to connect the webhook to this repository. To do this, follow these steps:On the Deploy page, copy the invoke URL by clicking the copy icon within the Invoke URL field.
{.cInlineImage-threeQuarter}
Access your GitHub account and open the repository for which you want to generate notification emails.
In the top menu, click Settings.
In the left navigation, click Webhooks.
Click Add Webhook and enter the following information:
Field
Value
Payload URL
The invoke URL you copied in Step 3, sub-step 1.
Content Type
Select application/json.
Secret
The last webhook secret you configured in Step 2.
Under Which events would you like to trigger this webhook? select Let me select individual events.
Select the Issues checkbox in the list that appears.
By doing so, you select GitHub issues as events that need to trigger this webhook.
In the same list, clear the Pushes check box to ensure that GitHub does not trigger your webhook when the team pushes changes to the selected GitHub repository.
Click Add Webhook to save the configuration.Now you have integrated Choreo with GitHub via the webhook you created and deployed. Proceed to step 4 to test it.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-webhook/,282,D109
Manage Applications,Grant types,"Choreo authentication is based on OAuth 2.0 In OAuth 2.0, grant types are methods that allow client applications to obtain an access token depending on the type of the resource owner, the type of the application, and the trust relationship between the authorization server and the resource owner.
h3 -> Refresh token grant
A refresh token is a token that you can use to get a new access token when your current access token is expired or when you need a new access token. You can use the refresh token grant type for this purpose. Issuing a refresh token is optional for the authorization server. If the authorization server issues a refresh token, it includes it in the response with the access token. You can use this refresh token and send it to the authorization server to obtain a new access token. Choreo's default authorization server, Asgardeo, issues refresh tokens for all other grant types other than the client credentials grant type, as recommended by the OAuth 2.0 specification.!!! note- Keep your refresh token private, similar to the access token. 
- The process to get a new access token using the Refresh Token grant type requires no user interaction.
h3 -> Token exchange grant
Choreo supports the token exchange grant type. This grant type allows the client to obtain a Choreo access token by providing a JWT issued by an external IdP. The token exchange grant type uses the protocol defined in the OAuth 2.0 token exchange specification. The OAuth 2.0 token exchange specification describes how you can request and obtain security tokens from OAuth 2.0 authorization servers. The following diagram depicts the token exchange flow in Choreo:{.cInlineImage-full}To exchange a JWT issued by an external IdP for a Choreo access token, you must send a request to the Choreo token endpoint with the JWT (referred to as the subject_token in the preceding diagram) in the request body. Upon successful authentication, validation of the request takes place, and the corresponding IdP configuration is retrieved using the issuer. Next, the subject token is validated. Successful validation generates and returns a Choreo access token.",https://wso2.com/choreo/docs/consume/manage-application/,450,D110
Deploy a Containerized Choreo Component,Step 1: Create a component from a Dockerfile,"Let's add a containerized REST API component by following these steps:Sign in to the Choreo Console at https://console.choreo.dev.
Create a project to add the REST API component. You can follow the instructions under Prerequisites in the Connect Your Own GitHub Repository to Choreo tutorial.
On the Components page, click Create on the REST API card.
Enter a unique name and a description for the API. For this tutorial, let's enter the following values:
Field
Value
Name
Greetings
Description
Sends greetings
!!! Info
Leave the value for the Access Mode field unchanged.
This field allows you to select whether you want the REST API to be publicly accessible or to be accessible only within Choreo. By default, the API is publicly accessible.
Click Next.
Click Authorize with GitHub to allow the REST API to access your GitHub account.
Once you perform the authorization, the GitHub Account field in the Connect Repository dialog box displays the GitHub account you authorized the REST API to access.
Select the following values to connect the repository.
Field
Description
Value
GitHub Account
Your GitHub account. If you want to add another GitHub account, you can expand the list, click + Add, and repeat step 6.
select your GitHub account
GitHub Repository
You can authorize the REST API to access all the repositories in the selected GitHub account or select one or more repositories that you want to allow the REST API to access. For this tutorial, you can select your fork of the choreo-sample-apps repository
choreo-sample-apps
Branch
The branch of the repository
main
Build Preset
Determines the implementation of the component: Ballerina or any other language as a Docker container
Dockerfile
Dockerfile path
The path to your Dockerfile. This path is defined relative to the repository root.e.g., If the Dockerfile is at the repository root, the value for this field for a monorepo is service-one/Dockerfile.
nodejs/rest-api/Dockerfile
Docker build Context Path
The Docker build context path. To include the repository root, leave the default **.** value.
nodejs/rest-api/
Port
The port at which your service is running.
8080
OpenAPI Filepath
The path to an OpenAPI specification (in YAML/JSON) relative to the repository root. If you do not specify a path, the system auto-generates a default allow-all specification.
nodejs/rest-api/openapi.yaml
!!! Tip
- The repository you select will be validated when you run a build for it.
- If you want to add another GitHub repository from your account, you can expand the list, click + Connect More Repositories, and repeat step 6.
Click Create.
The REST API deploy section opens on a separate page.
If you click the Overview icon, you will see the default OpenAPI specification instead of the specification you specified in the OpenAPI Filepath field. This is because you need to build and deploy the REST API to execute the required commands in the Dockerfile that will generate it.
To select a specific version of the REST API you want to deploy, click the first card in the Build Area section, select the required commit in the Configure & Deploy pane, and click Select. 
{.cInlineImage-threeQuarter}
If you want to make changes to the build configurations you previously defined, follow these steps: 1. Click the Build Configurations card in the Build Area section. 2. Make the required changes in the Build Configurations pane. 3. Click Save.
{.cInlineImage-threeQuarter}
When you create a Ballerina component, Choreo will allow you to develop it and define variables for which you can provide values when you deploy it. However, when you bring your own non-Ballerina component, the system runs the build via the Dockerfile. If you want to define configurable values before deploying, you can configure them in the DevOps Portal. For more information, see DevOps Portal - Configurations and secretsYou have successfully added a Dockerfile-based REST API component from a Dockerfile. Now let's build and deploy it.",https://wso2.com/choreo/docs/deploy/deploy-a-containerized-choreo-component/,916,D111
Performance Analysis,Use the Performance Analyzer,"You can use the Choreo Performance Analyzer on the Web Editor in low-code mode.
h3 -> Analyze the performance-critical path in real-time
To view the real-time analysis of the performance-critical path of your component, follow the steps below:Sign in to the Choreo Console at https://console.choreo.dev.
Navigate to your component and click Overview from the left pane.
Click Edit Code to access the Web Editor.
h4 -> Overall performance of the performance-critical path
On the low-code editor, you will see a bar with the summarized overall performance estimates for each resource function. By default, this banner displays the forecasted latency and throughput when the indicated user count range executes the performance-critical path. The upper bound of the user count range is set based on the availability of historical data. Since the Performance Analyzer tool derives these metrics in real-time,  any changes to the component will update the metrics in real-time.{.cInlineImage-threeQuarter}By default, the Performance Analyzer tool does not highlight the performance-critical path in the low-code diagram. Click  Reveal performance-critical path on the top banner to highlight it in green in the low-code diagram.
h4 -> Latency estimates for individual API invocations in the performance-critical path
The Performance Analyzer tool displays the estimated latency for each API invocation in the performance-critical path as a banner next to the API invocation in the low-code diagram, as shown below. The Performance Analyzer tool derives these estimates based on the user count range that is indicated on the low-code editor, as a bar with the summarized overall performance estimates for each resource function.{.cInlineImage-threeQuarter}
h3 -> Analyze the performance of all execution paths
By default, the Performance Analyzer tool does not highlight the performance-critical path in the low-code diagram. Click Reveal performance-critical path on the top banner to highlight it in green. A pane opens on the right of the Web Editor. You can perform an in-depth performance analysis of the component in this pane.{.cInlineImage-full}
h4 -> Execution paths
You can view all execution paths in the component in a tabular format listed on top of the Performance Forecast pane. The table shows the entries in descending order based on the time it takes to process a single request in each path.{.cInlineImage-half}The Performance Analyzer tool identifies the execution paths using the service invocations performed by each of them. If an execution path does not include any service invocation, then the latency of that path is assumed to be negligible.You can select any execution path from the table. When you select an execution path, the Performance Analyzer tool will highlight the execution path on the low-code diagram. The estimated overall performance values displayed on the top banner will change based on the execution path selected.
h4 -> Performance forecast graphs
The performance forecast graphs: the latency graph and the throughput graph for the selected path of execution are below the Execution Paths table in the Performance Forecast pane. These performance forecast graphs forecast how the latency and throughput may vary based on the number of users simultaneously accessing the component.{.cInlineImage-half}By analyzing these graphs carefully, you can gain a fair understanding of how well your component will scale with the increasing load.",https://wso2.com/choreo/docs/observe-and-analyze/performance-analysis/,717,D112
Create Your First Event-Triggered Integration,Step 2: Deploy,"Before you deploy the component, you must follow the steps given below to assign appropriate RabbitMQ credentials to the environment variables:In the Deploy view, go to the Development card and click Configure via the DevOps Portal. This takes you to the Configs & Secrets page in the DevOps profile, where you can apply environment-specific configuration files, environment variables, and other secret resources to containers.
Click Let's Get Started.
In the Mount a Configuration page, select Environment Variables as the configuration type and click Next.
Select Create New and enter a Config Name. Here, let's specify environmentconf as the Config Name.
Click Next.
Specify the environment variables as key-value pairs. You must use the values you obtain from your RabbitMQ instance as the values for the following keys:
Key
HOSTNAME
USERNAME
PASSWORD
VHOST
Click Finish. Now you are ready to deploy the component to the developer environment.
Go to the iPaaS profile and click the MQTT listener component you created.
Click Deploy on the left navigation, go to the Build Area card, and then click Deploy Manually.
!!! info
You have to deploy the component manually the first time. Subsequent deployments will occur automatically because automatic deployment is enabled by default.After Choreo deploys the component, you can proceed to test it.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-event-triggered-integration/,285,D113
Create Your First Event-triggered Integration,Step 2: Deploy,"Let's deploy your event-triggered integration to the development environment to make it invokable by following the steps given below:In the Choreo Console, click Deploy for your component, and click Config & Deploy.
!!! info
When you click Deploy, you will see the following deployment error displayed.{.cInlineImage-threeQuarter}This is because the automatic deployment for the event-triggered integration failed when you committed its updated implementation with new configurable variables.For more information about automatic deployment, see Deply Your Component
In the Configure & Deploy pane, enter the following information:
In the toEmail field, enter the email address to which you want the integration to send the notification emails.
In the webhookSecret field, enter any value.
!!! note
You must save this value for later use.
Click Deploy.
Choreo starts deploying the Integration. You can monitor the progress of the deployment in the Console pane that opens on the right of the page.Once Choreo completes the deployment, the Deploy page displays the Active deployment status for the event-triggered integration.!!! notes
The Configurables field shows the number of times you have updated the webhook secret. You will see 2 keys configured text displayed in this field as shown in the image if you specified a different webhook secret when you tested the Event-Triggered Integration in the Web Editor. If you want to edit the webhook secret again, follow these steps:   1. Click the edit icon within the Configurables field.   2. In the Configure & Deploy panel, enter a webhook secret different from the one you specified previously.   3. Click Deploy.",https://wso2.com/choreo/docs/ipaas/ballerina/create-your-first-event-triggered-integration/,357,D114
Create Your First REST API,Step 2: Deploy,"Once you have designed, tested, and committed the REST API, you need to deploy it so that users can invoke it.To deploy the API, follow the steps below:Click the Deploy icon. Then in the Build Area card, click Deploy Manually.
!!! note
Automatic deployment is enabled by default. However, you have to deploy the component manually the first time. Subsequent deployments will occur automatically.
{.cInlineImage-small}
To check the progress of the deployment, observe the Console pane.
{.cInlineImage-threeQuarter}Once the API is deployed, the Development card indicates that the API is active as shown below.{.cInlineImage-threeQuarter}Now you can test your deployed REST API to check again whether it is working as expected.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-rest-api/,168,D115
REST API Proxy,Develop a REST API Proxy,"Designing your REST API proxy from scratch involves declaring the resources and the methods the end-user applications will use to access the API. Choreo supports spec-driven API Proxy development. Therefore, it guides you visually via a Swagger editor to create REST API Proxies that comply with The Open API Specification (https://github.com/OAI/OpenAPI-Specification). It is the most widely used standard for declaring HTTP/REST APIs. Choreo also allows you to generate your OpenAPI specification through this editor.Choreo allows you to easily expose your existing APIs via a REST API proxy and convert it to a managed API. You can create a REST API Proxy in Choreo in two ways:From scratch by using an existing endpoint
By importing an OpenAPI specification
h3 -> Designing a new REST API Proxy using an existing endpoint
You can front your existing API with a REST API Proxy easily using Choreo. To design a new REST API Proxy, you need to create a REST API Proxy component and specify the API name, the base path, and the endpoint to create the basic API definition. Once Choreo creates the API definition, you can then define the resources by specifying the URI pattern, the HTTP methods, and optionally, any parameters:{.cInlineImage-threeQuarter}
h3 -> Designing a new REST API Proxy by importing an OpenAPI specification
Choreo allows you to create a REST API Proxy by importing an Open API Specification or providing an URL to the Open API specification. Choreo will then extract the API name, base path, and endpoint. Choreo gives you the flexibility to change this information as required. Once you create the API Proxy, you can modify it by defining the resources, URI pattern, HTTP methods, and any parameters (optional).Once you create an API proxy in Choreo, you can access the API definition of that API. Choreo also exposes the endpoints for the API where it maintains two gateway environments, production, and sandbox.",https://wso2.com/choreo/docs/develop/components/api-proxy/,423,D116
Map Data,Map Data - Step 2: Add a basic data mapping,"Let's first create a basic data mapping that maps a parameter named id  nested under person in the input to a parameter with the same name that is not nested in the output.To do this, follow the steps given below:Click the first + icon on the page, and then click Data Mapper in the Add Constructs pane.
{.cInlineImage-half}
The Data Mapper pane opens.
Enter a unique name for the data mapper (for example, transform).
Add two input  records in JSON format by following the steps given below:
Under Inputs, click + New Record.
Click  Import a JSON.
In the Name field, enter a name for the input record. For this example, let's enter personDetails as the name.
In the Sample JSON field, paste the following JSON content. (This is a sample student record.)
 {
     ""person"": {
         ""id"": 1001,
         ""firstName"": ""Vinnie"",
         ""lastName"": ""Hickman"",
         ""age"": 15
     }
 }
Click Save.
Similarly, add another JSON record under Inputs named courseDetails with the following content.
 {
     ""course"": [
         {
             ""id"": ""CS6002"",
             ""name"": ""Computation Structures"",
             ""credits"": 4
         },
         {
             ""id"": ""CS6003"",
             ""name"": ""Circuits and Electronics"",
             ""credits"": 3
         },
         {
             ""id"": ""CS6004"",
             ""name"": ""Signals and Systems"",
             ""credits"": 3
         }
    ]
 }
Add the output JSON by following the steps given below:
Under Output Type, click + New Record.
Click  Import a JSON.
In the Name** field, enter  studentDetails.
In the Sample JSON field, paste the following JSON content that has the format in which Choreo should generate the output.
 {
     ""id"": 1001,
     ""fullName"": ""Vinnie Hickman"",
     ""age"": ""15"",
     ""courses"": [
         {""title"": ""CS6002 - Computation Structures"", ""credits"": 4},
         {""title"": ""CS6003 - Circuits and Electronics"", ""credits"": 3},
         {""title"": ""CS6004 - Signals and Systems"", ""credits"": 3}
     ],
     ""totalCredits"": 10
 }
Click Save.
Click Save again to save the data mapper.",https://wso2.com/choreo/docs/develop/explore-code-editor/map-data/,782,D117
Configure Automatic Deployment,Step 2: Enable automatic deployment,"To enable automatic deployment for your REST API, follow the steps given below:First, run a manual build. To do this, click Deploy in the left pane and then click Build and Deploy.
!!! info
Choreo requires you to perform the first deployment of each component manually so that you can provide values for any configurable variables that the implementation may include.
Click the Automatic Deployment toggle to enable automatic deployment.
!!! info
You need to verify your GitHub account when you enable automatic deployment for the first time.
In the message that appears on the bottom-right of the page , click *Configure Alert. The Alert Configuration tab of the Settings page opens.
For the Component build and deployment failure alert, enter a valid email address and click the toggle to enable the alert.
{.cInlineImage-threeQuarters}Now automatic deployment is enabled for your REST API and a build should be automatically triggered every time you commit a change to the REST API implementation. To verify this, move on to Step 3.",https://wso2.com/choreo/docs/deploy/configure-automatic-deployment/,212,D118
Scheduled Tasks,Develop a scheduled task,"Developing a scheduled task refers to configuring an action to be executed.!!! tip
The development stage does not require you to specify the time interval at which the system needs to execute the action of the scheduled task. You need to provide it only when you deploy the Scheduled Task component.e.g., If you need to schedule a health check log for an application, you may need to configure the following:How the Scheduled Task component gets the heartbeat of the application that it is monitoring
The conditions based on which the Scheduled Task component can determine whether the application is healthy or not
A log that indicates whether the application is healthy or not to the end-userYou can develop a scheduled task with such configurations in three possible ways as shown in the image below:{.cInlineImage-half}
h3 -> Start from scratch
You can design a scheduled task via Choreo’s low-code editor that allows developers to design scheduled tasks with ease. This method involves designing the scheduled tasks from scratch by manually specifying the resources, the HTTP verbs, paths, and other required elements. You can do so in the low-code view or the pro-code view.
h4 -> Low-code view
{.cInlineImage-full}The scheduled task in the image above checks for the heartbeat of an application via the HealthCheckAPI connector. It logs Healthy if the application responds with a heartbeat or Unhealthy if the application does not respond.The low-code programming model allows developers to use commonly known programming constructs such as loops, conditions(if/else, variable declarations and assignments), logs, data transformations(visual data mapping), etc., in a graphical editor. It also allows developers to connect to any built-in or custom-developed connectors.The main advantage of the low-code programming view is that it increases developer productivity by multiple folds by eliminating the need to write complex code. As developers use constructs on the low-code editor to implement the integration logic for the scheduled task, the IDE automatically writes the corresponding Ballerina source code of the scheduled task, speeding up the developer's learning process significantly and boosting overall productivity.
h4 -> Pro-code view
In addition to the low-code view, Choreo provides a pro-code view for implementing the functionality of a scheduled task. You can switch between the two flows at any time. Choreo's online IDE allows viewing the low-code and pro-code editors side-by-side as shown below:{.cInlineImage-full}Choreo gives the developers the flexibility to implement the complete scheduled task using the pro-code view or to use the pro-code view for only some parts of the implementation and then use the low-code view for the rest, based on their preference. Choreo treats the source code of the scheduled task as the single source of truth irrespective of whether it is auto-generated from the low-code implementation or written manually by the developer. Therefore, there are no limitations or restrictions on which view developers may choose to implement the functionality of the scheduled task.
h3 -> Connect existing Ballerina repository
If you have a scheduled task written in the Ballerina Programming Language, you can deploy it in Choreo. To do this, you must save it in a private GitHub repository and connect that repository to Choreo.
h3 -> Bring your Dockerfile
If you have an existing scheduled task written in any programming language, you can deploy it in Choreo. To do this, you must generate a Docker image for the scheduled task and save the Dockerfile in a private GitHub repository. When you connect this GitHub repository to Choreo, you can build the Dockerfile to pull the scheduled task implementation from the Docker image.",https://wso2.com/choreo/docs/develop/components/scheduled-tasks/,776,D119
Create Your First Integration as an API,Step 2: Deploy,"Let's deploy the micro integrator REST API you created to the developer environment by following the steps given below:In the left navigation menu, click Deploy.
Click Deploy Manually.
!!! info
Automatic deployment is enabled for the component by default. You are required to carry out only the first deployment manually.Once Choreo has deployed the micro integrator REST API, you can proceed to the next step to test it.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-integration-as-an-api/,88,D120
Configure Enterprise Login,Step 1: Create an organization in Choreo,"To create an organization in Choreo, follow the steps below:Sign in to the Choreo Console at https://console.choreo.dev/ using a Google/ GitHub/ Microsoft account.
Create an organization as follows:
If you are a new user: enter a unique organization name and create an organization. For example, ""Stark Industries"".
{.cInlineImage-small}
If you are a returning user: expand the drop-down for your profile and click Settings. Under Organizations, you can view the organization you created at sign-up.",https://wso2.com/choreo/docs/administer/configure-enterprise-login/,120,D121
Webhook,Develop a webhook,"Developing a webhook is the process of creating the webhook by identifying the trigger event and implementing the logic to execute the event. You can create and design an event-driven integration using webhooks in Choreo easily.Choreo’s low-code editor allows developers to easily design and develop webhooks for platforms such as GitHub, Slack, and Google Calendar, etc. using the integrated pro-code or low-code editor. Creating a webhook in Choreo starts by either creating the Webhook component from scratch or by connecting an existing Ballerina repository. To create a webhook from scratch, you can start by creating a Webhook component and selecting the trigger type(e.g. GitHub).
Next, you can give the webhook a name, select the trigger channel, and select whether to manage the webhook code in a choreo-managed repository or in your own repository.{.cInlineImage-half}Once you have created your webhook, you can start developing the logic for the specific event(E.g. onOpened). Choreo will execute this logic when the webhook is activated. E.g. send an email when an issue gets created in GitHub.Additionally, you can define any configurations needed to run the webhook.
h3 -> Low code mode
{.cInlineImage-threeQuarter}The low-code programming model allows developers to use common programming constructs such as loops, conditions(if/else, variable declarations and assignments, logs, data transformations(visual data mapping), and much more in a graphical editor. It also allows developers to connect to any built-in or custom-developed connectors.Choreo allows you to add multiple triggers and channels to your webhook implementation via the low-code editor. It also shows the configurations needed to deploy the Webhook component.The main advantage of the low-code programming mode is that it increases the developer productivity by multiple folds by eliminating the need to write complex code. As developers use constructs on the low-code editor to implement the integration logic for the webhook, the IDE automatically writes the corresponding Ballerina source code of the webhook. This speeds up the developer's learning process significantly and thereby boosts overall productivity.
h3 -> Pro code mode
In addition to the low-code mode, Choreo provides a pro code mode of implementing the webhook's functionality with the ability to alternate between low-code and pro-code at any time. Choreo's online IDE allows viewing the low-code and pro-code editors side by side:{.cInlineImage-threeQuarter}Choreo gives the developers the flexibility to use the pro-code mode only or use it for implementing certain parts of the API and use the low-code mode for the rest (based on their preference). Choreo treats the source code (generated and handwritten) of the API as the single source of truth and therefore has no limitations or restrictions on which mode developers may choose to implement their webhook's functionality.",https://wso2.com/choreo/docs/develop/components/webhook/,629,D122
GraphQL APIs,Develop,"To create a GraphQL you need to add a GraphQL component.{.cInlineImage-full}Choreo comes with the Web Editor which is an IDE designed based on Visual Studio Code for developers to implement API functionality. At present, developers can design GraphQL APIs in the Web Editor by writing code, and test the functionality via cURL commands before committing the design to a private/Choreo-managed GitHub repository. Once you commit the design, the GraphQL API is available in the Choreo Console, where you can deploy, test, and observe it.{.cInlineImage-full}!!! info
Implementing the GraphQL APIs in the low-code mode is currently not supported.",https://wso2.com/choreo/docs/develop/components/graphql-api/,149,D123
REST APIs,Designing a REST API,"Designing a REST API is the process of declaring the resources, the appropriate HTTP verbs, paths, and input (request) and output (response) data formats to showcase the capabilities of the API. Designing an API based on a standard helps to do the design well and provide a consistent experience to the users of your API. The OpenAPI Specification is the most widely used standard for declaring HTTP/REST APIs. The design of an API is a crucial factor that determines the usability and the value of the API. A well-designed API is profitable due to the ease of adoption.Choreo’s low-code editor allows developers to design (and develop) high-quality REST APIs with ease. To design a REST API in Choreo, you must create a REST API component. You can design a REST API from scratch by manually specifying the resources, the HTTP verbs, paths, and other required elements. The Choreo roadmap also includes the capability to design a REST API by importing an OpenAPI document, which will be available soon.Choreo allows you to design your REST API in three possible ways as shown in the image below:{.cInlineImage-small}Start from scratch
You can design a REST API via Choreo’s low-code editor that allows developers to design (and develop) high-quality REST APIs with ease. This method involves designing the REST API from scratch by manually specifying the resources, the HTTP verbs, paths, and other required elements.
{.cInlineImage-threeQuarter}
Choreo allows developers to easily specify input and output data formats for each API resource:
{.cInlineImage-threeQuarter}
{.cInlineImage-threeQuarter}
Connect existing Ballerina repository
If you have a REST API written in the Ballerina Programming Language, you can deploy it in Choreo. To do this, you must save it in a private GitHub repository and connect that repository to Choreo.
Bring your Dockerfile
If you have an existing REST API written in any programming language, you can deploy it in Choreo. To do this, you must generate a Docker image for the REST API and save the Dockerfile in a private GitHub repository. When you connect this GitHub repository to Choreo, you can build the Dockerfile to pull the REST API implementation from the Docker image.",https://wso2.com/choreo/docs/develop/components/rest-api/,498,D124
View API Insights,Analyzing statistics - Analyzing statistics,"Once you access the Insights page, you can access the following subpages.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/view-api-insights/,16,D125
Connect Your GitHub Repository to Choreo,Connect your GitHub repository,"Let's connect your GitHub repository and use the REST API implementation in it to create a REST API component in Choreo:On the Components page, click +Create on the REST API card.
{.cInlineImage-small}
Enter a unique name and a description for the API. In this tutorial, let's enter the following values:
Field
Value
Name
COVID-19 Statistics
Description
Retrieve COVID-19 Statistics
Click Next.
Provide authorization with your GitHub account by clicking  Authorize with GitHub.
If you have not already authorized Choreo apps, click Authorize Choreo Apps when prompted.
Select a GitHub account, a repository that includes the implementation, the relevant branch, and the build preset (i.e., Ballerina or Dockerfile).
Enter the following values based on the preset you selected above:
Ballerina preset
Path: Enter a valid path relative to the root of your repository that points to the implementation of the REST API. If you have not designed and implemented your REST API yet, you can connect an empty GitHub repository or a sub-folder and proceed to create the component.
!!! info
You can create a component by connecting an empty GitHub repository for the Ballerina preset. However, you can only deploy it after developing and pushing a Ballerina implementation for the relevant component type.
Dockerfile preset:
Dockerfile path: Enter a valid path relative to the root of your repository that points to the Dockerfile. The path must include - Dockerfile. Choreo validates the Dockerfile path and checks if the given file name contains the word Dockerfile ignoring cases.
Docker context path: Enter a valid path relative to the root of your repository that points to the Docker project.
OpenAPI file path (Optional): Enter a valid path relative to the root of your repository that points to the OpenAPI schema. Choreo validates the input to check if the given file name has one of the following extensions: *.yaml, *.yml, or *.json.
Click Create.You have now successfully created your component by connecting your own GitHub repository.Developers can collaborate via any of the following approaches:Use the same upstream repository to create a shared component in the same organization, develop, push changes to the respective tracking branch, and eventually send a pull request to the relevant branch.
Create their forks from the shared upstream repository, connect to individual components, commit, and send pull requests to the upstream repository.Once you collaborate and complete developing the REST API component, you can deploy and test it. For detailed instructions, see steps 2 and 3 in the Create Your First REST API tutorial.",https://wso2.com/choreo/docs/develop/manage-repository/connect-your-own-github-repository-to-choreo/,559,D126
Quick Start Guide,Step 3: Create and publish a new version of the REST API,"Currently, the updates to the readinglist REST API are saved only as long as the deployment status of the readingList API remains Active. If you undeploy and redeploy the readingList API, Choreo deploys it in a new container. Therefore you cannot retrieve the reading list with the updates you made after the last deployment. To persist the data even after undeploying and redeploying the REST API, let's connect it to a MySQL database. Then let's create and publish a new version of the REST API with the ability to persist the data to the MySQL database.
h3 -> Step 3.1: Provision a database
To persist your updates to the reading list, provision a MySQL database on a cloud-based platform. For example, see AWS Documentation - Provision a database.To allow Choreo to interact with the database, add the following IPs to the allowlist of the provisioned database:- 20.22.170.144/28
- 20.22.170.176/28For more information, see Connect with Protected Third Party Applications
h3 -> Step 3.2: Create a new version of the REST API
Let's create a new version of the readingList REST API that can connect to a MySQL database on a cloud platform to persist data, and then redeploy it. To do this, follow the steps given below:In the Choreo Console, open the readingList REST API (if it is not already open) and click the Deploy icon to open the Deploy tab.
Expand the list of versions and click + Create New.
{.cInlineImage-threeQuarters}
Select version-2 as the associated GitHub branch and enter 2.0.0 as the version name. Next click Create.
!!! info
The version-2 GitHub branch has another version of the REST API implementation with the required configurations to connect to the sample MySQL.
Click Config & Deploy. When the Config & Deploy pane opens, enter values for the dbHost, dbUser, dbPassword, dbName, and dbPort fields based on the database you provisioned in Step 3.1: Provision a database.
Click Deploy.Now you have successfully deployed a new version of your REST API.
h3 -> Step 3.3: Publish the new REST API version
To publish the new version of the REST API you created, repeat Step 1.4: Publish the REST API
h3 -> Step 3.4: Consume the new REST API version
You can try out the new version via the front-end application. For more information about accessing and using the front-end application, see Step 2.3.5: Invoke the REST API.!!! info
You do not need to subscribe the readingListApp application on the Developer Portal to the new REST API version because Choreo automatically creates this subscription.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,592,D127
Root Cause Analysis,Detect anomalies and perform root cause analysis,"To detect anomalies of the component, you must trace its executions from the code statement level to the machine it runs in. You can analyze observability data and logs to troubleshoot and identify the root cause for the anomalies you detect.
h3 -> Analyze the throughput graph
The throughput graph depicts the total throughput of the component (which includes both successful and erroneous requests) during a selected time interval. You can analyze the spikes in the throughput graph to identify the root cause for requests that result in an error. The following figure is an example of a throughput graph:{.cInlineImage-full}The actions you can perform in a throughput graph are as follows:View the number of successful requests and errors: To do this, hold the pointer over the area of the graph that shows the required time interval. The throughput graph displays the number of successes over the graph as shown in the figure above (in this example, it displays 757.64 successes and 200.14 errors). The low-code diagram displays the success rate for each API call.
View log entries: If you click the required area on the graph, the log entries applicable for that period are displayed in the Logs pane. In this example, the log displays multiple entries indicating the error employee information not found in the hr-service.
View data for a custom time range: You can expand the graph by clicking and dragging the pointer over the period you want to drill down. The default graph displays data for the last 24 hours.
View details per request: Once you view data for a custom time range, each request that was sent during the selected time range is displayed in a pane above the low-code diagram as shown below.
{.cInlineImage-full}
This pane displays the latency, the time at which the service received the request, and the status.
When you click on a specific request, the low-code diagram displays the following:
If an error has occurred, the error code is displayed near the relevant API call. In this example, the 404 error code has occurred when the request was processed by an API call.
The path (control flow) in which the service executed the request is highlighted in green. In this example, the highlighted path indicates that the selected request was processed on the HTTP API call (on the GET request sent).
The execution time is displayed per if, while, and foreach body. In this example, the execution time taken by the component for the if body is 1.2 milliseconds.
h3 -> Analyze the latency graph
The latency graph depicts the latency of requests over a selected time interval. You can analyze the spikes in the latency graph to identify the API invocations that result in error status. The actions you can perform are as follows:View details of a latency that has occurred: To do this, go to the latency graph under the Throughput & Latency tab and click a data point where there is a spike. This displays the latency, start time, and status of the corresponding requests just above the low-code diagram as shown in the following figure:
{.cInlineImage-full}
View details for a custom time range: If you want to drill down to view details at a higher granularity, drag the pointer over a time range to view the graph for the selected period.
View details per request: The latency graph allows you to view details for each request that the service received during a selected custom time range. For details, see Analyze the throughput graph - View details per request bullet point.
h3 -> Analyze diagnostic data
The Diagnostic View allows you to further drill down the observability data you view in the Throughput & Latency tab to identify possible root causes for anomalies of a service. The following figure is an example of how you can view diagnostic data once you click on the Diagnostics View tab:{.cInlineImage-full}!!! info
The time range applied to the Diagnostics View by default is the same time range for which you viewed the Throughput & Latency before clicking on that tab.If you hold the pointer over a section where you see fluctuations in multiple bins, you can view the related logs as shown in the following figure:{.cInlineImage-half}In this example, the logs indicate that the reason for the errors during the selected time interval was that client has been unable to connect to the hr-service component. This error has occurred 1637 times.In the same example, if you further analyze the sample diagnostic data, you can identify the connectivity error as the most common error.
Based on this, you can conclude that the root cause of the anomalous throughput and latencies is the connectivity issue.",https://wso2.com/choreo/docs/observe-and-analyze/observe/root-cause-analysis/,969,D128
DevOps Portal,View component specific information,"In the Recently Created section, click on a component to open it on a separate page.{.cInlineImage-threeQuarter}On this page, you can view the information described in the following subtopics.
h3 -> Overview
This tab displays the following information:{.cInlineImage-full}!!! Tip
The internal routing URL is an internal endpoint for the component. Other components in the same organization can use this URL to communicate with this component without using the public internet or an internal gateway.In this tab, you can perform the following activities:Deploy or redeploy a component
You can click Deploy or Redeploy as relevant.
Perform advance promotions for a component
When you have multiple environments, the Overview tab of the DevOps Portal allows you to select the environment to which you want to promote the component as shown below:
{.cInlineImage-threeQuarter}
In doing so, you might bypass one or more environments. For example, when you promote a component to the production environment, you can bypass one or more development environments.
Manage replicas
If you are on a private data plane, you can click the + and - icons on this bar to change the minimum and the maximum number of replicas that you want to allow the component to have at any given time.
{.cInlineImage-half}
Each row displays basic information (such as the CPU and memory usage) about an individual replica. If you move the pointer over a row, three icons will appear. These enable you to view the replica events, status, and logs.
h3 -> Containers
This tab displays information related to a selected Docker container such as the URL to the Docker image from which Choreo pulls the component, the image pull policy, resource limits and requests, exposed ports, etc.If you are on a private plane, you can edit this information. You can also add commands and arguments to the Docker image.
h3 -> Configurations and secrets
This tab displays configurations and/or secrets that you have configured for your component.You can also add new configurations and/or secrets.{.cInlineImage-full}
h3 -> Storages
Choreo provides Kubernetes storage support for components to persist state or share volumes between containers.
Choreo allocates a default storage volume for each component. Choreo also allows you to create and manage additional volume for components in an organization where you have set up private data plane support.
h4 -> Create a volume mount for a component
Follow these steps to create a volume mount:Sign in to the Choreo DevOps Portal at https://devops.choreo.dev/, select a project, and click a component to create a volume.
!!! Tip
Ensure the project is in an organization where you have set up the private data plane capability.
Click the Storage tab and then click Let’s Get Started. This opens the Create Volume Mounts pane, where you can specify volume information depending on your requirement.
Enter a Volume Name, add the required labels, and select an appropriate Volume Type.
!!! Tip
You must specify values for the additional volume information depending on the Volume Type you select. For example, if the Volume Type is NFS Server, you must specify the Server IP Address and Path.
Click Continue and proceed to add container mount information.
For the selected container, specify a Mount Path and click Finish.
{.cInlineImage-full}
This creates the volume and displays details of it in the Volume Mounts pane.
{.cInlineImage-full}
You can perform the following actions in the Volume Mounts pane:
Create new volumes and mounts.
Delete existing volumes and mounts.
Search for volumes you have created.
h3 -> Health Checks
This tab allows you to define health checks for a selected container.{.cInlineImage-half}
h3 -> Scaling
In this tab, you can define the thresholds based on which the component can scale horizontally.{.cInlineImage-half}The threshold limits for memory and CPU consumption are available by default, and you can edit them if required. To add a new threshold criterion, click Create. The Create a Scaling Threshold pane opens. In this pane, you can select more threshold criteria. You can also create custom thresholds.When the component reaches the threshold for any resource, the system automatically creates a new replica for it. In this tab, you can specify the minimum and the maximum number of replicas that you want to allow the component to have at any given time.",https://wso2.com/choreo/docs/devops/devops-portal/,968,D129
Manage Applications,Revoke access tokens - part 1,"In the case of theft, security violation, or precaution, Choreo allows an admin to revoke an access token via the revoke token endpoint. You can use a utility like a cURL to invoke this endpoint and revoke your access token.Sign in to the Choreo Developer Portal at https://devportal.choreo.dev. Alternatively, click Developer Portal on the Choreo Console header. {.cInlineImage-half} Click Applications. In the left pane, click OAuth 2.0 Tokens. You will find the Consumer Key (client ID), Consumer Secret (client secret), Token Endpoint, and Revoke Endpoint listed here. You can use these values to revoke the access token.The parameters required to invoke the revoke token endpoint are as follows:access_token_to_be_revoked - The access token to be revoked <base64 encoded (consumerKey:consumerSecret)> - Use a Base64 encoder to encode your consumer key and consumer secret. Choreo does not recommend the use of online Base64 encoders for this purpose. <consumerKey>:<consumerSecret> Thereafter, enter the",https://wso2.com/choreo/docs/consume/manage-application/,237,D130
Develop Integrations with the Micro Integrator,Develop with Integration Studio,"Integration Studio is a graphical development environment for building and deploying integration artifacts in WSO2 Micro Integrator. It is an Eclipse-based IDE that provides a comprehensive set of tools for designing and testing integration flows and building integration artifacts. With WSO2 Integration Studio, developers can create integration projects and develop integration artifacts in a visual, drag-and-drop manner, reducing the time and effort required to build and deploy integration flows. Additionally, the Integration Studio provides features such as debugging, testing, and version control to help ensure the quality and reliability of integration flows.Creating an Integration project and Composite Exporter project in WSO2 Integration Studio allows developers to export their integration projects as a single deployment artifact, called a composite application. This composite application contains all the components and configurations required to deploy the integration project to WSO2 Micro Integrator. The Composite Exporter project helps to simplify the deployment process by allowing developers to package their integration projects as a single, self-contained artifact that can be easily deployed and managed. This can help improve the consistency and reliability of integration projects and simplify the overall deployment process.To get started with Integration Studio, see WSO2 API Manager Documentation - Developing Integration Solutions.",https://wso2.com/choreo/docs/ipaas/micro-integrator/develop-integrations-with-integration-studio/,243,D131
Observability Overview,View and filter all logs,"The Logs panel includes all logs generated by the service. You can filter it based on time or based on text. The following figure shows how this might look:{.cInlineImage-full}To download the log entries, click Download. As a result, the log entries are saved as a .zip file in the location you specify.
h3 -> Trace requests
You can trace requests received by your service at a given timestamp by clicking a point in the time axis of either the throughput or the latency graphs.  The low-code view shows the received requests.
For each request in the low-code view, it displays the request time, the latency, and the status. Furthermore, when you click on a specific request, you can view the status code, request latency, the path (control flow) followed to execute the request, and the execution time per if, while, and foreach body.
The low-code diagram also displays the average request latency and the success rate for each client request that corresponds to the selected time interval.",https://wso2.com/choreo/docs/observe-and-analyze/observe/observability-overview/,215,D132
Create Your First Integration,Step 2: Deploy,"Let's deploy the micro integrator REST API you created to the developer environment by following the steps given below:In the left navigation menu, click Deploy.
Click Deploy Manually.
!!! info
Automatic deployment is enabled for the component by default. You are required to carry out only the first deployment manually.Once Choreo has deployed the micro integrator REST API, you can proceed to the next step to test it.",https://wso2.com/choreo/docs/ipaas/micro-integrator/create-your-first-integration/,88,D133
Forecast Performance Metrics,Use the Performance Analyzer,"You can use the Choreo Performance Analyzer on the Web Editor in low-code mode.
h3 -> Analyze the performance-critical path in real-time
To view the real-time analysis of the performance-critical path of your component, follow the steps below:Sign in to the Choreo Console at https://console.choreo.dev.
Navigate to your component and click Overview from the left pane.
Click Edit Code to access the Web Editor.
h4 -> Overall performance of the performance-critical path
On the low-code editor, you will see a bar with the summarized overall performance estimates for each resource function. By default, this banner displays the forecasted latency and throughput when the indicated user count range executes the performance-critical path. The upper bound of the user count range is set based on the availability of historical data. Since the Performance Analyzer tool derives these metrics in real-time,  any changes to the component will update the metrics in real-time.{.cInlineImage-threeQuarter}By default, the Performance Analyzer tool does not highlight the performance-critical path in the low-code diagram. Click  Reveal performance-critical path on the top banner to highlight it in green in the low-code diagram.
h4 -> Latency estimates for individual API invocations in the performance-critical path
The Performance Analyzer tool displays the estimated latency for each API invocation in the performance-critical path as a banner next to the API invocation in the low-code diagram, as shown below. The Performance Analyzer tool derives these estimates based on the user count range that is indicated on the low-code editor, as a bar with the summarized overall performance estimates for each resource function.{.cInlineImage-threeQuarter}
h3 -> Analyze the performance of all execution paths
By default, the Performance Analyzer tool does not highlight the performance-critical path in the low-code diagram. Click Reveal performance-critical path on the top banner to highlight it in green. A pane opens on the right of the Web Editor. You can perform an in-depth performance analysis of the component in this pane.{.cInlineImage-full}
h4 -> Execution paths
You can view all execution paths in the component in a tabular format listed on top of the Performance Forecast pane. The table shows the entries in descending order based on the time it takes to process a single request in each path.{.cInlineImage-half}The Performance Analyzer tool identifies the execution paths using the service invocations performed by each of them. If an execution path does not include any service invocation, then the latency of that path is assumed to be negligible.You can select any execution path from the table. When you select an execution path, the Performance Analyzer tool will highlight the execution path on the low-code diagram. The estimated overall performance values displayed on the top banner will change based on the execution path selected.
h4 -> Performance forecast graphs
The performance forecast graphs: the latency graph and the throughput graph for the selected path of execution are below the Execution Paths table in the Performance Forecast pane. These performance forecast graphs forecast how the latency and throughput may vary based on the number of users simultaneously accessing the component.{.cInlineImage-half}By analyzing these graphs carefully, you can gain a fair understanding of how well your component will scale with the increasing load.",https://wso2.com/choreo/docs/develop/run-and-test/forecast-performance-metrics/,717,D134
Migrate Applications to the Latest Version,Step 2: Deploy the migrated components,"Choreo adds the migrated components to a project named DefaultProject-{ORGANIZATION_NAME} in the current Choreo version. They are NOT deployed.You can deploy them after editing and testing them in the VS Code Editor as follows:Access the current Choreo version via https://console.choreo.dev/.
In the Home page, select the DefaultProject-{ORGANIZATION_NAME} project.
Click the Components icon in the left navigator to open the Components page. The page displays the APIs, services, and integrations (applications) that you migrated from the previous version. Choreo displays these as a list of components.
Click on a component. It opens on a separate page.
Click Edit with VS Code Online to open the component configuration in the VS Code Editor.
If there are syntax errors in the code, fix them.
!!! help
If you require our assistance to carry out this step, contact us via choreo-help@wso2.com.
Once you correct all the errors in the code, commit the component configuration as follows:
To check whether the code is compiling, open the terminal in the VS Code Editor, and issue the following command:
bal build
If the build is successful, click the Run icon to run the component.
To commit the changes, click Sync with Choreo Upstream (at the bottom of the page), and then click Sync my changes with Choreo.
In the left panel, enter a commit message (e.g., Implement REST API) and click on the tick.
{.cInlineImage-small}
Select Yes in the message that appears to stage the changes.
To push the changes to the GitHub repository, click on the GitHub action menu (marked in the image below) and click Push.
![Push changes](../assets/img/tutorials/rest-api/git-action-menu.png){.cInlineImage-small}
Once you successfully push the changes to the GitHub repository, the VS Code Editor indicates the successful status by displaying the text **In sync with Choreo upstream** for the `service.bal` file.
To deploy the component, go back to the Choreo Console and click on the Deploy icon. Then in the Deploy tab, click Deploy.
To test the component, click on the Test icon. Try out the component using one of the methods provided in that view.
If the tests are successful, click the Deploy icon again, and click Promote under Production to promote the component to production. The deployed components will appear as APIs in the developer portal.!!! info
    The above step is only applicable if the migrated component was an API or a service. For integrations, you can click the **Deploy** icon again and then click **Run Once**.Inform your customers of the migration and request them to subscribe again to the new API (the migrated component) via the Developer Portal.
!!! info
Once all the consumers have switched to the new API, the Choreo team will restrict access to the previous Choreo version.
!!! attention
You need to complete the migration before the 1st of February 2022.",https://wso2.com/choreo/docs/reference/migrate-applications-to-the-latest-version/,675,D135
Choreo Insights API,Inputs,"h3 -> APIUsageByAppFilter
Filters the API usage by application results.
h3 -> APIUsageByBackendOverTimeFilter
Filters the results for API usage by backend over time.
h3 -> APIUsageOverTimeFilter
Filters the results for API usage over time.
h3 -> AlertSummaryFilter
Filters the alerts summary results.
h3 -> ApplicationFilter
Filters applications by the application owner and API IDs.
h3 -> CacheFilter
Filters response cache results.
h3 -> DataFilter
Filters results by the given combination of organization, environment, and tenant.
h3 -> DeviceFilter
Filters results related to devices.
h3 -> ErrorCountByStatusCodeFilter
Filters errors by status code results.
h3 -> ErrorsByCategoryFilter
Filters errors by category results.
h3 -> ErrorsByStatusCodeFilter
Filters errors by status code results.
h3 -> ErrorsDetailsFilter
Filters the results for error details.
h3 -> GeoLocationFilter
Filters the API usage by geolocation results.
h3 -> LatencyFilter
Filters latency results.
h3 -> LatencySummaryFilter
Filters latency summary results.
h3 -> OrgFilter
Filters results for the given organization.
h3 -> PaginationFilter
Filters related to pagination.
h3 -> ResourceUsageFilter
Filters resource usage results.
h3 -> SearchFilter
Filters results by searching matching results for the provided search text.
h3 -> SubscriberFilter
Filters the subscriber results.
h3 -> SuccessAPIUsageByAppFilter
Filters successful API usage by application results.
h3 -> TenantDataFilter
Filters results by the tenant.
h3 -> TimeFilter
Filters results by the provided date range.
h3 -> TopAPIsByAlertCountFilter
Filters the top APIs by alert count results.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,415,D136
Create Your First Event-triggered Integration,Step 3: Update,"In this step, you will be updating the implementation of the event-triggered integration enabling it to listen to the assigning of issue labels in a specific GitHub repository. To do this, follow the steps given below:On the Overview page, copy the URL under Deployment Status.
Access your GitHub account and open the repository for which you want to generate notification emails.
In the top menu, click Settings.
In the left navigation menu, click Webhooks.
Click Add Webhook and enter the following information:
Field
Value
Payload URL
The invoke URL you copied in Step 3, sub-step 1.
Content Type
Select application/json.
Secret
The last webhook secret you configured in Step 2.
Under Which events would you like to trigger this webhook? select Let me select individual events.
Select the Issues checkbox in the list that appears.
By doing so, you select GitHub issues as events that need to trigger this webhook.
In the same list, clear the Pushes check box to ensure that GitHub does not trigger your webhook when the team
pushes changes to the selected GitHub repository.
Click Add Webhook to save the configuration.Now you have integrated Choreo with GitHub via the Event-Triggered Integration you created and deployed. Proceed to step 4 to test it.",https://wso2.com/choreo/docs/ipaas/ballerina/create-your-first-event-triggered-integration/,279,D137
Configure Automatic Deployment,Step 3: Commit changes to trigger the automatic build,"To verify whether your REST API implementation gets automatically deployed when you push commits, follow the steps given below:In the Choreo Console, navigate back to the REST API component for which you enabled automatic deployment.
To update the implementation, click Overview in the left pane and then click Edit Code. The Web Editor opens.
In the Web Editor, make an edit to the REST API implementation. For example, click the last return statement, replace Hello in the statement with Hi, and click Save.
!!! info
To edit this value, double-click it.
Click Sync with Choreo Upstream in the Git status bar.
{.cInlineImage-threeQuarters}
In the message that appears, click Sync my changes with Choreo.
In the left pane, enter a commit message (e.g., Implement REST API) and click the tick.
{.cInlineImage-threeQuarters}
You will get a message prompting you to configure your user.name and user.email. To proceed, follow the steps given below:
In the message, click Open Git Log.
Click Terminal to open the in-built terminal and issue the following commands (with the placeholders replaced with the email and username you use for GitHub):
git config --global user.email ""<YOUR_GITHUB_EMAIL_ADDRESS>""
git config --global user.name ""<YOUR_GITHUB_USERNAME"">
To push the changes to your GitHub repository, click 0↓ 1↑ in the Git Status Bar.
{.cInlineImage-threeQuarters}
!!! info
This icon only appears after the Web Editor completes the committing process.
Click OK in the message that appears.
In the Username field that appears, enter your GitHub username and press Enter/Return.
{.cInlineImage-half}
In the Password field that appears, enter your personal access token for GitHub and press Enter/Return.
Return to the tab in which you are running the Choreo Console.
In the left pane, click Deploy.
Click the refresh icon next to Build and Deployment History.
{.cInlineImage-threeQuarters}
The Build and Deployment History section will display a new record with the Automatic label as shown below for the automatic build you triggered with your last commit.
{.cInlineImage-threeQuarters}
You can click on this record to open the Console panel and view the logs that Choreo generated when it deployed the REST API.
The commit ID in the record (starting with #) is the commit that triggered the automatic deployment. You can click on it to view it in GitHub.",https://wso2.com/choreo/docs/deploy/configure-automatic-deployment/,567,D138
Create Your First Integration,Step 3: Test,"Once you have deployed the Integration REST API you can test it via the OpenAPI Console, or a cURL command.In this tutorial, let's test via the OpenAPI Console:To open the test view, click Test in the Development card. Alternatively, you can click the Test icon in the left panel.
Click OpenAPI Console.
Select the /HelloWorld resource and click Try it out.
Click Execute. Choreo displays the following response under Response body.
{""Hello"":""Integration""}The above response indicates that your micro integrator REST API is working as expected.",https://wso2.com/choreo/docs/ipaas/micro-integrator/create-your-first-integration/,121,D139
Webhook,Deploy a webhook,"Choreo provides an easy, interactive UI to help you deploy the webhook in Choreo to the default development environment. On deployment, Choreo prompts to add the configuration values that the developer has configured.{.cInlineImage-threeQuarter}Choreo runs a professional, enterprise-grade CI/CD process to deploy APIs to its runtime(data plane) clusters. Under the hood, Choreo’s data plane runs on a Kubernetes stack and hence benefits from all its features such as auto-scaling, auto-healing, secret management, liveness, readiness checks, etc. When you deploy a webhook, Choreo checks out your latest code, builds it, creates a Docker image, and starts it in a Kubernetes cluster managed by Choreo. At this point, Choreo also registers the webhook with the relevant event source (e.g., GitHub, Slack, etc.). When the relevant action occurs in the event source, Choreo is notified through the callback. Choreo then activates the webhook and fires events. Choreo exposes HTTP-based webhooks as an API. Therefore, you can test, manage, and observe this API like any other API on Choreo.Once you deploy the webhooks to the development environment, it is active in the developer environment. When you are ready to take the code to production, you can promote the deployment and enable the functionality to your consumers.Choreo allows you to view the deployment logs through the Deploy view. This helps you troubleshoot and view the status of the builds and deployment.
h3 -> Choreo environments
Choreo by default provides a development environment and a production environment in two separate Kubernetes clusters. Once you have deployed the Webhook component to the development environment and its functionality has been verified, developers can then promote their webhooks to the production environment:{.cInlineImage-threeQuarter}Once you have promoted the Webhook component to production, Choreo then shows a second URL that developers can use in production applications to invoke the webhook.
h3 -> Test your webhook
Testing your webhook is an integral part of the spec-driven API development approach. Once you deploy your webhook, it is ready to be tested. Testing your webhook in Choreo can be done in 3 ways:Via the inbuilt OpenAPI Console
Via cURL
With a Postman integration
h3 -> Integrated Console
The in-built Swagger console is an interactive UI where you can test your HTTP-based webhook easily. You can test your webhooks in the environments you deploy them by selecting the environment. Choreo, by default, uses OAuth2.0 authentication. Therefore the Swagger console provides you the option to generate your test keys to test the APIs. Once you meet the pre-requisites, you can test the different resources you defined by specifying any parameters if needed.
{.cInlineImage-threeQuarter}
h3 -> cURL
Choreo provides you with a cURL command based on the resource, method, and environment you want to test your webhook. You need to select the environment, the methods, specify the base path of the resource, and any parameters. Once you provide the information to Choreo, it will generate a cURL command with an API key in place for you to test.{.cInlineImage-threeQuarter}
h3 -> Postman
Choreo also allows you to integrate Postman. To integrate Postman, you need to create a postman account, generate an API Key from Postman, and include them in the Choreo UI. Once you integrate Postman successfully, you can import Postman workspaces, or create new workspaces and continue to test it on Choreo.{.cInlineImage-threeQuarter}",https://wso2.com/choreo/docs/develop/components/webhook/,820,D140
Connect to an External Identity Provider,Step 2: Obtain a JWT from an external IdP to exchange for a Choreo access token,"Follow this procedure:Sign in to the Choreo API Developer Portal at https://devportal.choreo.dev/.
Click the Applications tab.
Create a new application or use an existing application.
In the left navigation menu, click OAuth 2.0 Tokens under Production Keys.
If you have already generated credentials, go to step 6. Otherwise, click Generate Credentials to generate the Consumer Key and Consumer Secret.
!!! tip
Before you click Generate Credentials, click Advanced Configurations and make sure Token Exchange is selected as one of the Grant Types.
{.cInlineImage-half}
Click the User Keys tab.
{.cInlineImage-half}
In the Identity Provider field, select an IdP.
{.cInlineImage-half}
This displays the steps you need to follow to generate a token:
{.cInlineImage-half}
As mentioned in Step 1 in the UI, obtain an access token from the external IdP that you selected. For instructions to obtain an access token for OKTA, see Okta Developer Documentation - Implement OAuth for Okta - Get an Access Token and Make a Request.
Paste the access token in the <Your_IdP_name> Token field. Here, you see the field name displayed as Okta Token.
Click ://Curl and copy the curl command to obtain the Choreo access token. Alternatively, you can click Generate Test Token to get the Choreo access token via the UI.Now you can use the generated Choreo access token to invoke APIs that you have subscribed to using the application.",https://wso2.com/choreo/docs/administer/connect-to-an-external-identity-provider/,348,D141
GraphQL APIs,Lifecycle,"Once you implement a GraphQL API, you can build, test, and eventually put it into production. Choreo executes a CI/CD pipeline to manage the API lifecycle. Choreo stores the source code of APIs in a GitHub repository for the user account. This GitHub repository can be a Choreo-managed repository or a GitHub repository that you own.  It also provides the capability for developers to connect their own GitHub repositories containing the source code of their APIs. The CI/CD pipeline in Choreo takes an API through the complete process, starting from code checkout to compile, build, test, and finally deploy.",https://wso2.com/choreo/docs/develop/components/graphql-api/,129,D142
Develop Integrations with the Micro Integrator,Integration project directory structure,"Integration Project is a multi-module maven project. It can contain multiple modules with WSO2 Synpase configurations and a composite application module to export all the configurations as a single deployable artifact.In addition to the above, you can optionally add the OpenAPI definition file and libraries. You can add the OpenAPI definition to any location in the project, and you need to define its path when creating a component. You can add Java libraries to the libs directory in the project root.",https://wso2.com/choreo/docs/ipaas/micro-integrator/develop-integrations-with-integration-studio/,101,D143
Scheduled Tasks,Deploy a scheduled task,"At the deployment stage, Choreo prompts you to specify the time interval at which it should run the scheduled task to execute the configured action.{.cInlineImage-full}Once you specify the time interval and proceed to deploy, Choreo starts the process of deploying an API to the default development environment as shown below:{.cInlineImage-full}Choreo runs a professional, enterprise-grade CI/CD process to deploy APIs to its runtime(data plane) clusters. Under the hood, the data plane of Choreo runs on a Kubernetes stack, benefitting from all its features such as auto-scaling, auto-healing, secret management, liveness, readiness checks, etc.Once you deploy the scheduled task to the development environment, the system exposes it through an API Gateway with API security turned on.When you deploy the scheduled task to the development environment, it is active in the developer environment. When you are ready to take the code to production, you can promote the deployment and enable the functionality for your consumers.Choreo allows you to view the deployment logs through the Deploy view. Therefore you can troubleshoot and view the status of the builds and deployment.",https://wso2.com/choreo/docs/develop/components/scheduled-tasks/,250,D144
Create Your First Webhook,Step 4: Test,"To test your webhook, create a GitHub issue with the Bug label in the repository to which you connected the webhook.You will receive a mail similar to the following to the email address you provided in Step 2.{.cInlineImage-half}",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-webhook/,53,D145
View API Insights,Analyzing statistics - Overview,"The Overview page gives you a quick overview of the performance of the system. It can be used as a dashboard to view the current system status.{.cInlineImage-full}The information displayed is as follows:Total Traffic
{.cInlineImage-half}
This widget displays the total traffic of the selected environment received during a given time interval. Both successful requests and failed requests are displayed. To investigate further, you can click the arrow icon on the bottom right corner of the widget to open the Traffic page.
Error Request Count
{.cInlineImage-half}
This widget displays the total number of requests that have resulted in errors in your selected environment during the selected time range.
Average Error Rate
{.cInlineImage-half}
This widget displays the average error rate (i.e., error count/total request count) of the selected environment for a given time interval. You can use this widget as an indicator to understand the health of the system. If the error rate is high, you can investigate further by clicking the arrow on the bottom right of the widget and opening the Errors page.
95th Percentile Latency
{.cInlineImage-half}
This widget displays the 95th percentile of all API latencies in your selected environment for the given time interval. You can use this widget to know whether the complete system operates under given SLAs. This metric provides the first indication of slow APIs. To investigate further, you can click the arrow on the bottom right of the widget to open the Latency page where you can further analyze the latency.
API Request Summary
{.cInlineImage-full}
This chart displays the total successful requests, the total requests that have resulted in errors, and the latency in a timeline. The y-axis on the left displays the request count and the error count. The x-axis shows time, and the y-axis on the right shows the latency in milliseconds. The granularity of the data points is decided based on the time range you have selected. The tooltip provides the exact value of all three metrics accurately.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/view-api-insights/,437,D146
REST API Proxy,Test the REST API Proxy,"Once you deploy your API, it is ready to be tested. Testing your REST API Proxy is an integral part of the spec-driven API development approach. Testing your API Proxy in Choreo can be done in 3 ways:Via the inbuilt OpenAPI Console
Via cURL
With a Postman integration
h3 -> In-built OpenAPI console
The in-built OpenAPI console is an interactive UI where you can test your API Proxy easily. You can test your APIs in the environments you deploy them in by selecting the environment. Choreo by default uses OAuth2.0 authentication. Therefore the OpenAPI console provides you the option to generate your test keys to test the APIs. Once you meet the pre-requisites, you can test the different resources you defined by specifying any parameters if needed.{.cInlineImage-threeQuarter}
h3 -> cURL
Choreo provides you with a cURL command based on the resource, method, and environment you want to test your REST API Proxy. You need to select the environment, the methods, specify the base path of the resource, and any parameters. Once you provide the information to Choreo, it will generate a cURL command with an API key in place for you to test.{.cInlineImage-threeQuarter}
h3 -> Postman
Choreo also allows you to integrate Postman. To integrate Postman, you need to create a postman account, generate an API Key from Postman, and include them in the Choreo UI. Once you integrate Postman successfully, you can import Postman workspaces, or create new workspaces and continue to test it on Choreo.{.cInlineImage-threeQuarter}",https://wso2.com/choreo/docs/develop/components/api-proxy/,364,D147
Connect Your GitHub Repository to Choreo,Migrate Choreo-managed repositories to your own GitHub repositories,"If you previously created components on Choreo without connecting your GitHub repository,  your code resides in a Choreo-managed repository. Choreo will remove all Choreo-managed repositories and the relevant components created using them by the 31st of January, 2023. Choreo will send the source code to the users via mail. Users can then use this source code, store it in their GitHub repositories and create new components.If you have published any connectors for these components, Choreo will continue to keep them published. Once you create a new version of the component, you can then publish a new version of the connector. However, any applications using the original version of the connector will have to use the new connector version to use the new REST API. To do this,  a user needs to change the  ServiceUrl (REST API URL) and the auth credentials (generated from the Choreo Developer portal) used by the client application to consume the connector.",https://wso2.com/choreo/docs/develop/manage-repository/connect-your-own-github-repository-to-choreo/,201,D148
Quick Start Guide,Step 1: Create and publish a REST API - Step 1: Create and publish a REST API,"In this step, you are playing the role of the API developer. You will create and publish the REST API that the web application needs to consume.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,30,D149
Create Your First Integration as an API,Step 3: Test,"Once you have deployed the Integration REST API you can test it via the OpenAPI Console, or a cURL command.In this tutorial, let's test via the OpenAPI Console:To open the test view, click Test in the Development card. Alternatively, you can click the Test icon in the left panel.
Click OpenAPI Console.
Select /HelloWorld resource and click Try it out.
Click Execute. Choreo displays the following response in Response body.
{""Hello"":""Integration""}The above response indicates that your micro integrator REST API is working as expected.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-integration-as-an-api/,120,D150
Manage Applications,Revoke access tokens - part 2,"encoded value for this parameter. curl -k -v -d ""token=<ACCESS_TOKEN_TO_BE_REVOKED>"" -H ""Authorization: Basic <base64 encoded (consumerKey:consumerSecret)>"" -H ""Content-Type: application/x-www-form-urlencoded"" https://sts.choreo.dev/oauth2/revoke curl -k -v -d ""token=a0d210c7a3de7d548e03f1986e9a5c39"" -H ""Authorization: Basic OVRRNVJLZWFhVGZGeUpRSkRzam9aZmp4UkhjYTpDZnJ3ZXRual9ZOTdSSzFTZWlWQWx1aXdVVmth"" -H ""Content-Type: application/x-www-form-urlencoded"" https://sts.choreo.dev/oauth2/revoke You receive an empty response with the HTTP status as 200. The following HTTP headers are returned: content-type: text/html content-length: 0 set-cookie: apim=1663574032.947.241.8184|dcb1dc1c03c8f17e5aa485d6222013b8; Path=/oauth2; Secure; HttpOnly x-frame-options: DENY x-content-type-options: nosniff x-xss-protection: 1; mode=block Cache-control: no-store pragma: no-cache revokedaccesstoken: eyJ4NXQiOiJNV1E1TldVd1lXWmlNbU16WlRJek16ZG1NekJoTVdNNFlqUXlNalZoTldNNE5qaGtNR1JtTnpGbE1HSTNaRGxtWW1Rek5tRXlNemhoWWpCaU5tWmhZdyIsImtpZCI6Ik1XUTVOV1V3WVdaaU1tTXpaVEl6TXpkbU16QmhNV000WWpReU1qVmhOV000Tmpoa01HUm1OekZsTUdJM1pEbG1ZbVF6Tm1FeU16aGhZakJpTm1aaFl3X1JTMjU2IiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiJiNWViODFkMC01ZTMxLTQwZDgtYWY0MS03OWMwMjJlNTRhNTciLCJhdXQiOiJBUFBMSUNBVElPTiIsImF1ZCI6Im80VFhsS0J6MGFlSTRCdHdjY2NFeG51cjRDVWEiLCJuYmYiOjE2NjM1NzM4NDksImF6cCI6Im80VFhsS0J6MGFlSTRCdHdjY2NFeG51cjRDVWEiLCJzY29wZSI6ImRlZmF1bHQiLCJvcmdhbml6YXRpb24iOnsidXVpZCI6ImVjMGQxOTk4LWU0ZDUtNDY0ZS1hYzg4LTk4ODgzOTU2MGQ1ZCJ9LCJpc3MiOiJodHRwczpcL1wvc3RzLmNob3Jlby5kZXY6NDQzXC9vYXV0aDJcL3Rva2VuIiwiZXhwIjoxNjYzNTc3NDQ5LCJpYXQiOjE2NjM1NzM4NDksImp0aSI6ImQ3NDgzNDVlLWFjZmQtNDY4OS04YWUxLTY1NzljOTM4NTA0NCJ9.X0YaQGqjAmz_7h7F1S6s2Esxbn2doViQpsCj-U8_aWOHUIUQS0vs-LZwo_ETwjh_iFqG-Ll6d1M9lxO8bvfFyeyBg5qQ22qErj5Vsaz6z-kCzMbnBrRiVhKq4Gf4VdwK8y88kMR7Q3Xzm4wrEMRdQEIpDlMy-1aXtM4Ed8D7ICfvHf4LwgdAWe5-zUJLTpEMnreuQzMD7H4xEQRRSAGIG1w_oOL8Zh8uODEZVljrmQowlbmkUeoVoH_NShlo60OW-eT_GeMjvfMkig_Oz2NN4M9vPpIABm5ABTIg-kzb_mZ27yc9JzlOfXBpfKErnEQd8Pn4vNMT51eFk-ieT4utKJAZuHto0DYjdSdYiyXw3pLrKFxYRNN0IUGfjLpCuTrU-ss9iviBN_StfbEqQHfa9cohJgaXWtOl_YChFahO86OGwSpF_T76OA3RE9juRBJgN-4AsG0cTdnnyoRS3HllfJe7aQwl6qcRoFqNgUvUJjYU1debFe9FUFK4Kv35b6lPhB9KTrPBUvxfGMNdIRGc6AkrIP5Iet6VtfOb8weQWLjpoSFJ7rC4KCd_c2TXpZPVM5Zb4kRs2IHsZBXrosEUJ9a-6xGBCbdlGH5eP5WWAyLX_yf2sj-4iNDR29go2a_Y74mTjCjHKHoBik-V3Al6Jqu8pb_3C4AEIX2KQfxUc6s authorizeduser: b5eb81d0-5e31-40d8-af41-79c022e54a57@carbon.super revokedrefreshtoken: fe037a4a-a187-3333-8dbe-032b8326fca4 strict-transport-security: max-age=15724800; includeSubDomains Note that if you use an invalid access token, you still receive an empty response with the HTTP status of 400 with the following HTTP headers and error description: HTTP/2 400 content-type: text/html content-length: 113 set-cookie: apim=1663579039.216.277.415949|dcb1dc1c03c8f17e5aa485d6222013b8; Path=/oauth2; Secure; HttpOnly x-frame-options: DENY x-content-type-options: nosniff x-xss-protection: 1; mode=block strict-transport-security: max-age=15724800; includeSubDomains * Connection #0 to host sts.choreo.dev left intact {""error_description"":""Error occurred while revoking authorization grant for applications"",""error"":""server_error""}* Closing connection 0",https://wso2.com/choreo/docs/consume/manage-application/,1749,D151
Map Data,Map Data - Step 3: Configure the data mapper,"In this step, you will map parameters in the input JSON with parameters in the output JSON. You will learn how to do basic mappings, troubleshoot mapping errors, and map arrays.
h4 -> Basic mapping
To map the person ID with the student ID, select id under personDetails, and then select id under studentDetails as shown below:{.cInlineImage-threeQuarters}
h4 -> Diagnose and fix mapping errors
If any error occurs when you map parameters, you can fix them in the Statement Editor. To try it, follow the steps given below:Select age under personDetails, and then select age under studentDetails.
{.cInlineImage-threeQuarters}
The connection appears in red to indicate an error in the data mapping (because the data type of the age parameter is different in the two records).
Click on the connection, move the cursor over the warning icon to view the error, and then click Fix by editing expression.
{.cInlineImage-threeQuarters}
Leave the expression selected (as by default), and in the Suggestions tab of the Statement Editor, click toString().
Doing so converts the parameter value to the string format.
{.cInlineImage-half}
Click Save.The connection appears in blue to indicate that there are no errors.
h4 -> Aggregate multiple input fields into one output field
You can derive one output parameter by combining two or more input parameters. In this example, the value for the fullName output parameter is a combination the values for the firstName and lastName input parameters.  You can map them as shown below:{.cInlineImage-threeQuarters}!!! info
By default, the Web Editor combines the two input parameters with a plus (+) operator. If you want to use a different operator or method to integrate two fields, click on the code icon to edit the expression via the Statement Editor.{.cInlineImage-threeQuarters}
h4 -> Map the arrays
When the input and the output contain arrays, you can map an input array with the required output array and then convert the mapping to a query to map the individual parameters within the arrays.In the example in this tutorial, you need to map the course array under courseDetails with the courses array under studentDetails. Let's map them as follows:Select course in the courseDetails and then select courses under studentDetails.
{.cInlineImage-threeQuarters}
The mapping appears in red because the types of the two records you selected are incompatible. Let's move on to the next step to fix it.
To convert the mapping to a query, click the icon for code action and then click Convert to Query as shown below:
{.cInlineImage-threeQuarters}
To map the individual parameters within the array, click the icon for expanding the query.
{.cInlineImage-threeQuarters}
Map the parameters within the arrays as given below:
Map id and name with title. Once you add this mapping, click the icon for editing code and change the expression to courseItem.id + """" + courseItem.name.
{.cInlineImage-threeQuarters}
Map credits under courseItem with credits under courses.
{.cInlineImage-threeQuarters}
Click Configure, and once the Data Mapper pane appears, click Save in it.Now you have successfully configured the data mapper.",https://wso2.com/choreo/docs/develop/explore-code-editor/map-data/,728,D152
Create Your First REST API,Step 3: Test,"Once you have deployed the Choreo application you can test it via the OpenAPI Console, a cURL command, or Postman.In this tutorial, let's test via the OpenAPI Console:To open the test view, click Test in the Development card. Alternatively, you can click the Test icon in the left panel.
Click Try it out.
In the country field, enter USA.
Click Execute.
Choreo displays the following response body under Responses.
{.cInlineImage-half}Congratulations! You have now successfully created and tested a REST API in Choreo!",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-rest-api/,127,D153
Forecast Performance Metrics,Assumptions,"The Performance Analyzer generates forecasts based on the following assumptions:For service-based applications, the overhead of non-I/O operations (CPU-bound operations) is negligible compared to API calls to connectors.
The service under evaluation is deployed with sufficient resources and therefore is not a bottleneck.
Sufficient historical data is available for each service operation or API for the AI models to derive an accurate estimation.",https://wso2.com/choreo/docs/develop/run-and-test/forecast-performance-metrics/,82,D154
Choreo Insights API,Enums,"h3 -> EnvironmentType
Represents an error type.
h3 -> ErrorCodeType
Represents an error code type.
h3 -> ErrorType
Represents an error type.
h3 -> GroupByField
Represents an groupByField used in CustomReports.
h3 -> Metric
Represents a metric used in CustomReports.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,75,D155
REST APIs,Developing a REST API,"Choreo supports spec-driven API development. Once you have carefully designed and defined your API, you can start implementing the functionality of your API. Choreo allows you to link a GitHub project when creating the REST API. You can implement your API as a Ballerina project or as in any language as a Docker container and store in the GitHub repo. Alternatively, if you are selecting the Ballerina preset when creating the REST API, you can link an empty GitHub repository, and then proceed to implement it before deploying the REST API.WSO2 provides a Ballerina extension for Visual Studio Code which you can use to easily develop your REST API as a Ballerina project.",https://wso2.com/choreo/docs/develop/components/rest-api/,140,D156
Performance Analysis,Assumptions,"The Performance Analyzer generates forecasts based on the following assumptions:For service-based applications, the overhead of non-I/O operations (CPU-bound operations) is negligible compared to API calls to connectors.
The service under evaluation is deployed with sufficient resources and therefore is not a bottleneck.
Sufficient historical data is available for each service operation or API for the AI models to derive an accurate estimation.",https://wso2.com/choreo/docs/observe-and-analyze/performance-analysis/,82,D157
Create Your First REST API Proxy,Step 3: Deploy the REST API Proxy,"Deploying the REST API proxy makes it invokable. By default, Choreo maintains two environments for development and production. Learn more. For this tutorial, let's deploy the proxy to the development environment.In the left navigation menu, click Deploy.
Click Configure & Deploy. The Configure & Deploy pane opens.
In the Endpoint field, enter https://samples.choreoapps.dev/company/hr.
The above URL is the endpoint of the sample API.
If you have a sandbox environment to test the API proxy, you can give the URL to that environment in the Sandbox Endpoint field.
Click Save & Deploy.Once you have deployed it to the development environment, you can test it. When you are ready to take it to production, you can return to this view and promote it by clicking Promote on the Development card.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-rest-api-proxy/,181,D158
Configure Enterprise Login,Step 2: Configure enterprise login for your Choreo organization,"To configure enterprise login for your Choreo organization, follow the steps below:Expand the drop-down for your profile and click Settings.
Click Copy Handle to copy the organization handle to the clipboard.
{.cInlineImage-half}
When you add a Choreo organization, Choreo reserves the organization name for your user account. Therefore, you need to create an organization of the same name on the Choreo IdP (i.e., Asgardeo).
To create your organization on the Choreo IdP, follow these steps:
Sign up to Asgardeo with the same credentials you used to create your Choreo account.
Paste the value copied in step 2 as the organization name in Asgardeo and click Create.
{.cInlineImage-half}
To enable enterprise login for your organization, send us an email as follows:
If you already have a support account with us, send us the organization name/handle and the email domains specific to your organization through our support portal.
If you do not have a support account with us yet, send an email to choreo-help@wso2.com requesting to enable enterprise login to your organization.
Mention the following information in the request:
Organization name or handle. For example, “Stark Industries” or “starkindustries”
Email domains specific to your organization. For example, “@stark.com”, “@starkindustries.com”, and “@stark.eu.
!!!info ""Sample Email""
          Subject : [Stark Industries] Configure enterprise login
          
          Content:
              
              Hi CS team,
              Configure enterprise login to my organization and please find the relevant information below.
              Organization name/handle: “Stark Industries”/“starkindustries”
              Email domains specific to my organization: “@stark.com”, “@starkindustries.com”, and “@stark.eu”
              Thank you!
To configure your enterprise login, our support team will send you an email with a verification code. Login to your domain host account and configure the DNS record for your email domain with the following values:
Field
Value
Name/Host/Alias
@ or leave blank
Time to Live (TTL)
Leave default value or use 86400
Value/Answer/Destination
wso2-domain-verification:<verification_code>What's next?Next, you can create a connection to the federated identity provider (For example, Auth0, ADFS, Keycloak, etc.), following the steps below:",https://wso2.com/choreo/docs/administer/configure-enterprise-login/,683,D159
Configure Developer Portal Self-Sign-Up,Approve or reject new users,"To manage the users who try to access your Developer Portal via self-sign-up, you can follow either of the following approaches:Enable auto-approval: This involves automating the user approval process.  When you enable auto-approval, you allow each user who signs up to access your Developer Portal by default.
Manually approve/reject: This allows you to view all the user registrations in a list and approve/reject each registration as required.
h3 -> Enable auto-approval for new user registrations
To enable auto-approval and automatically approve each new user account registered to your Developer Portal, follow the steps given below:Click Settings in the left navigation menu of the Choreo Console.
Click Self Signups.
Toggle the Auto-approval switch.Once you enable auto-approval, the users can sign in to your Developer Portal and view your APIs and applications soon after they create an account.
h3 -> Manually approve or reject user accounts
If you have not enabled auto-approval, you can manually approve/reject the new user registrations. Once a user creates an account, Choreo sends an email to ask the user to confirm the account. To manually approve/reject user accounts that were confirmed by users, follow the steps given below:Click Settings in the left navigation menu of the Choreo Console.
Click Self Signups. You will see the user accounts listed for approval.
If you want to approve a user account, click Approve for it. If not, click Reject.
If you approve, the user will receive an email confirming that the user account is approved.
If you reject the user account, Choreo sends an email to inform the user that the user account is rejected. Once you reject a user account, that user cannot sign up to your Developer Portal via that account again.",https://wso2.com/choreo/docs/administer/configure-developer-portal-self-sign-up/,389,D160
Create Your First Event-Triggered Integration,Step 3: Test,"To test the component, you must publish messages to a designated topic in your RabbitMQ server.Go to the RabbitMQ Management Console and publish the following message to the SalesOrderQueue topic.
{
  ""Orders"": {
    ""Order"": {
      ""Id"": 1,
      ""Price"": 150
    }
  }
}
Now you are ready to observe the logs and see the message received by the integration component.
Go to the iPaaS profile and click the MQTT listener component you created.
Click Observe on the left navigation, go to the Logs section, and observe the message received by the integration component from the RabbitMQ server. You will see a message similar to the following:
!!! info
It can take a few minutes for messages to appear in the Logs section. To view the latest logs, click Load Latest Logs.
{.cInlineImage-full}
This confirms that the event-triggered integration is functioning as expected.
!!! tip
The Observe view allows you to observe statistics related to your Choreo component. For more information on observing a Choreo component, see the Observability overview.Congratulations! You have successfully created an event-triggered integration in Choreo with an existing integration, deployed the integration component, triggered an event, and tested the component.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-event-triggered-integration/,297,D161
Deploy a Containerized Choreo Component,Step 2: Build and deploy,"To implement the REST API, you need to build and deploy it. When you trigger the build you execute the commands in the selected Dockerfile to apply the required configurations to the REST API.To build and deploy the REST API, follow these steps:On the Deploy page, click Build and Deploy.
!!! note
Deploying the REST API component may take a while. You can track the progress by observing the logs.
Once the deployment is complete, the deployment status changes to Active. The Invoke URL field displays the URL via which you can invoke the REST API.
Check the deployment progress by observing the console logs on the right of the page.
You can access the following scans under Build.
The Dockerfile scan: This scans the Dockerfile for a user ID and fails the build if no user is assigned to the Docker container.
Container (Trivy) vulnerability scan: This detects vulnerabilities in the Dockerfile-based image and in the third-party packages that the source code uses. If you click Container (Trivy) vulnerability scan, the details of the vulnerabilities open in a separate pane. If this scan detects critical vulnerabilities, the build will fail.
!!! info
If you want to bypass these vulnerabilities, you need to run Choreo on a private data plane.You can test, manage, and observe this REST API you created from a Dockerfile the way you would a Ballerina component.For detailed instructions, see the following sections of the Create Your First REST API tutorial.Step 3: Test
Step 4: Manage",https://wso2.com/choreo/docs/deploy/deploy-a-containerized-choreo-component/,317,D162
Create a Policy,Step 3: Publish the policy,"You can publish mediation policies to Ballerina Central. When you deploy the API after attaching policies, Choreo pulls these packages from Ballerina Central and bundles them into the interceptor application under the hood. ""For more details on building and deploying an interceptor application, see Policies. To use policies in your APIs, publish them as public packages following the steps given below:Package the policy before publishing it to Ballerina Central by issuing the following command:
    bal pack 
Publish the package to Ballerina Central by issuing the following command:
    bal pushOnce you publish the package, it will be listed in the policy list in the Choreo Console as below:{.cInlineImage-small}",https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,154,D163
Alerts,Types of alerts - Out-of-memory alert,"If the Kubernetes pod that runs your component goes out of memory, it restarts immediately. However, during that interval, the service becomes unavailable and the requests that it was processing at the time can become erroneous.
Due to this, the out-of-memory error can be very adverse for your component. Therefore, when an out-of-memory error occurs, the admin members of the organization that owns the component receive an alert email similar to the sample given below.{.cInlineImage-full}This email contains details about your component and the number of times this event occurred within the alert monitoring period.
You can check the logs and the memory usage during that time interval by clicking Check in Portal. This takes you to the Observe tab of that particular component. You can also contact WSO2 for support via the Contact us link provided at the bottom of the alert email.
h4 -> Troubleshoot out-of-memory error
When you click Check in Portal, you are redirected to the Observe tab of the component in the Choreo Console.{.cInlineImage-full}The item marked 1 in the above image shows the time bin where the out-of-memory error that occurred is highlighted and the other logs that occurred during that time are displayed within the scrollable Logs column. The column also displays the number of times the log occurred.Item 2 is the one-hour time range around the point of time at which the error occurred (i.e. error time +/- 30mins). In the Diagnostic View tab, this time range is further divided into 5 similar-sized time bins. In this scenario, the size of each bin is 12 minutes. These 12-minute bins are marked 3.{.cInlineImage-half}When you hover over the graph, you can view the memory usage. You can note that it has increased steadily during the time interval and reached the maximum value. This causes the application to log the out-of-memory error and restart.
h4 -> Select a custom time range
If you want to change the automatically selected time interval (i.e., one hour) for debugging purposes, do as follows:Click the drop-down bar for time selection (marked in the image below).
{.cInlineImage-half}
Click Custom.
Specify the time range for which you want to view logs in the Diagnostics View tab by entering the required times in the From and To fields.
Click Apply.For more information on how to use the Observe tab for root cause analysis, see Root Cause Analysis.",https://wso2.com/choreo/docs/alerts/,540,D164
Alerts,Types of alerts - Application error alert,"This alert is triggered when you use the log:printError() function in your component and the component logs an error via that. Such errors indicate that your component is unable to function as designed, and therefore you are notified via email so that you can troubleshoot them. The following is a sample of such a notification email.{.cInlineImage-full}This email provides details about the component. You can click Check in Portal to open the Observe tab in the Choreo Console for this component. You can also get support from WSO2 via the Contact us link provided in the email.
h4 -> Troubleshoot application error
Once you click Check in Portal in the notification email, you are redirected to the Observe tab of the component in the Choreo Console.{.cInlineImage-full}This opens the Throughput and Latency view in which the request that caused the error log is automatically selected (see 1  in the image above). The graphs in this tab display the throughput and latency for this request. The color of the graph indicates whether the request was successfully processed or whether it resulted in an error.In addition, you can observe the following:The error log that triggered the alert mail (marked 2 in the image).
The time range for which the error log applies (marked 3 in the image). However, you can scroll to view more logs that occurred during the time range selected for debugging purposes. This time range is selected via the drop-down field marked 5 in the image. You can update this time range as explained under Select a custom time range.
The status and the latency of the request (marked 4 in the image).",https://wso2.com/choreo/docs/alerts/,346,D165
Create Your First Webhook,Step 5:  Promote,"To promote the webhook to the Production environment, follow these sub-steps:On the Deploy page, click Promote
In the Configure & Deploy pane, leave the default selection (i.e., Use default configuration values) unchanged.
If you have configured any default values for the configurable variables, selecting Use default configuration values allows you to proceed with those values.
However, you did not configure any default values for configurable variables in this tutorial. Therefore, you need to enter new values.
To enter values for configurable variables, click Next.
In the toEmail field, enter the email address to which you want the webhook to send the notification emails.
In the webhookSecret field, enter any value.
!!! note
You must save this value for later use.
Click Promote in the pane.
Once the system completes the promoting process, the Production card displays the deployment status as Active.
{.cInlineImage-threeQuarter}",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-webhook/,203,D166
Quick Start Guide,Step 1: Create and publish a REST API - Step 1.1: Create the REST API,"Let's create your first REST API.On the Home page, click on the project you created.
Click Create in the  REST API card.
Enter a unique name and a description for the API. For example, you can enter the name and the description given below:
Field
Value
Name
readingList
Description
Manages reading lists
In the Access Mode field, leave the default selection (i.e., External: API is publicly accessible) unchanged so that users outside your organization can access your API.
Click Next.
To allow Choreo to connect to your GitHub account, click Authorize with GitHub.
If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials, and select the private repository you created by forking https://github.com/wso2/choreo-examples/tree/version-1 to install the Choreo GitHub App.
!!! info
The Choreo GitHub App requires the following permissions:- Read and write access to code and pull requests.- Read access to issues and metadata.You can revoke access if you do not want Choreo to have access to your GitHub account. However, write access is only used to send pull requests to a user repository. Choreo will not directly push any changes to a repository.
{.cInlineImage-half}
In the Connect Repository dialog box, enter the following information:
Field
Description
GitHub Account
Your account
GitHub Repository
choreo-examples
Branch
version-1
Build Preset
Click Ballerina because you are creating the REST API from a Ballerina project and Choreo needs to run a Ballerina build to build it.
Path
reading-list-service
Click Create to initialize a REST API with the implementation from your GitHub repository.The REST API opens on a separate page where you can see its overview.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,405,D167
Webhook,Manage webhooks,"Choreo exposes HTTP-based webhooks as APIs. Therefore, you can leverage the API management capabilities of Choreo to manage these APIs. API Management has automatically turned on for HTTP-based webhooks(and other APIs) on Choreo. Converting an unmanaged API to a managed API is a key advantage. Developers can use its capabilities to manage the exposure of APIs to their consumers. Developers can configure the API’s security settings, set rate limits, associate usage plans, provide other documentation, and perform other related functions to govern the API.
h3 -> Lifecycle of the API exposing the webhook
Once you implement a webhook, it needs to be built, tested, and eventually put into production as an API. Choreo executes a CI/CD pipeline that manages the API’s Lifecycle. Choreo by default stores the source code of webhooks in a private Github repository for the user account. Optionally, a user can choose to store the code in a user-managed repository. The CI/CD pipeline in Choreo takes an API through the whole process, starting with code checkout, to compile, build, test, and finally to deployment.{.cInlineImage-threeQuarter}
h3 -> Add documentation to the API exposing the webhook
A well-designed API needs to be well-documented as well. The usability of the API is a deciding factor of its value. Many API developers find documenting an API a tedious task. Choreo makes documentation an easy task for developers by allowing different sources of documentation. Choreo allows you to add documentation to the REST API by specifying a URL, in Markdown format, importing a file, or by simply including inline documentation.
h3 -> Settings
A well-managed API needs to have security policies and access-control policies in place. Setting rate-limiting policies will ensure:Your API is protected from common types of security attacks such as certain types of Denial Of Service (DOS) attacks
Traffic is regulated and the resources are not exhaustedIn addition to providing different usage plans, Choreo also allows you to set different rate-limiting policies against the API or each resource. While the API level rate-limiting will impact the whole API, resource-level rate-limiting gives you the flexibility to change the rate-limiting policy per operation based on the anticipated or analyzed usage.{.cInlineImage-threeQuarter}Choreo uses OAuth2.0 authentication.{.cInlineImage-threeQuarter}
h3 -> Consumers
Consuming the published APIs is made easy with the inbuilt Choreo Developer Portal. Application developers can discover and invoke published APIs using the Choreo Developer Portal. Learn more about the Choreo Developer Portal.
h3 -> Observe your webhook
You can assess the performance of your webhook by observing the success and failure rates of the requests sent to it. The observability view allows you to visualize the performance statistics via interactive graphs.Learn more on how to observe your webhook from here.",https://wso2.com/choreo/docs/develop/components/webhook/,644,D168
Create Your First Integration as an API,Step 4: Observe,"To observe statistics for your micro integrator REST API, click Observe in the left navigation menu. The graphs for throughput and latency will display the request you sent in Step 3: Test.For more information about observing components, see Observability Overview.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-integration-as-an-api/,50,D169
Define Configurable Variables,Define Configurable Variables - part 1,"A configurable variable allows you to define a parameter for which you specify the value when you deploy the component that includes it.You may want to define a configurable variable in the following scenarios:A Choreo component you create is accessible to all the members of your organization. If a specific variable value contains sensitive information, you can define it as a configurable variable to avoid exposing the value in the component implementation. For example, consider a REST API that returns a password to users whose requests meet specific conditions. In this scenario, you may not want to expose that password to everyone who can access the REST API implementation. You may need to provide different values for a specific variable. For example, each component user may want to provide a unique email address to receive the response.To understand how to define a configurable variable, let's create a REST API that returns a configurable email address to its users as follows:First, let's create the component in which you can add a configurable variable: Sign in to the Choreo Console at https://console.choreo.dev. Under Create a New Component, click REST API to start creating a REST API. In the Create REST API dialog, click Start From Scratch. Next, enter a unique name for the REST API and click Create. !!! Info To learn how to create a REST API with more details, try the . Once the Overview page opens, click Edit Code to open the Web Editor. Now let's define the email address you want to return as a configurable by following these sub-steps: Click the first + icon on the page, and in the Add Constructs pane that appears, click Configurable. {.cInlineImage-threeQuarters} The Configurable pane displays the configurable template. Let's use this template and define the configurable. By default, the data type of the configurable variable is int. To change it to a different type, click int, and click the required type in the list of suggestions. For this guide, click string. To enter a name for the configurable variable, double-click <add-config-name> and enter the required text (e.g., email). By default, the value of the configurable variable is ?. This value specifies that the configurable field should appear",https://wso2.com/choreo/docs/develop/explore-code-editor/define-configurable-variables/,472,D170
Map Data,Map Data - Step 4: Design the REST API with the data mapper,"You can use the data mapper you configured in the REST API implementation.!!! tip
For more information on how to create a REST API, see Create Your First REST APIThe following is a sample REST API implementation that includes the data mapper you configured. It uses a function to derive the sum of the credits a student earned by completing each subject. Then the REST API calculates the total number of credits the student has earned by adding n (i.e., the value provided by the user) to the sum of credits the student earned from the subjects.import ballerina/io;
type Person record {
    int id;
    string firstName;
    string lastName;
    int age;
};
type Courses record {
    record {
        string id;
        string name;
        int credits;
    }[] courses;
};
type Student record {
    int id;
    string fullName;
    string age;
    record {
        string title;
        int credits;
    }[] courses;
    int totalCredits;
};
function transform(Person person, Courses courses) returns Student => {
    totalCredits: getTotalCredits(courses),
    courses: from var coursesItem in courses.courses
        select {
            title: coursesItem.id + "" - "" + coursesItem.name,
            credits: coursesItem.credits
        },
    age: person.age.toBalString(),
    id: person.id,
    fullName: person.firstName + "" "" + person.lastName
};
function getTotalCredits(Courses courses) returns int {
    int total = courses.courses.'map(course => course.credits).reduce(getSum, 0);
    return total;
}
function getSum(int total, int n) returns int
{
    return total + n;
}
public function main() {
    Person person = {
        id: 1001,
        firstName: ""Vinnie"",
        lastName: ""Hickman"",
        age: 15
    };
    Courses courses = {
        courses: [
            {
                id: ""CS6002"",
                name: ""Computation Structures"",
                credits: 4
            },
            {
                id: ""CS6003"",
                name: ""Circuits and Electronics"",
                credits: 3
            },
            {
                id: ""CS6004"",
                name: ""Signals and Systems"",
                credits: 3
            }
        ]
    };
    Student student = transform(person, courses);
    io:println(student);",https://wso2.com/choreo/docs/develop/explore-code-editor/map-data/,924,D171
Deploy a Containerized Choreo Component,Step 3: Manage the deployment,"If you want to view Kubernetes-level insights to carry out a more detailed diagnosis of this Dockerfile-based REST API, click DevOps Portal in the top menu.{.cInlineImage-full}For more information about the information, see DevOps Portal.",https://wso2.com/choreo/docs/deploy/deploy-a-containerized-choreo-component/,58,D172
Create Your First REST API,Step 4: Manage,"Once you have successfully deployed your API and tested it, you can perform the following actions for itManage the lifecycle: You can publish your API to the Developer Portal to make it available for public use, or deploy it as a prototype so that users can try it out and provide feedback for improvement. Once you publish an API, you can deprecate it or block it from being used if required.
Validate subscriptions: You can configure subscription validation to mandate subscriptions.
Add documents: This involves attaching files with information about the API for users.
Select/switch usage plans: You can select a usage plan for your API out of Bronze Silver, Gold, and Unlimited based on the level of traffic that you expect the API to receive. You can change the usage plan when required.
Update API settings.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-rest-api/,165,D173
Develop Integrations with the Micro Integrator,OpenAPI support,"You can develop an OpenAPI definition to define your REST API allowing customers and developers to understand its functionality.  When you develop a REST API on the Integration Studio and deploy it as a Micro Integrator REST API on Choreo, you can attach the OpenAPI specification to it.When you develop a REST API in the WSO2 Integration Studio, you can add an OpenAPI definition to the project. When you create the component, you can provide a path to the OpenAPI Specification (OAS) file.{.cInlineImage-half}",https://wso2.com/choreo/docs/ipaas/micro-integrator/develop-integrations-with-integration-studio/,114,D174
Scheduled Tasks,Choreo environments,"Choreo provides a development environment and a production environment in two separate Kubernetes clusters by default. Once you have deployed the scheduled task to the development environment and verified whether it functions as expected, you can promote it to the production environment.{.cInlineImage-full}If required, you can change the time interval of the scheduled task before you promote it to the production environment.",https://wso2.com/choreo/docs/develop/components/scheduled-tasks/,81,D175
REST API Proxy,Deploying a REST API Proxy,"The following diagram illustrates the process of deploying an API in Choreo to the default development environment.{.cInlineImage-threeQuarter}Choreo runs a professional, enterprise-grade CI/CD process to deploy APIs to its runtime(data plane) clusters. Under the hood, Choreo's data plane runs on a Kubernetes stack, hence benefits from all its features such as auto-scaling, auto-healing, secret management, liveness, readiness checks, and so on. You are required to manually manage this CI/CD pipeline via the Choreo Console.Once you deploy the REST API to the development environment, it is then exposed through Choreo with API security turned on. Developers get a testable URL for their API which they can use to verify the functionality of the API they implemented.You may set up a separate sandbox environment to test the API proxy before pushing it to production. To deploy the API proxy to both the sandbox environment and the development environment, enter the test environment URL as the sandbox endpoint and the API backend URL as the endpoint.{.cInlineImage-small}",https://wso2.com/choreo/docs/develop/components/api-proxy/,234,D176
Manage Applications,Step 2: Generate keys - Step 2: Generate keys,"Choreo provides an OAuth 2.0 bearer token-based authentication for API access. An API access token/key is a string that is passed as an HTTP header of an API request to authenticate the API access.Once you create an application in Choreo, you can then generate the credentials for it. When you generate the credentials for the first time, Choreo gives you a consumer key and the consumer secret for the application. The consumer key becomes the unique identifier of the application, similar to a user's user name, and is used to authenticate the application or user. You can use this consumer key and consumer secret to generate an API access token by invoking the token endpoint. You can also revoke the access token by invoking the revoke endpoint. For testing purposes, you can generate a test token via the UI. However, we strongly recommend that you do not use the test token in your production environment.This section will walk you through the steps to generate an API access token in Choreo.Let's get started!",https://wso2.com/choreo/docs/consume/manage-application/,211,D177
Choreo Insights API,Scalars,"h3 -> Boolean
The Boolean scalar type represents true or false.
h3 -> Float
The Float scalar type represents signed double-precision fractional values as specified by IEEE 754.
h3 -> ID
The ID scalar type represents a unique identifier, often used to re-fetch an object or as the key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as ""4"") or integer (such as 4) input value is accepted as an ID.
h3 -> Int
The Int scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
h3 -> String
The String scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,212,D178
Create Your First Integration,Step 4: Observe,"To observe statistics for your micro integrator REST API, click Observe in the left navigation menu. The graphs for throughput and latency will display the request you sent in Step 3: Test.For more information about observing components, see Observability Overview.",https://wso2.com/choreo/docs/ipaas/micro-integrator/create-your-first-integration/,50,D179
REST APIs,Lifecycle of a REST API,"Once you implement a REST API, you should build it, test it, and eventually push it to the production environment. You can apply any of the six API lifecycles states (i.e., Created, Pre-released, Published, Blocked, Deprecated, and Retired) while adhering to their respective lifecycle flows.When you publish an API, you can also publish a connector for that API to make it available on the Choreo Marketplace.",https://wso2.com/choreo/docs/develop/components/rest-api/,97,D180
Configure Enterprise Login,Step 3: Bring your own identity,"Bring your own identity to Choreo by configuring a federated enterprise IdP on Asgardeo to your organization. Now that you have created an organization in Asgardeo with the same name as your Choreo organization in Step 2, Choreo can authenticate users signing in to that organization. Follow the steps below to configure the federated IdP:Sign in to Asgardeo at https://asgardeo.io/signup?utm_source=console.
To configure a federated enterprise identity provider to your Asgardeo organization, follow the steps in Asgardeo documentation - Add Standard-Based Login.
Next, navigate to Develop and select Applications from the left navigation. You will see an application prefixed “WSO2_LOGIN”.
{.cInlineImage-half}
Click on the application and select the Sign-in Method tab. You can observe the connection you configured in step 2 of this section.
{.cInlineImage-half}You are all set! Your users in the enterprise IdP can now log into the Choreo Console using their user credentials.",https://wso2.com/choreo/docs/administer/configure-enterprise-login/,237,D181
Create Your First REST API Proxy,Step 4: Test your REST API Proxy,"In Choreo, you can test your REST API proxy before publishing it for consumers to use it. Choreo provides you with three modes to test your REST API proxy:OpenAPI Console
cURL
PostmanIn this tutorial, let's use the inbuilt OpenAPI Console.In the left navigation menu, click Test.
In the Environment list, select Development.
Choreo uses OAuth 2.0 Therefore, you will notice the security header. Click Get Test Key to generate a new test key for testing purposes.
Let's invoke. Expand the GET resource with the /department/{departmentId} path and click Try it Out.
Enter 1 in the departmentId field and click Execute.
You will see the following response:
 {
  ""id"": ""1"",
  ""name"": ""Finance""
 }",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-rest-api-proxy/,179,D182
GraphQL APIs,Deploy,"The following diagram illustrates the procedure to deploy an API in Choreo to the default development environment.{.cInlineImage-full}Choreo runs a professional, enterprise-grade CI/CD process to deploy APIs to their runtime(data plane) clusters. The data plane of Choreo runs on a Kubernetes stack under the hood. Therefore, you can benefit from its features such as auto-scaling, auto-healing, secret-management, liveness and readiness checks, etc.Once you deploy a GraphQL API to the development environment, it gets exposed through an API Gateway with API security enabled. At this time, Choreo provides a test URL for the API, which you can use to verify the functionality of the API.",https://wso2.com/choreo/docs/develop/components/graphql-api/,157,D183
Create a Policy,Write unit tests,"Writing unit tests to test policy functions is similar to writing unit tests for a regular Ballerina function.Let’s write a unit test for the validateRequestHeader function.import ballerina/http;
import choreo/mediation;
import ballerina/test;
@test:Config {}
public function testRequestHeaderValidationFailure() {
  http:Request req = new;
  http:Response|false|error|() result = validateRequestHeader(createContext(""get"", ""/test""), req, ""testHeader"", ""test"");
  if !(result is http:Response) {
    test:assertFail(""Expected http:Response, found "" + (typeof result).toString());
  }
  test:assertEquals(result.statusCode, http:STATUS_BAD_REQUEST, ""Status code mismatch"");
}
function createContext(string httpMethod, string resPath) returns mediation:Context {
   mediation:ResourcePath originalPath = checkpanic mediation:createImmutableResourcePath(resPath);
   mediation:Context originalCtx =
               mediation:createImmutableMediationContext(httpMethod, originalPath.pathSegments(), {}, {});
   mediation:ResourcePath mutableResPath = checkpanic mediation:createMutableResourcePath(resPath);
   return mediation:createMutableMediationContext(originalCtx, mutableResPath.pathSegments(), {}, {});
}The policy function modifies the same request/response/context instance that you pass to it. Check the request/response/context instance after calling the policy function to verify these changes.",https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,374,D184
Create Your First Event-triggered Integration,Step 4: Test,"To test your Event-Triggered Integration, create a GitHub issue with the Bug label in the repository to which you connected the webhook.You will receive a mail similar to the following to the email address you provided in Step 2.{.cInlineImage-half}",https://wso2.com/choreo/docs/ipaas/ballerina/create-your-first-event-triggered-integration/,57,D185
View API Insights,Analyzing statistics - Traffic,"The Traffic page shows information related to the traffic that goes through your API management deployments. This includes API usage, application usage, resource usage, etc. You can use this page to investigate the usage of APIs and applications, traffic patterns, etc.{.cInlineImage-full}You can filter the information displayed in the widgets as follows:",https://wso2.com/choreo/docs/observe-and-analyze/analyze/view-api-insights/,70,D186
Create Your First Integration as an API,Step 5: Publish,"Let's publish the micro integrator REST API to make it available for subscriptions in the Developer Portal.In the left navigation menu, click Manage, and then click Lifecycle.
Click Publish.
The lifecycle status of the API will change to Published.
To view the API in the Developer Portal, click Go to Devportal. The API opens on a separate page in the Developer Portal.Congratulations! You have successfully exposed an integration designed in the WSO2 Integration Studio as a REST API in Choreo and published it!!!! info ""What's next""
For a micro integrator REST API, you can also perform API management actions. For more information about these API Management actions, see API Management.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-integration-as-an-api/,147,D187
Alerts,Types of alerts - Anomaly alert,"This alert is triggered when average latency exhibits a considerable upward shift compared to what the system observed during the last five minutes for a resource function. Latency spikes and upward latency shifts are considered high latency.Anomaly alerting is disabled by default. An organization administrator needs to enable it.Choreo alerts a user of this anomaly via email. This email includes details to identify the component and the resource function, anomaly time stamp, etc. The email has a link that takes a user to the components' latency graph in the observability view pane. A user can view the latency graph by clicking on the link Check in Portal in the email and thereby perform an RCA for the anomaly.The anomaly detector issues two types of alerts:
The immediate alert as as soon as the anomaly is detected
The aggregated alert in which it aggregates all the anomalies detected in the last 15 minutes. The anomaly detecter sends this following the immediate alert.",https://wso2.com/choreo/docs/alerts/,190,D188
Scheduled Tasks,Observe a scheduled task,"You can assess the performance of your scheduled task by observing the success and failure rates of the requests sent to it. The observability view allows you to visualize the performance statistics via interactive graphs.To learn more about how you can observe your scheduled task, see Observability Overview.",https://wso2.com/choreo/docs/develop/components/scheduled-tasks/,55,D189
Manage Applications,Step 2: Generate keys - Access token for testing,"You can generate an access token for testing using the Choreo UI by following the steps below:Sign in to Choreo Developer Portal at https://devportal.choreo.dev. Alternatively, click the Developer Portal link on the Choreo Console header.
Click Applications.
In the left pane, click OAuth 2.0 Tokens.
Expand the Advanced Configurations section and review the options.
{.cInlineImage-half}
Grant Types: The grant types used to generate the access token.
Public Client: Identify the application as a public client to allow authentication without a client secret. You can use this for applications running on a browser or mobile device.
Application access token expiry time: The access token expiry time (seconds).
Refresh token expiry time: The refresh token expiry time (seconds).
ID token expiry time: ID token expiry time (seconds).
Click Generate Credentials to generate the credentials for the application for the first time. Once you generate the keys, you can find the application's consumer key and consumer secret.
{.cInlineImage-half}
!!! info
You can use the UI to generate a test token using the consumer key and consumer secret for the application, only for test purposes. We strongly recommend NOT using this token in your production environment.
Click :// CURL to copy the cURL command template for generating the access token. You can generate an API access token by adding the consumer key and consumer secret to the URL and invoking the token endpoint.
{.cInlineImage-half}",https://wso2.com/choreo/docs/consume/manage-application/,336,D190
REST APIs,Deploying a REST API,"The following diagram illustrates the procedure to deploy an API in Choreo to the default development environment.{.cInlineImage-small}Choreo runs a professional, enterprise-grade CI/CD process to deploy APIs to their runtime(data plane) clusters. The data plane of Choreo runs on a Kubernetes stack under the hood. Therefore, you can benefit from its features such as auto-scaling, auto-healing, secret-management, liveness and readiness checks, etc.Choreo allows developers to connect their own GitHub repositories containing the source code of their APIs. The CI/CD pipeline in Choreo takes an API through the complete process, starting from code checkout to compiling, building, testing, and finally deploying.Once you deploy a REST API to the development environment, it gets exposed through an API Gateway with API security enabled. At this time, Choreo provides a test URL for the API, which you can use to verify the functionality of the API.",https://wso2.com/choreo/docs/develop/components/rest-api/,207,D191
Define Configurable Variables,Define Configurable Variables - part 2,"as an empty field at deployment. For this guide, let's leave it unchanged. Click Save. The Web Editor displays the added configurable as shown in the image below: {.cInlineImage-half} Now let's update the last return statement to return the configurable variable you added instead of the default greeting. To do this, follow these sub-steps: Click the edit icon on the last return statement (shown in the image below). {.cInlineImage-half} This Return pane opens, displaying the existing return statement. Click name and then click Expressions. Under Arithmetic, click Es + Ex. Double-click add-expression, and enter ""Please email your application to "". Click Es + Ex again, and then click Suggestions. In the list of suggestions, click email. Here, you are selecting the configurable variable that you previously added. Click Save. You have completed editing the REST API configuration. To view the code view of the REST API, click the icon marked in the image below: {.cInlineImage-full} You will see the configurable you added in the code view as configurable string email = ?;. Commit and push the REST API changes you made to GitHub so that they are also available in the Choreo Console. For instructions, see Create Your First REST API - Step 1.5: Commit the REST API to GitHub. Open the browser tab in which you are running the Choreo Console and refresh it. Click Deploy in the left navigation menu for your REST API. To deploy the REST API, click Config & Deploy. The Configure & Deploy pane opens on the left of the page. The email field in this pane is the configurable you added to the REST API implementation. Choreo saves the value you enter here in an Azure key vault. In the email field, enter any email address. Click Deploy. Once Choreo completes the deployment, the Configurables field indicates that the REST API has a configured key. {.cInlineImage-full} If you want to enter a different value for the configurable, you can click on the edit icon in this field and repeat steps 9-10.Now you have tried out adding a basic configurable. Proceed to the subsections to learn how to add configurables with default values and define configurable variables as you develop your",https://wso2.com/choreo/docs/develop/explore-code-editor/define-configurable-variables/,485,D192
Create Your First Integration,Step 5: Publish,"Let's publish the micro integrator REST API to make it available for subscriptions in the Developer Portal.In the left navigation menu, click Manage, and then click Lifecycle.
Click Publish.
The lifecycle status of the API will change to Published.
To view the API in the Developer Portal, click Go to Devportal. The API opens on a separate page in the Developer Portal.Congratulations! You have successfully exposed an integration designed in the WSO2 Integration Studio as a REST API in Choreo and published it!!!! info ""What's next""
For a micro integrator REST API, you can also perform API management actions. For more information about these API Management actions, see API Management.",https://wso2.com/choreo/docs/ipaas/micro-integrator/create-your-first-integration/,147,D193
GraphQL APIs,Choreo environments,"Choreo provides a development environment by default and a production environment in two separate Kubernetes clusters. Once you deploy an API to the development environment and verify its functionality, you can promote the API to the production environment.{.cInlineImage-full}Once you promote an API to production, Choreo provides a second URL that you can use in a production application to invoke the API.",https://wso2.com/choreo/docs/develop/components/graphql-api/,83,D194
Create Your First Webhook,Step 1: Develop - Step 1: Develop,"To create a project, add a Webhook component to it, design the webhook, test it, and then commit it to make it available in the Choreo Console, follow these sub-steps:",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-webhook/,42,D195
Quick Start Guide,Step 1: Create and publish a REST API - Step 1.2: Deploy the REST API,"For the REST API to be invokable, you need to deploy it. To deploy the REST API, follow the steps given below:Navigate to the Choreo Console. You will be viewing an overview of the readingList REST API.
In the left pane, click Deploy, and then click Configure & Deploy.
!!! info
Automatic deployment is enabled for the REST API by default. You are required to carry out only the first deployment manually. When automatic deployment is enabled, your REST API is automatically deployed every time you push a commit to the GitHub repository in which its implementation resides. You can disable automatic deployment if required.
In the Configure & Deploy pane, click Deploy without entering a sandbox endpoint.
!!! info
In this example, you are testing the REST API only in the Choreo Console and not in a sandbox environment. Therefore, you do not need to enter a sandbox endpoint.
This deploys the API to the development environment.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,199,D196
Create a Policy,Step 2: Implement the policy - Step 2: Implement the policy,"Let's implement a policy to validate an incoming header in the request and the response as follows:Request path: If the request header is not present or if the validation fails, let's log an error and return a 403 Bad Request response to the client.
Response path: Let's log a message to indicate whether the request is valid or not.To implement the policy, open the the Policy.bal file in the Ballerina project and fill in/modify the generated policy stubs(i.e., request, response, or fault). The following are sample implementations for the Request and Response stubs:",https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,124,D197
Develop Integrations with the Micro Integrator,Third-party libraries,"Adding third-party JARs to the Micro Integrator can provide the following benefits:Providing additional functionality that is not available in the core Micro Integrator distribution to allow greater flexibility and customization of integration solutions.
Allowing the Micro Integrator to integrate with existing systems such as databases or other APIs, improving the overall integration capabilities.
Providing optimized implementations of common functions, improving the performance of Micro Integrator.
Developers can avoid having to re-implement commonly used functions, reducing development time and increasing efficiency.To add third-party libraries to the Micro Integrator, you can add a new directory named libs to the root of the Micro Integrator project. When you deploy the component, all the JARs in the libs directory in the project path will be included in the Micro Integrator runtime.{.cInlineImage-half}",https://wso2.com/choreo/docs/ipaas/micro-integrator/develop-integrations-with-integration-studio/,177,D198
REST API Proxy,Choreo environments,"Choreo by default provides a development environment and a production environment in two separate Kubernetes clusters. Once you have deployed the API to the development environment and its functionality has been verified, developers can then promote their APIs to the production environment:{.cInlineImage-threeQuarter}Once you have promoted the API to production, Choreo then shows a second URL that developers can use in production applications to invoke the API.",https://wso2.com/choreo/docs/develop/components/api-proxy/,89,D199
Create Your First REST API Proxy,Step 5: Manage your REST API Proxy,"Now that you have a tested REST API proxy, let's publish it and make it available for application developers to consume.
h3 -> Step 5.1: Secure your REST API Proxy
First, let's review the security settings and add a rate limit to the API.Click Manage on the left navigation and click Settings.
Click Security. Review the security settings. If you wish to change the security settings, click Edit and make the necessary changes. Once the changes are confirmed, you can save them by clicking Save.
{.cInlineImage-full}
Next, let's add a rate-limiting policy to the API. Click Resources.
Click Edit.
Select API Level as the rate-limiting level and then select the required rate-limiting level. Here, you are adding a rate-limiting policy for the entire API.
{.cInlineImage-full}
!!! info
You can also apply rate limits per resource as shown in the image below.{.cInlineImage-full}Learn more.
Click Save.
h3 -> Step 5.2: Apply usage plans on the REST API Proxy
Apply usage plans on the REST API proxy to allow API developers to select the suitable usage plan when subscribing to the REST API proxy.In the left pane, click Usage Plans.
Select the Bronze, Gold, and Unlimited checkboxes.
Click Save.
h3 -> Step 5.3: Publish the REST API Proxy
Publishing the REST API proxy makes it available for consumers to discover and subscribe.In the left pane, click Lifecycle.
Click Publish.
A message appears where you can specify whether you want to publish a connector for this REST API proxy. Creating a connector for this REST API proxy makes it available in the Marketplace. Click Yes, Please.
Click Publish Connector.
This changes the status of the API to Published.
To understand how a user can generate credentials for the API and then invoke it, proceed to the next step.
h3 -> Step 5.4: Invoke your REST API Proxy
Now your REST API proxy is ready to be consumed. An application developer can discover your REST API proxy, subscribe to it, and invoke it.
h4 -> Step 5.4.1: Generate Credentials
On the Lifecycle Management page, click Go to DevPortal.
{.cInlineImage-full}
Once you open the API Developer Portal, click Credentials in the left navigation menu.
Click Generate Credentials. Choreo populates the Consumer Key and Consumer Secret fields with newly generated tokens.
Click ://Curl. Then copy the cURL command that is displayed.
!!!info
Click the icon for copying to copy the cURL command. Do not manually copy it. The displayed cURL command is only a template, and it does not include the generated credentials.
Close the Get cURL to Generate Access Token card. Then click Update.
A message appears to confirm that the keys are successfully updated.
Issue the cURL command you copied to generate an access token.
!!! info ""Before issuing the cURL command:""
Replace consumer-key and consumer-secret with the consumer key and the consumer secret you generated in the API Developer Portal.
Now, let's try out the REST API proxy you created by invoking a resource.
h4 -> Step 5.4.2; Invoke the REST API Proxy
In the left navigation menu, click Try out.
Enter the following values:
Field
Value
Environment
Development
Access Token
the generated access token in step 6. Alternatively, click Get Test Key to generate a test access token.
Expand the GET resource with the /department/{departmentId} path and click Try it out.
Enter the departmentId value as 1.
Click Execute and observe the response.Congratulations! You have successfully created your first REST API Proxy, deployed, developer tested, managed, and invoked it.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-rest-api-proxy/,839,D200
Create Your First Event-triggered Integration,Step 5: Promote,"To promote the Event-Triggered Integration to the Production environment, follow these sub-steps:On the Deploy page, click Promote.
In the Configure & Deploy pane, leave the default selection (i.e., Use default configuration values) unchanged.
If you have configured any default values for the configurable variables, selecting Use default configuration values allows you to proceed with those values.
However, you did not configure any default values for configurable variables in this tutorial. Therefore, you need to enter new values.
To enter values for configurable variables, click Next.
Click Promote in the Configure & Deploy pane.
Once the system completes the promoting process, the Production card displays the deployment status as ActiveCongratulations! You have created your first event-driven integration, deployed it, updated its implementation to integrate with GitHub, tested it, and promoted it to production!",https://wso2.com/choreo/docs/ipaas/ballerina/create-your-first-event-triggered-integration/,182,D201
View API Insights,Analyzing statistics - Errors,"The Errors page shows information related to erroneous API calls that are received by your system. The errors are categorized based on the error type. You can further drill down using the error subtypes. Use this page as the starting point for debugging any API errors.{.cInlineImage-full}You can filter the information displayed in the widgets as follows:
h4 -> Viewing errors by category
The following widgets are available for monitoring errors when you have selected Category in the upper-right corner of the page.This graph shows the error by category over time for the selected period. Apply the required filters as explained above to select the APIs and the error categories to which this content applies. When you select multiple APIs, the error count is grouped by category.
{.cInlineImage-full}
This table provides further information about the errors such as application details and the error reason. For some authentication errors, the application name is not available. You can use this table to get more concrete information about the errors related to your APIs and then start the problem identification.
{.cInlineImage-full}
h4 -> Viewing errors by status code
The following widgets are available for monitoring errors when you selected Status Code in the upper-right corner of the page.Errors by Status Code
This graph shows the distribution of HTTP status codes received for errors over time for the selected period. Apply the required filters as explained above to select the APIs and status code groups to which this content applies. When you select multiple APIs, the error count is grouped by the status code.
{.cInlineImage-full}
Target Errors by Status Code
This graph shows the distribution of target errors that have occurred during the selected time interval by HTTP status code. Apply the required filters as explained in the table above to view the APIs and status code groups to which this content applies. If you select multiple APIs, the widget groups the target error count by the status code.
{.cInlineImage-full}
Errors
The Errors heat map shows the HTTP response codes of errors sent to the client by the API Gateway. Each row displays the number of times the system returned each status code for the selected APIs. The cell color is red for higher numbers and white for lower numbers. If required, you can further filter the results by the error code groups you identified with the Errors by Status Code graph.
{.cInlineImage-full}
Target Errors
The Target errors heat map shows the HTTP response codes of errors that the API Gateway received from the backend. Each row displays the number of times the system returned each status code for the selected APIs. The cell color is red for higher numbers and white for lower numbers. If required, you can further filter the results by the error code groups you identified with the Target Errors by Status Code graph.
{.cInlineImage-full}",https://wso2.com/choreo/docs/observe-and-analyze/analyze/view-api-insights/,596,D202
Configure Enterprise Login,Role-based access control for Enterprise login,"Choreo allows you to configure your users residing in an external IDP (Identity Provider) to log in to Choreo with appropriate permissions seamlessly based on their role.Follow the steps below to configure role-based access control to an enterprise login in Choreo:
h3 -> Prerequisites
Configure Enterprise Login for your organization.
Be sure your Enterprise IDP includes the groups/roles attributes in the tokens it sends to Asgardeo in the respective protocol.
Be sure you have admin privileges in Choreo.
h3 -> Step 1: Configure Asgardeo
Configure your IDP as an External IDP in Asgardeo. Depending on your IDP, you may select OpenID Connect or SAML as the protocol between Asgardeo and your IDP.
!!! note
If you are using OpenID Connect, configure the requested scopes accordingly for Asgardeo to get the relevant group/role details from the external IDP.
 ![scopes](../assets/img/administration/configure-enterprise-login/configure-requested-scopes.png){.cInlineImage-half}
Configure the application as follows:
Go to the Asgardeo Console. Click Develop -> Applications -> WSO2_LOGIN_FOR_CHOREO_CONSOLE and then select Sign-in Method.
Depending on the protocol you selected above, configure your login to use the above IDP.
For OpenID Connect, follow: https://wso2.com/asgardeo/docs/guides/authentication/enterprise-login/add-oidc-idp-login/#enable-the-oidc-idp-for-login
For SAML, follow: https://wso2.com/asgardeo/docs/guides/authentication/enterprise-login/add-saml-idp-login/#enable-the-saml-idp-for-login
Go to User Attributes  and add the groups attribute to the user attribute list and mark it mandatory.
{.cInlineImage-half}
Configure the attribute/scope settings.
Go to the Asgardeo Console. Click Manage -> Scopes -> Open ID.
Click New Attribute and add the Groups attribute to the list.
{.cInlineImage-half}
h3 -> Step 2: Map Asgardeo groups to Choreo Roles in the Choreo Console
!!! note
1. This configuration can be done only by the organization Admin.
2. The Choreo organization admin should add the group role mapping entry for the Admin role to enable the external enterprise organization Admin to access this page.Log in to the Choreo console.
From the left navigation menu, click Settings.
Click Organization -> Role Mapping
To add a new group role mapping, click Add Mapping.
{.cInlineImage-half}
Enter the exact Groups name configured at the Enterprise IdP and map the list of Choreo roles by selecting the checkbox(s) from the list.
Click Save.!!! note
1. You can assign one or more roles to each group.
2. You can only update the role name. The group name is not editable.
3. If a change in the group role mapping occurs, it will take effect from the next login session onwards.
4. If there are no mappings, all the enterprise users will be applied with the default developer role.",https://wso2.com/choreo/docs/administer/configure-enterprise-login/,746,D203
Create a Policy,Step 2: Implement the policy - Request Flow,"The following is a sample implementation for the request flow:@mediation:RequestFlow
public function validateRequestHeader(mediation:Context ctx, http:Request req, string headerName, string headerValue) returns http:Response|false|error|() {
   string|http:HeaderNotFoundError header = req.getHeader(headerName);
   if (header is http:HeaderNotFoundError) {
    string message = string `Header ${headerName} is not found`;
    log:printError(message);
    return generateResponse(message, http:STATUS_BAD_REQUEST);
   }
   if (header != headerValue) {
    string validationFailedMessage = string `Header validation failed. Expected ${headerValue} but found ${header}`;
    log:printError(validationFailedMessage);
    return generateResponse(validationFailedMessage, http:STATUS_BAD_REQUEST);
    }
    log:printInfo(""Header validation successful"");
    return ();
}
function generateResponse(string message, int statusCode) returns http:Response {
    http:Response response = new();
    response.setTextPayload(message); 
    response.statusCode = statusCode;
    return response;
}",https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,315,D204
REST API Proxy,Manage the REST API Proxy,"API Management is automatically turned on in REST API Proxies (and other APIs) on Choreo. Converting an unmanaged API to a managed API is a key advantage of exposing REST API Proxies. Developers can use its capabilities to manage the exposure of APIs to their consumers. Developers can configure the API’s security settings, set rate limits, associate usage plans, provide other documentation, and perform other related functions to govern the API.
h3 -> Lifecycle of a REST API Proxy
Once you implement a REST API Proxy, it needs to be tested, deployed, and eventually put into production. Once you deploy the REST API Proxy, you can apply any of the six API lifecycles states (i.e., Created, Pre-released, Published, Blocked, Deprecated, and Retired) while adhering to their respective lifecycle flows.When you publish an API, you can also publish a connector for that API to make it available on the Choreo Marketplace.{.cInlineImage-threeQuarter}
h3 -> Add documentation to the REST API Proxy
A well-designed API or API Proxy needs to be well-documented as well. The usability of the API/API Proxy is a deciding factor of its value. Many API developers find documenting an API a tedious task. Choreo makes documentation an easy task for developers by allowing different sources of documentation. Choreo allows you to add documentation to the REST API by specifying a URL, in Markdown format, importing a file, or by simply including inline documentation.
h3 -> Usage Plans
The usage plan determines the number of requests allowed for the API per minute. Therefore, this is also the rate limit that applies to an API.{.cInlineImage-threeQuarter}
h3 -> Settings
A well-managed API needs to have security policies and access-control policies in place. Setting rate-limiting policies will ensure:Your API is protected from common types of security attacks such as certain types of Denial Of Service (DOS) attacks
Traffic is regulated and the resources are not exhaustedIn addition to providing different usage plans, Choreo also allows you to set different rate-limiting policies against the API or each resource. While the API level rate-limiting will impact the whole API, resource-level rate-limiting gives you the flexibility to change the rate-limiting policy per operation based on the anticipated or analyzed usage.{.cInlineImage-threeQuarter}Choreo uses OAuth2.0 authentication.{.cInlineImage-threeQuarter}
h3 -> Consumers
Consuming the published APIs is made easy with the inbuilt Choreo Developer Portal. Application developers can discover and invoke published APIs using the Choreo Developer Portal.To learn more about the Choreo Developer Portal, see Developer Portal.",https://wso2.com/choreo/docs/develop/components/api-proxy/,598,D205
Manage Applications,Step 2: Generate keys - Renew an access token using the refresh token grant type,"!!! note
- To use this grant type, you will need the refresh token you received when you generated your current access token.
- Your application must have the Refresh Token grant type enabled.
- You can use a refresh token only once.You can use a refresh token to obtain a new access token when your current access token expires or when you need to renew the access token due to security reasons. You need to use the Refresh Token grant type for this purpose.To generate a new access token and a new refresh token, you can invoke the Token API by replacing the <refresh-token> with the refresh token you received with the access token and replacing <base64(consumerKey:consumerSecret)> with the application's Consumer Key value and Consumer Secret value as follows:curl -k -d ""grant_type=refresh_token&refresh_token=<refresh-token>"" -H ""Authorization: Basic <base64(consumerKey:consumerSecret)>"" -H ""Content-Type: application/x-www-form-urlencoded"" https://sts.choreo.dev/oauth2/tokencurl -k -d ""grant_type=refresh_token&refresh_token=3154090c-37f1-3268-90f9-8bd84daf135c"" -H ""Authorization: Basic UXk3RUZfVEtMbEVLWTlVRFpiWHVscVA4ZVVBYTpKSWN3VTlIX1hGUFdTcW1RQmllZ3lJUzRKazhh"" -H ""Content-Type: application/x-www-form-urlencoded"" https://sts.choreo.dev/oauth2/token{
    ""scope"":""default"",
    ""token_type"":""Bearer"",
    ""expires_in"":3600,
    ""refresh_token"":""7ed6bae2b1d76c041787e8c8e2d6cbf8"",
    ""access_token"":""b7882d23f1f8207f4bc6cf4a20633ab1""
}The above API response grants you a new access token and a refresh token.",https://wso2.com/choreo/docs/consume/manage-application/,505,D206
GraphQL APIs,Test,"Once you deploy your GraphQL API, you can test it using the GraphQL Console. The GraphQL Console is an interactive UI that guides you to write queries and mutations to test the GraphQL API.Choreo uses OAuth2.0 authentication to secure GraphQL APIs by default. Therefore, the GraphQL Console allows you to generate test keys to test the APIs.{.cInlineImage-full}",https://wso2.com/choreo/docs/develop/components/graphql-api/,85,D207
Create Your First Event-triggered Integration,Step 1: Develop - Step 1: Develop,"In this step, you will create an event-triggered integration to it, design the event-triggered integration, and then commit it to the connected GitHub repository to make it available in the Choreo Console.",https://wso2.com/choreo/docs/ipaas/ballerina/create-your-first-event-triggered-integration/,46,D208
Quick Start Guide,Step 1: Create and publish a REST API - Step 1.3: Test the REST API,"Let's test the readingList REST API via Choreo's Open API Console by following the steps given below:Click Test in the left pane, and be sure that you are in the OpenAPI Console view. If not, click OpenAPI Console in the left pane.
Expand the POST method and click Try it out.
Update the request body so that the parameters have the values given below:
Parameter
Value
author
Bram Stoker
status
to_read
title
Dracula
The request body should look as follows:
  {
    ""author"": ""Bram Stoker"",
    ""status"": ""To Read"",
    ""title"": ""Dracula""
  }
Click Execute.
Check the Server Response section. On successful invocation, you will receive the 200 HTTP code.Similarly, you can expand and try out the GET and DELETE methods.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,196,D209
REST APIs,Choreo environments,"Choreo provides a development environment by default and a production environment in two separate Kubernetes clusters. Once you deploy an API to the development environment and verify its functionality, you can promote the API to the production environment.{.cInlineImage-threeQuarter}Once you promote an API to production, Choreo provides a second URL that you can use in a production application to invoke the API.",https://wso2.com/choreo/docs/develop/components/rest-api/,85,D210
View API Insights,Analyzing statistics - Latency,"The Latency page shows information related to the latency of API calls within the API management deployment. You can view a summary of the slowest APIs and then drill down into the API view for further analysis. Use this page as a starting point to debug API slowness.{.cInlineImage-full}The information displayed is as follows:Top 10 Slowest APIs
This widget allows you to identify the slowest APIs of the API management system at a glance. Since these are the APIs that contribute to the higher 95th percentile of the system, improving these APIs lowers the 95th percentile of latency in the API Management deployments.
{.cInlineImage-full}
Latencies By Category
This widget allows you to further drill down details in the above chart. Use the API selector in this widget to select the slow API you identified in the earlier step and then analyze further. Use the charts available in the widget to view the 95th percentile and the median latency over the selected period of the following:
Backend
Request mediation
Response mediation
{.cInlineImage-full}
You can use these charts to further drill down and analyze whether the latency occurs in the backend, request mediation, or response mediation. Also, because you can see both the median and 95th percentile, you can easily identify whether the slowness is occurring in each request or whether it is intermittent.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/view-api-insights/,287,D211
Define Configurable Variables,Define Configurable Variables - part 3,components.,https://wso2.com/choreo/docs/develop/explore-code-editor/define-configurable-variables/,3,D212
Create Your First Webhook,Step 1: Develop - Step 1.1: Create a project and add a Webhook component,"First, let's add a Webhook component as follows:Sign in to the Choreo Console at https://console.choreo.dev.
On the Home page, click + Create Project.
{.cInlineImage-small}
Enter a unique project name and a description. For this tutorial, let's enter the following values:
Field
Value
Name
IssueTracking
Description
Track GitHub issues
Click Create. This takes you to the Components page.
On the Components page, click Create on the Webhook card.
{.cInlineImage-small}
Provide authorization with your GitHub account by clicking  Authorize with GitHub.
If you have not already authorized Choreo apps, click Authorize Choreo Apps when prompted.
Select a GitHub account, a repository that includes a Ballerina project or a Dockerfile, the relevant branch, and Ballerina as the build preset.
Enter a valid path relative to the root of your repository that points to the implementation of the webhook. If you have not designed and implemented your webhook yet, you can connect an empty GitHub repository or a sub-folder and proceed to create the component.
!!! note
If you connect an empty GitHub repository to create the component, you cannot deploy the component. Be sure to implement your webhook before proceeding to the deployment stage.
Click Next.
In the Create a Webhook pane, click on the Webhook type you want to create, for example GitHub.
Click Create.
In the Webhook Name field, enter a unique webhook name (e.g., IssueTracking).
From the Trigger Channel list, select IssuesService so that the system can trigger your webhook based on a change it observes in GitHub issues (i.e., assigning a label in this scenario).
Click Create.
The webhook opens on a separate page.",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-webhook/,394,D213
Choreo Insights API,Objects - API,Represents API details.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,5,D214
Develop Integrations with the Micro Integrator,Environment variables,"You can use environment variables in WSO2 Micro Integrator to improve the configuration management, security, portability, and manageability of the Micro Integrator installation. By using environment variables, organizations can simplify the management and maintenance of their micro installations and ensure that they can be quickly and easily updated when required.The Choreo DevOps Portal allows you to define configurations and secrets to a deployed integration (as well as other component types). For more information, see Configurations and secrets.For a list of parameters that you can configure as environment variables, see WSO2 API Manager Documentation - Injecting Parameters - Supported parameters.",https://wso2.com/choreo/docs/ipaas/micro-integrator/develop-integrations-with-integration-studio/,127,D215
Choreo Insights API,Objects - APILatency,"Latency
Represents latency values for a single API over time.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,14,D216
Construct Statements,Construct Statements - part 1,"The Choreo Web Editor allows you to construct Ballerina statements depending on the use case you want to build. It is an intuitive visual editor that is easy to use even without an in-depth knowledge of the Ballerina Programming Language.It provides the following:Context-based suggestions Ballerina libraries (standard libraries and language libraries) Pre-defined expression templates Documentation for functions and methods to easily configure parametersThis guide walks you through the steps to build the following statement using the editing capabilities in the Choreo Web Editor.string maxValue = ""Max : "" + int0:max(30, -89).toString();The above is a variable statement named maxValue that derives the maximum value in a list of two integers and passes the value in string format (for example, as ""Max : 30"" ).!!! info ""Access the Choreo Web Editor"" If you have not already accessed the Choreo Web Editor, follow these steps: 1. Sign in to the Choreo Console at https://console.choreo.dev. 2. On the Home page, scroll to the Get started with a template section. On the Echo Service template, click Get Started. The REST API created via the template opens on a separate page. 3. Click Edit Code. The Web Editor opens.To build the statement, follow these steps:!!! tip If you want to make changes to the content you have added to the statement that you are creating, you can undo and redo your actions via the relevant icons on the top right of the toolbar. You can also remove content via the icon for deleting.On the low-code diagram, click +. Then click Variable in the Add Constructs pane that opens. !!! info From here onwards, let's use the term Statement Editor to refer to this collection of panes that help you to add and edit statements. {.cInlineImage-full} The Variable pane opens displaying the syntax for a variable statement with <add-expression> selected by default. Click the var type descriptor on the statement and click string on the Suggestions tab. !!! info The Suggestions tab provides contextual suggestions based on the selected item. The Suggestions tab currently lists variable type suggestions because you selected the type descriptor. {.cInlineImage-half} Here, you are specifying that the variable value is a string. To edit the variable name, double-click variable and type maxValue in the text box. !!! info Another way to make a part of a",https://wso2.com/choreo/docs/develop/explore-code-editor/construct-statements/,514,D217
Create Your First Webhook,Step 1: Develop - Step 1.2: Design the webhook,"Designing a webhook involves specifying how the webhook should function by adding and configuring the required connectors and statements. You can do this by editing the low-code diagram of the Webhookor by editing its code.You can implement your webhook in Ballerina or any other language and containerize it. You can use the Ballerina VS code extension to develop the webhook in Ballerina. Learn more.For example, you can use the following source code to design a webhook to read the labels of GitHub issues in a specific repository and generate an email notification for GitHub issues with the bug label. You can add this code in the .bal file in your repository.import ballerina/log;
import wso2/choreo.sendemail;
import ballerinax/trigger.github;
import ballerina/http;
configurable string toEmail = ?;
configurable github:ListenerConfig config = ?;
listener http:Listener httpListener = new (8090);
listener github:Listener webhookListener = new (config, httpListener);
service github:IssuesService on webhookListener {
    remote function onOpened(github:IssuesEvent payload) returns error? {
        //Not Implemented
    }
    remote function onClosed(github:IssuesEvent payload) returns error? {
        //Not Implemented
    }
    remote function onReopened(github:IssuesEvent payload) returns error? {
        //Not Implemented
    }
    remote function onAssigned(github:IssuesEvent payload) returns error? {
        //Not Implemented
    }
    remote function onUnassigned(github:IssuesEvent payload) returns error? {
        //Not Implemented
    }
    remote function onLabeled(github:IssuesEvent payload) returns error? {
        //Not Implemented
        github:Label? label = payload.label;
        if label is github:Label && label.name == ""bug"" {
            sendemail:Client sendemailEp = check new ();
            string sendEmailResponse = check sendemailEp->sendEmail(toEmail, subject = ""Bug reported: "" + payload.issue.title, body = ""A bug has been reported. Please check "" + payload.issue.html_url);
            log:printInfo(""Email sent "" + sendEmailResponse);
        } else {
        }
    }
    remote function onUnlabeled(github:IssuesEvent payload) returns error? {
        //Not Implemented
    }
}",https://wso2.com/choreo/docs/get-started/tutorials/create-your-first-webhook/,691,D218
Quick Start Guide,Step 1: Create and publish a REST API - Step 1.4: Publish the REST API,"Now that your API is tested, let's publish it and make it available for applications to consume.
h4 -> Step 1.4.1: Update the CORS configuration
The application developer in this scenario calls the API from a different domain to Choreo (i.e., Vercel). By default, web browsers block these calls for security reasons. To enable the application to call the API, update the CORS configuration as follows:In the left pane, click Manage.
Click Settings.
Under API Settings click Edit.
Toggle the CORS Configuration switch to enable the CORS configuration.
Select the Access Control Allow Credentials checkbox.
In the Apply to Development pane that opens on the right-hand side of the page, enter a meaningful message. Then click Apply.
Click Save.
h4 -> Step 1.4.2: Publish the REST API
We are now ready to publish the REST API. To do so, follow the steps given below:In the Manage tab, click Lifecycle.
Click Publish to publish the REST API to the Developer Portal. External applications can subscribe to the API via the Developer Portal.
To access the Developer Portal, click Go to DevPortal.
The readingList REST API will open in the Developer Portal.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,270,D219
Create a Policy,Step 2: Implement the policy - Response Flow,"The following is a sample implementation for the response flow:@mediation:ResponseFlow
public function validateResponseHeader(mediation:Context ctx, http:Request req, http:Response res, string headerName, string headerValue) returns http:Response|false|error|() { 
   string|http:HeaderNotFoundError header = res.getHeader(headerName);
   if (header is http:HeaderNotFoundError) {
       string message = string `Header ${headerName} is not found`;
    log:printError(message);
    return ();
   }
   if (header != headerValue) {
    string validationFailedMessage = string `Header validation failed. Expected ${headerValue} but found ${header}`;
    log:printError(validationFailedMessage);
    return ();
   }
   return ();
}",https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,212,D220
Create Your First Event-triggered Integration,Step 1: Develop - Step 1.1: Create an event-triggered integration,"Let's create a new project and add an event-triggered integration to it by following the steps given below:On the Home page of the Choreo Console, click + Create Project. Next, enter a unique name and a description for the project, and click Create.
On the Event-triggered integration card, click Create.
Enter a name and a description for the event-triggered integration. For example, you can enter IssueTracking as the
name and GitHub issue tracking integration as the description.
Click Next.
Provide authorization with your GitHub account by clicking Authorize with GitHub.
If you have not already authorized Choreo apps, click Authorize Choreo Apps when prompted.
If you have not already connected your GitHub repository to Choreo, enter your GitHub credentials, and select the private repository you want to use for this tutorial.
Select values from the GitHub Account, GitHub Repository, and Branch fields as follows:
Field
Value
GitHub Account
Your GitHub account.
GitHub Repository
Select the GitHub repository with the Ballerina project that you created for this tutorial.
Branch
The branch of your GitHub repository that contains the Ballerina project you want to use.
Click Ballerina to select Ballerina as the build preset.
!!! info
The build preset specifies the type of build that Choreo needs to run for the component (for example, Choreo needs to run a micro integrator build for components developed via the WSO2 Integration Studio, a Ballerina build for a component added via a Ballerina project etc.).
In the Path field enter the path to the directory in your GitHub repository that contains the Ballerina.toml file.
!!! info
Choreo identifies a Ballerina project by the Ballerina.toml file. Therefore, when you create an event-triggered integration from a Ballerina project, the GitHub repository you connect needs to have the Ballerina.toml file in its root directory or sub-directory.
Click Next.
Select GitHub as the trigger type, and click Next.
From the Trigger Channel list, select IssuesService so that the system can trigger your event-triggered integration based on a change it observes in GitHub issues (i.e., assigning a label in this scenario).
Click Create.
The event-triggered integration opens on a separate page where you can see its overview.",https://wso2.com/choreo/docs/ipaas/ballerina/create-your-first-event-triggered-integration/,518,D221
View API Insights,Analyzing statistics - Cache,"The Cache page shows statistics that indicate the efficiency with which response caching is carried out for the requests sent to your APIs.{.cInlineImage-full}The page displays the following statistics:Cache Hit Percentage
This graph shows the percentage of requests the system has handled via the response cache over time and the total hits over time. This information allows you to assess how efficiently the backend handles API requests. For example, if the cache hit rate is low, it may indicate that the backend generates the same response each time a specific request is sent instead of returning the response via the cache. In such a scenario, there is scope to improve performance via response caching.
{.cInlineImage-full}
Latency
This section shows the total latency reported during the same time interval applied to the Cache Hit Percentage graph above.
{.cInlineImage-full}",https://wso2.com/choreo/docs/observe-and-analyze/analyze/view-api-insights/,179,D222
GraphQL APIs,Observe,"Choreo allows you to visualize and monitor the performance of GraphQL APIs deployed on Choreo. Choreo has in-built support for viewing the overall status, latencies, throughput data, diagnostic data, and logs. Developers can efficiently detect and troubleshoot anomalies in GraphQL APIs using  Choreo Observability.For more information about the observability capabilities of Choreo, see Observability.",https://wso2.com/choreo/docs/develop/components/graphql-api/,85,D223
REST APIs,API management,"Choreo provides API management capabilities by default for REST APIs (and other APIs) so that you can manage the exposure of APIs to consumers. Choreo API management capabilities also allow you to configure API security settings, set rate limits, associate usage plans, provide other documentation, and perform other related functions to govern the API. The following image shows how you can execute the consumer-facing lifecycle of an API.{.cInlineImage-threeQuarter}The inbuilt Choreo Developer Portal makes it easy for consumers to consume published APIs. Application developers can discover and invoke published APIs via the Choreo Developer Portal. To learn more about the Choreo Developer portal, see Developer Portal).",https://wso2.com/choreo/docs/develop/components/rest-api/,144,D224
Develop Integrations with the Micro Integrator,Connectors,"WSO2 Micro Integrator (MI) Connectors are pre-built connectors that facilitate integration between WSO2 MI and various other systems. They allow you to easily connect to databases, message brokers, REST APIs, etc., to perform actions such as sending messages, executing queries, or retrieving data. These connectors are simple to use. Therefore you can easily integrate them into your WSO2 MI integration flows. You can use Micro Integrator connectors in a wide range of integration scenarios, such as data integration, service-oriented architecture (SOA) integration, and event-driven architecture (EDA) integration.WSO2 Integration Studio is a development environment that allows you to develop integration flows using WSO2 Micro Integrator Connectors. With Integration Studio, you can design and implement integration flows that connect various systems and perform various actions, such as sending messages, executing queries, or retrieving data. You can build integration flows using the pre-built connectors provided by WSO2 MI, or custom connectors that you develop using the Connector Development Toolkit. The Integration Studio provides a graphical user interface that makes it easy to build and test integration flows. It also provides a set of tools to manage and deploy the integration flows in a WSO2 MI runtime environment.For more information, see the following topics in WSO2 API Manager Documentation.Connectors Overview
Adding Connectors",https://wso2.com/choreo/docs/ipaas/micro-integrator/develop-integrations-with-integration-studio/,279,D225
Create a Policy,Step 2: Implement the policy - Fault flow,"Let's not make any changes to the Fault flow in this example. Therefore, you can remove the Fault flow stub from the Policy.bal file.!!! note
The  @mediation:RequestFlow @mediation:ResponseFlow and @mediation:FaultFlow annotations are bound with the keywords in the Ballerina.toml. Therefore, the changes you make to the policy stubs should reflect in the Ballerina.toml file. For example, if the policy is applicable only on the request and response paths, you can remove the  @mediation:FaultFlow annotation from the policy. Then, you MUST remove the choreo-apim-mediation-fault-flow keyword from the generated Ballerina.toml file. If you omit doing so, the Ballerina compiler will show an error at compile time.",https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,176,D226
View API Insights,Analyzing statistics - Devices,"The Devices page displays information about operating systems and HTTP agents that end users use to invoke the APIs. You can use this page to get an idea of the distribution of your user base and improve your APIs to match the audience.{.cInlineImage-full}To filter the information displayed on this page by API, select the required API(s) in the API field. All is selected by default.The information displayed is as follows:Top Platforms
This chart shows the breakdown of the API clients by the operating system. The pie chart only shows platforms with a significant amount of requests. Other platforms are grouped under the Other category.
{.cInlineImage-half}
Top User Agents
This chart shows the breakdown of the API clients by user-agent. The pie chart only shows user agents with a significant amount of requests. Other platforms are grouped under the Other category.
{.cInlineImage-half}",https://wso2.com/choreo/docs/observe-and-analyze/analyze/view-api-insights/,192,D227
Construct Statements,Construct Statements - part 2,"statement editable is to click on the required statement component and press Enter/Return. {.cInlineImage-half} Double click <add-expression> and type ""Max : "" in the text box. !!! info To navigate from one item on the statement to another, you can also press Tab or Shift + Tab. {.cInlineImage-half} Here, you are entering static text as a part of the variable value. Click Expressions, and under the Arithmetic section, click the Es + Ex expression. !!! info The Expressions tab lists all the pre-defined templates that you can use to define complex expressions. {.cInlineImage-half} In the Es + Ex expression template, Es refers to the existing expression you clicked and selected. + Ex combines another expression with Es. Click Libraries and search for max. In the filtered list, click lang.int:max. !!! info The Libraries tab lists all the Ballerina standard and language libraries. {.cInlineImage-half} lang.int:max is a Ballerina standard library for deriving the maximum value. You will see some diagnostics generated for the library you selected. Move on to the next step to resolve them. Click the int0:max(n,ns) function. When you select a function or a method call, the Parameters tab opens by default. This tab displays information about the selected function or method call, including details about parameters, descriptions, and return type descriptions. On this tab, you can easily add parameters to the expression by selecting the checkboxes for the relevant parameters. {.cInlineImage-half} !!! note When a function or a method call requires a particular parameter to work, the Statement Editor selects the appropriate parameter by default and does not allow you to clear it. Change the n and ns parameter values to integers. To make each parameter value editable, you can double-click the corresponding <add_expression> on the variable statement. Let's change them as follows: Parameter Value n 30 ns -89 Select int0:max(30,-89) and click Suggestions. Click toString() in the suggestions list to convert the value that the expression derived to a string format. {.cInlineImage-half} Note that the Statement Editor has cleared all the diagnostics messages, indicating that the statement is valid. You will see the variable statement to be as follows: string maxValue = ""Max : "" + int0:max(30, -89).toString();Congratulations! You have constructed a valid statement via the Statement Editor!You can click Save to add the variable statement to the low-code diagram.",https://wso2.com/choreo/docs/develop/explore-code-editor/construct-statements/,553,D228
REST APIs,Observability,"Choreo allows you to visualize and monitor the performance of REST APIs deployed on Choreo. Choreo has in-built support for viewing the overall status, latencies, throughput data, diagnostic data, and logs. Developers can efficiently detect and troubleshoot anomalies in REST APIs using  Choreo Observability.For more information about the observability capabilities of Choreo, see Observability.",https://wso2.com/choreo/docs/develop/components/rest-api/,83,D229
Quick Start Guide,Step 2: Consume the REST API - Step 2.3: Deploy a Web application and invoke the REST API - Step 2: Consume the REST API - Step 2.3: Deploy a Web application and invoke the REST API,"At present, any user can invoke the readingList REST API via the readingListApp application (i.e., using its token) and update the reading list. However, if a user sends a request to retrieve the reading list, the response will also show entries by other users. To allow multiple users to use the application and maintain personal reading lists, you need a front-end application that allows each user to log in with a unique user ID.In this step, let's deploy a predesigned front-end application. This application is designed to personalize the readingList based on the user ID that it obtains from its identity provider. To enable the application to obtain the user ID, let's configure Asgardeo as the identity provider.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,152,D230
Choreo Insights API,Objects - APIUsage,"Usage
Represents the API usage for a single timestamp. The timestamp is calculated based on the granularity value provided.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,24,D231
Create Your First Event-triggered Integration,Step 1: Develop - Step 1.2: Design the event-triggered implementation,"Designing an event-triggered integration involves adding the required statements and connectors that define how it functions to its implementation.You can do this by editing its code.!!! info
You can implement your Event-Triggered Integration in Ballerina or any other language. If you implement it in a language other than Ballerina, you need to containerize it and then deploy the containerized event-triggered integration. To learn more, see Deploy a Containerized Choreo Component.When you create an event-triggered integration from a Ballerina project, you can design it using the Ballerina VS code extension.In this tutorial, you can use the following source code of an event-triggered integration that reads the labels of GitHub issues in a specific GitHub repository and generates an email notification for GitHub issues with the bug label.import ballerina/log;
import wso2/choreo.sendemail;
import ballerinax/trigger.github;
import ballerina/http;
configurable string toEmail = ?;
configurable github:ListenerConfig config = ?;
listener http:Listener httpListener = new (8090);
listener github:Listener webhookListener = new (config, httpListener);
service github:IssuesService on webhookListener {
    remote function onOpened(github:IssuesEvent payload) returns error? {
        //Not Implemented
    }
    remote function onClosed(github:IssuesEvent payload) returns error? {
        //Not Implemented
    }
    remote function onReopened(github:IssuesEvent payload) returns error? {
        //Not Implemented
    }
    remote function onAssigned(github:IssuesEvent payload) returns error? {
        //Not Implemented
    }
    remote function onUnassigned(github:IssuesEvent payload) returns error? {
        //Not Implemented
    }
    remote function onLabeled(github:IssuesEvent payload) returns error? {
        //Not Implemented
        github:Label? label = payload.label;
        if label is github:Label && label.name == ""bug"" {
            sendemail:Client sendemailEp = check new ();
            string sendEmailResponse = check sendemailEp->sendEmail(toEmail, subject = ""Bug reported: "" + payload.issue.title, body = ""A bug has been reported. Please check "" + payload.issue.html_url);
            log:printInfo(""Email sent "" + sendEmailResponse);
        } else {
        }
    }
    remote function onUnlabeled(github:IssuesEvent payload) returns error? {
        //Not Implemented
    }
}To use it, replace the existing contents in the *.bal file in the Ballerina project that resides in the GitHub repository you connected for this event-triggered integration.",https://wso2.com/choreo/docs/ipaas/ballerina/create-your-first-event-triggered-integration/,763,D232
Choreo Insights API,Objects - APIUsageByApp,"UsageByApp
Represents API usage across APIs by a single application.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,15,D233
REST APIs,Business insights,"Once you take your APIs to production, you need to constantly analyze the APIs to get a good understanding of their usage.",https://wso2.com/choreo/docs/develop/components/rest-api/,24,D234
Quick Start Guide,Step 2: Consume the REST API - Step 2.3: Deploy a Web application and invoke the REST API - Step 2.3.1: Configure Asgardeo to integrate with your application,"To generate the configurations required for end users to log in to the front-end application (for example, the access token, redirect URLs, etc.), let's create an application in Asgardeo by following the steps given below:Access Asgardeo at https://console.asgardeo.io/ and log in with the same credentials with which you logged in to Choreo.
Click Single-Page Application to start adding a single-page application.
Enter a name for the single-page application and enter https://localhost:5173 as the authorized redirect URL.
Click Register.
Click Protocol to open the Protocol tab, and make the following changes:
In the Authorized redirect URLs field, enter http://localhost:5173/. Next, click the Add icon.
Under Access Token, select JWT as the token type.
Scroll down to the ID Token section and enter the following value in the Audience field.
https://sts.choreo.dev/oauth2/token
Click Add URL to save this value.
Click Update.
Click Quick Start, and then click the React icon (because you will be using a preconfigured sample react front-end application).
A separate page opens for your application with Integrate Your Application option selected by default.
!!! info
Under this option, you will see some instructions to configure the application. Some of these steps are already completed for the pre-configured front-end application you will be using.Next, you need to pass the configurations displayed on this page to your front-end application. To do so, proceed to Step 2.3.2 - Configure the front-end application.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,348,D235
Create a Policy,Step 2: Implement the policy - Best practices,"The following are some best practices and additional information you can refer to when implementing your policy:Organize the source within the default module of the package. Do not add any additional modules.
A policy implementation can contain any combination of flows. A generated project contains stubs for all three flows: Request, Response, and Fault. You can remove any stub that you do not require. For example, when you create a policy that re-writes the resource paths, you can remove the Response and fault stubs.
The HTTP request/response objects and the context record that gets passed as parameters to the policy functions are passed as references. Therefore, the changes you make to these values are persisted and are passed through all other policies. The request and the response accumulate all the transformations done to them via the attached policies.
The following return types of the policy functions(flows) is unmodifiable:
http:Response - Returns an HTTP response when you terminate the mediation flow prematurely. For example,  in the in-flow sequence, the mediation sequence terminates before calling the backend. The mediation policy then sends an HTTP response to the client.
false - Returns false if you want to terminate the mediation sequence with a pre-defined response(on the Choreo side).
error - Returns an error if you want to terminate the mediation flow and transfer control to the fault flow. The fault flow would then construct an error response and send it to the client.
() - Returns () to signal the successful completion of the policy. Once the proxy has completed executing the policy, it starts to execute the next policy in the sequence.",https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,331,D236
View API Insights,Analyzing statistics - Alerts,"The Alerts page shows information related to business alerts issued by Choreo for your currently selected environment and organization. You can use this page as a health monitoring dashboard and make it visible to your project team. Using this page you can drill down on each alert and discover possible anomalies in your published APIs. See the topics given below to get details of the available widgets and understand how to use them effectively.{.cInlineImage-full}PrerequisitesTo use this page, be sure to configure alerts and have API invocations that trigger alerts.!!! Note
Alerts are retained only for a week.Alert Summary
This table lists down each alert generated during the selected time interval. The message of the alert can be viewed by expanding the arrow icon on the details column. The drop-downs can be used to filter alerts based on the alert type and API.
{.cInlineImage-full}
Top APIs by Alert Count
This shows a pie chart and a table to visualize the alert distribution during the selected time interval.
{.cInlineImage-full}",https://wso2.com/choreo/docs/observe-and-analyze/analyze/view-api-insights/,221,D237
Create a Policy,Glossary - Glossary,Following are some of the commonly used terms when discussing policies in Choreo:,https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,16,D238
Choreo Insights API,Objects - APIUsageByAppOverTime,"UsageByAppOverTime
Represents API usage across APIs by applications over time.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,17,D239
View API Insights,Analyzing statistics - Reports,"The Reports page allows you to download monthly usage reports for your system. There are preconfigured reports with system-wide statistics, and a custom report generator to generate reports based on a subset of APIs/applications.{.cInlineImage-full}
h4 -> Download custom reports
This widget allows you to generate a custom report for the statistics that have been generated up to now and download it.{.cInlineImage-full}To generate a custom report, follow the steps below:In the API field, select one or more APIs for which you want to generate the report. If required, you can select all the APIs by selecting All.
If you need to further filter the content printed in the report, select one or more applications in the Application field. By default, all the applications that have subscribed to one or more of the selected APIs are selected.
!!! Tip
If you want to filter the report content by the API consumer instead of the application, click on the toggle switch to the right of the Application field, and then select the required consumer. Only consumers who have subscribed to one or more of the selected APIs are displayed in the list. You can either select one, or all of them.
Select the required year and the month in the Year and Month fields to specify the time interval for which you want to generate the report.
Click Download, and select the required format.The report is downloaded in the specified format. The following is a sample report generated in PDF format.{.cInlineImage-half}The contents of the report are as follows.
h4 -> Download pregenerated reports
These widgets allow you to download monthly reports for the last three months.{.cInlineImage-half}To download a pregenerated report, click Download for the relevant month and then click on the required format.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/view-api-insights/,381,D240
Quick Start Guide,Step 2: Consume the REST API - Step 2.3: Deploy a Web application and invoke the REST API - Step 2.3.2: Configure the front-end application,"To configure the front-end application by defining the ports it needs to run on, adding the endpoint to the readingList API, etc., follow the steps given below:Clone version-1 branch in your fork of https://github.com/wso2/choreo-examples/tree/version-1.
Open the cloned repository using an IDE (for example Visual Studio Code), and make the following changes.
Navigate to the choreo-reading-list-application-example/reading-list-front-end/.env.example file and rename it to .env.
Enter values for the parameters in the .env file as given below.
On the page of the application you created in Asgardeo, Configure the AuthProvider section displays some parameters with values. You can copy those values for some of these parameters in the choreo-reading-list-application-example/reading-list-front-end/.env file based on the mapping given in the following table:
.env File Parameter
AuthProvider Parameter
VITE_SIGNIN_REDIRECT_URL
signInRedirectURL
VITE_SIGNOUT_REDIRECT_URL
signOutRedirectURL
VITE_ASG_CLIENT_ID
clientID
VITE_BASE_URL
baseUrl
Enter values for the rest of the parameters as given below:
VITE_RESOURCE_SERVER_URL
On the page for the readingList REST API in the Choreo Console, click Test to open the Test tab.
In the Open API Console pane, copy the API endpoint.
Add /books to the end of the API endpoint you copied to complete the resource server URL.
VITE_CHOREO_CLIENT_ID
Access the Choreo Developer Portal at https://devportal.choreo.dev/.
In the top menu, click Applications and then click the readingListApp application.
In the left navigation menu, click Production Keys.
Copy the value in the Consumer Key field and paste it as the value of the VITE_CHOREO_CLIENT_ID parameter.
VITE_ORG_HANDLE
This is the value displayed next to the Asgardeo logo in the Asgardeo Console.
{.cInlineImage-threeQuarters}
VITE_STS_TOKEN_ENDPOINT
In the Choreo Developer Portal, open the readingListApp application.
Copy the value in the Token Endpoint field and paste it as the value of the VITE_STS_TOKEN_ENDPOINT parameter.Now you have configured your front-end application. Next, you need to configure Asgardeo as the identity provider for your application.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,585,D241
Quick Start Guide,Step 2: Consume the REST API - Step 2.3: Deploy a Web application and invoke the REST API - Step 2.3.3: Configure Asgardeo as an identity provider for Choreo,"Let's deploy a predesigned front-end application. This application is designed to personalize the readingList based on the user ID that it obtains from its identity provider. To enable the application to obtain the user ID, let's configure Asgardeo as the identity provider by following the steps given below:!!! info
To configure an identity provider for Choreo, you need administration privileges in Choreo.In the Choreo Console, open the Home page.
In the left navigation menu, click Settings.
Click API Management and under Identity Providers, click + Add Provider.
In the list of identity providers, click Asgardeo.
In the Asgardeo dialog, enter the following information:
In the Name and Description fields, enter a name and a description for the identity provider.
To get the well-known URL, follow the steps given below:
Navigate to Asgardeo and open the single-page application you created in [Step 2.3.3: Configure Asgardeo as an identity provider for Choreo(#step-23-deploy-a-web-application-and-invoke-the-rest-api).
Click Info to view the endpoints of the application.
Copy the endpoint in the Discovery field.
Navigate to the Choreo Console and paste the URL you copied in the Well-Known URL field in the Asgardeo dialog.
Click Next, and then click Add.Now you have successfully configured Asgardeo as the identity provider for the front-end application.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,323,D242
Choreo Insights API,Objects - APIUsageByApplication,"UsageByApplication
Represents a single API usage by a single application.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,15,D243
Create a Policy,Glossary - mediation:Context,"The mediation context is used to pass parameters between policies. It is created per request and you can access it in any of the flows. For example, if a correlation ID needs to be set to the request, you can set it in the context of the request flow and access it in the response or fault flow. The context has the following functions:# Retrieves the value for the specified key.   
public function get(string name) returns anydata;
# Stores the provided key-value pair. If a mapping exists for the key, the value is overwritten.
public function put(string name, anydata value);
# Removes the entry mapped by the specified key and returns the removed value.
public function remove(string name) returns anydata;
# Retrieves the value for the specified key. If there is no mapping for the key, return the specified
public function getOrDefault(string name, anydata default) returns anydata;
# Checks whether a mapping exists for the specified key.
public function hasKey(string name) returns boolean;
# Returns the `mediation:Context` instance which captured the initial contextual information of the resource,
# before the mediation flow was invoked. Calling this on an original `mediation:Context` object will return itself.
public function originalContext() returns Context;
# The HTTP method of the resource method
public function httpMethod() returns string;
# Retrieves an instance of `mediation:ResourcePath` which is an API for contextual information on the resource path
# of this resource. It also contains methods for modifying the resource path as the user sees fit. This resource
# path is the same path used by the mediation service for deriving the backend endpoint's resource to invoke.
# Therefore, the default behavior of the mediation service is to invoke a resource in the backend endpoint which
# has the same relative resource path as the corresponding mediation service resource.
public function resourcePath() returns ResourcePath;
# Sets the given `mediation:ResourcePath` instance as the resource path of this context.
public function setResourcePath(ResourcePath path);
# Adds a mapping between a path param name and a resolved value for it. There need not be a path parameter in the
# resource path by the name specified in `name` for one to use this method. On its own, the path param values have
# no bearing on the resource path.
public function addPathParamValue(string name, PathParamValue value);
# Returns the collection of resolved values for the path parameters in this particular context, mapped
# by the parameter name.
public function resolvedPathParams() returns map<PathParamValue> & readonly;
# Removes the resolved path parameter value which maps to the specified name.
public function removePathParamValue(string name);
# Adds a query parameter to the request to be sent to the backend. If there is already a query parameter by
# with the same name, the new value will be appended to it, making it an array.
public function addQueryParam(string name, string value);
# Removes the specified query parameter from the request. If the value of the parameter is an array, the whole
# array will be removed.
public function removeQueryParam(string name);
# Retrieves a map of all the query params in the current request context. The returned map is a read only snapshot
# of the map of query parameters in the context at the time this method was called.
public function queryParams() returns map<string[]> & readonly;",https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,761,D244
View API Insights,Analyzing statistics - Geo Map,"The Geo Map page allows you to see a geographical representation of your API usage. You can use this page to make business decisions such as identifying growing regions, analyzing the impact of a region-specific marketing campaign, etc.{.cInlineImage-full}To filter the information displayed on this page by API, select the required API(s) in the API field. The default value is All.This heat map highlights the countries with the appropriate color based on the hit count. It uses a relative color scale to depict the highest hit count to the lowest non-zero hit count.{.cInlineImage-half}
h4 -> Viewing the number of requests by country
You can hold the pointer over the highlighted countries to view the country name and the total number of hits from that location. You can also use the mouse to zoom the map or pan it.{.cInlineImage-half}!!! Note
Currently, this feature is only available for on-premise environments.Optionally you can download geo map data in a tabular format using the PDF or CSV download options by clicking  on the top right corner.!!! Note
The geo-map page utilizes the IP address of the incoming request to derive the geolocation. The actual source IP address can be replaced if there are intermediate hosts between the client and the gateway node. Therefore, the reverse proxy or the load balancer fronting the gateway node must add the x-forwarded-for header to each request to preserve the source IP address. If you do not configure this correctly, the Geo Map page will not show any data. To test this, you can manually add an x-forwarded-for header to the request.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/view-api-insights/,351,D245
Quick Start Guide,Step 2: Consume the REST API - Step 2.3: Deploy a Web application and invoke the REST API - Step 2.3.4: Create a user in Asgardeo,"To sign in to the readingListApp application and create private reading lists, the end users require user IDs. The end users can self-register these user IDs in Asgardeo or request an Asgardeo user with administration privileges to add them. For more information, see Asgardeo Documentation - Manage users.For this use case, you will play the role of an Asgardeo user with administration privileges who registers the user IDs.To define a user for the readingListApp application, follow the steps given below:Navigate to the Asgardeo Console.
On the Home page, click View users to open the Users page.
Click Add User.
In the Add User dialog, enter your email, first name, and last name, and click Finish.
Asgardeo will send you an email to set your password.  It will also open your user profile on a separate page.
In your user profile, toggle the Lock User switch to unlock your profile.
In the email you received from Asgardeo (with the subject Here is your new account in the organization <ORGANIZATION_ID>), click Set Password.
Enter a password that matches the given criteria in the Enter new password and Confirm password fields, and click Proceed.!!! tip
You can create more users to test your front-end application.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,276,D246
Choreo Insights API,Objects - APIUsageByBackend,"UsageByBackend
Represents API usage across APIs by a single backend.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,16,D247
Create a Policy,Glossary - Keywords,"The Ballerina.toml file needs to include the following keywords for the mediation policies to work:choreo-apim-mediation-policy: This keyword is a mandatory keyword that is required to identify that the package is a mediation policy type.
choreo-apim-mediation-request-flow: Specifies whether the policy applies to the request flow.
choreo-apim-mediation-response-flow: Specifies whether the policy applies to the response flow.
choreo-apim-mediation-fault-flow: Specifies whether the policy is applicable for the fault flow.",https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,133,D248
Quick Start Guide,Step 2: Consume the REST API - Step 2.3: Deploy a Web application and invoke the REST API - Step 2.3.5: Invoke the REST API,"To run the front-end application and send requests to the readingList REST API via it, follow the steps given below:!!! info
To render the front-end application as a web application, you will be using the Node Package Manager software.In the terminal, navigate to the choreo-reading-list-application-example/reading-list-front-end directory in the clone of your GitHub repository.
Issue the following commands in the given order:
npm i
This command installs the latest Node Package Manager version in the local directory where the front-end application resides.
npm run dev
This command runs the front-end application as a web application.
The front-end application will start running at http://localhost:5173/ as logged in the terminal.
Access the front-end application via http://localhost:5173/.
Click Login, and sign in with the credentials of a user that you have created in Asgardeo.
To allow your application to access your Choreo account, select the User Account checkbox and click Allow.
The application opens as follows.
{.cInlineImage-half}
Add three new reading items with different statuses.
For example, the details can be as follows:
Title
Author
Status
The Museum of Innocence
Orhan Pamuk
reading
The Remains of the Day
Kazuo Ishiguro
to_read
David Copperfield
Charles Dickens
read
To add each record, follow the steps given below:
Click + Add New.
Enter values for the Name, Author, and Status fields.
Click Save.
Three tabs will appear for each status. To delete a reading list item, you can click Delete for it.To verify whether the reading list is personalized for each user, you can log in as a different user. The reading list items you entered above will not appear for the other user.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,402,D249
Choreo Insights API,Objects - APIUsageByBackendOverTime,"UsageByBackendOverTime
Represents API usage across APIs by each backend over time.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,19,D250
Create a Policy,Glossary - Policy name and description,"The Package.md file contains information about the policy. Choreo uses this information to render the policy configuring UI. This file is written in Markdown format and should be structured as follows.Format:# <policy-name>
## Overview
<policy description>Example:# ValidateHeader
## Overview
This policy validates the request and response headers with the configured values.",https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,78,D251
Choreo Insights API,Objects - APIUsageOverTime,"UsageOverTime
Represents a single API usage over time.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,13,D252
Quick Start Guide,Step 2: Consume the REST API - Step 2: Consume the REST API,"You have published the readingList REST API to the Developer Portal where application developers can find it and subscribe their applications to it.In the previous steps, you played the role of a REST API developer and developed a REST API. In this step, you will play the role of the web application developer who will consume this REST API.To consume the readingList REST API, let's create an application, subscribe it to the REST API, generate keys, and invoke the API.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,95,D253
Create a Policy,Glossary - Policy versioning,"Choreo or mediation dependencies bump their major version when switching to a major update in the language (For example, from update 1 to update 2). There can be significant incompatibilities in these major versions. Therefore, we recommended versioning the policy package in a manner that the major version gets bumped when upgrading the Choreo/mediation dependency version to a major version.",https://wso2.com/choreo/docs/develop/api-policies/create-a-policy/,76,D254
Quick Start Guide,Step 2: Consume the REST API - Step 2.1: Create an application,"An application in the Developer Portal is a logical representation of a physical application such as a mobile app, web app, device, etc.Let's create the application to consume the readingList REST API by following the steps given below:In the top menu of the Developer Portal, click Applications.
Click Create.
Enter a name for the application (for example, readingListApp and click Create.
Your Application will open on a separate page.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,90,D255
Choreo Insights API,Objects - AlertSummaries,Represents alert summaries.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,6,D256
Quick Start Guide,Step 2: Consume the REST API - Step 2.2: Subscribe to the API,"To consume the REST API, the readingListApp application needs to subscribe to it. To subscribe your application to the API, follow the steps given below:In the left navigation menu, click Subscriptions.
Click Add APIs.
Find your REST API and click Add.Now your application has subscribed to the readingList REST API.",https://wso2.com/choreo/docs/get-started/quick-start-guide/,68,D257
Choreo Insights API,Objects - AlertSummary,Represents a summary for an alert.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,8,D258
Choreo Insights API,Objects - Application,Represents application details.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,5,D259
Choreo Insights API,Objects - CacheHit,"Represents the response cache hits and misses for a single timestamp. The timestamp is calculated based on the
granularity value provided.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,26,D260
Choreo Insights API,Objects - CacheHits,"s
Represents the response cache hits and misses over time.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,13,D261
Choreo Insights API,Objects - CustomReportGroupBy,Represents the usage data overtime for the selected parameters of a specific groupByValue.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,17,D262
Choreo Insights API,Objects - CustomReportOvertime,Represents usage data overtime for the selected parameters.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,10,D263
Choreo Insights API,Objects - CustomReportTopOvertime,Represents usage data overtime for the selected parameters grouped by the top N groupByValues.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,18,D264
Choreo Insights API,Objects - CustomReportUsage,Represents usage data for a single timestamp in CustomReports.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,12,D265
Choreo Insights API,Objects - DetailsOfErrors,Represents error details over time.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,7,D266
Choreo Insights API,Objects - Environment,Represents an environment.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,5,D267
Choreo Insights API,Objects - ErrorCountByCategory,"Represents the number of errors from each category for a single timestamp. The timestamp is calculated according to the
provided granularity value. If you select some categories, the error counts are retrieved only for those categories,
and a null value is shown for the other categories that are not selected.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,59,D268
Choreo Insights API,Objects - ErrorCountByCode,Represents the error count for a single error status code.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,12,D269
Choreo Insights API,Objects - ErrorCountByCodeForAPI,"ForAPI
Represents the error count for each status code for a single API.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,17,D270
Choreo Insights API,Objects - ErrorDetails,"Represents details of an error for a single timestamp. The timestamp is calculated according to the granularity value
provided.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,24,D271
Choreo Insights API,Objects - ErrorStatusCodeCategoryCounts,Represents errors by the main status code (4xx or 5xx) and the total error count.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,21,D272
Choreo Insights API,Objects - ErrorSummary,"Provides the unsuccessful usage (i.e., 4xx and 5xx response codes) summary across all APIs.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,23,D273
Choreo Insights API,Objects - ErrorValue,"Represents the unsuccessful request count (i.e., 4xx and 5xx response codes) for a single timestamp. The timestamp
is calculated based on the granularity value provided.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,37,D274
Choreo Insights API,Objects - ErrorsByCategory,Represents the errors by category over time.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,9,D275
Choreo Insights API,Objects - ErrorsByStatusCode,Represents the error counts grouped by status code for each API.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,13,D276
Choreo Insights API,Objects - ErrorsByStatusCodeCategory,"Category
Represents the error category values (grouped as 4xx, 5xx, and total) for both proxy and target errors for a
single timestamp. The timestamp is calculated based on the granularity value provided.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,45,D277
Choreo Insights API,Objects - Latency,"Represents latency values for each latency category for a single timestamp. The timestamp is calculated based on the
granularity value provided.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,26,D278
Choreo Insights API,Objects - LatencySummary,"Summary
Provides the latency summary.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,8,D279
Choreo Insights API,Objects - LatencyValue,"Value
Represents the latency value for a single timestamp. The timestamp is calculated according to the provided granularity
value.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,25,D280
Choreo Insights API,Objects - Organization,Represents an organization.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,5,D281
Choreo Insights API,Objects - OverallLatency,Represents the overall latency values.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,7,D282
Choreo Insights API,Objects - Pagination,Represents pagination details.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,6,D283
Choreo Insights API,Objects - Platform,Represents a platform.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,5,D284
Choreo Insights API,Objects - Provider,Represents API Provider details.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,6,D285
Choreo Insights API,Objects - ResourceUsage,Represents the usage of a single API resource.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,10,D286
Choreo Insights API,Objects - ResourceUsages,"s
Represents API resource usages.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,9,D287
Choreo Insights API,Objects - SlowAPI,A slow API identified based on the response latency (95th percentile).,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,14,D288
Choreo Insights API,Objects - Subscriber,Represents API Subscriber details.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,8,D289
Choreo Insights API,Objects - SuccessAPIUsageByApplication,Represents successful usages(that have resulted in the 2xx response code) of an API by an application.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,23,D290
Choreo Insights API,Objects - SuccessSummary,Provides the successful (2xx response code) usage summary across all the APIs.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,17,D291
Choreo Insights API,Objects - SuccessValue,"Represents the successful request count (i.e., requests that have received the 2xx response code) for a single
timestamp. The timestamp is calculated according to the granularity value provided.",https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,40,D292
Choreo Insights API,Objects - TopAPIByAlertCount,Represents a top API by alert count.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,9,D293
Choreo Insights API,Objects - TopAPIsByAlertCount,Represents the top APIs by alert count.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,9,D294
Choreo Insights API,Objects - TotalError,Represents the total errors.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,6,D295
Choreo Insights API,Objects - UsageByGeoLocation,Represents the usage of a single API in a single country.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,13,D296
Choreo Insights API,Objects - UserAgent,Represents a user agent.,https://wso2.com/choreo/docs/observe-and-analyze/analyze/choreo-insights-api/,6,D297
Observing Choreo Private Data Planes With New Relic,Observing Choreo Private Data Planes With New Relic,"
Nilushan Costa 
|
2 Feb, 2023Disclaimer: The New Relic logo and trademark is owned by New Relic Inc and its respective content owners. New Relic is not affiliated with, nor has it endorsed or sponsored Choreo and no such endorsement or affiliation is implied. The New Relic logo has been used without the permission of the copyright holders under Section 107 of the United States Copyright Act, for the purpose of Fair Use, in describing the interoperability of the services.
In the modern world, digital transformation has become vital for enterprises. A digitally transformed enterprise may use numerous computing resources to run various applications for its business needs.
Once computing resources and applications have been put to use in production environments, they must be observed. This helps enterprises understand how the resources/applications are performing, realize if they are being used cost-effectively, and investigate what went wrong when things don’t go as planned.
The ability for users to observe their components is also vital in Choreo. Customers using Choreo’s cloud data plane or private data planes can benefit from its built-in observability view. This view can be used to understand resource usage, view CPU flame graphs, analyze logs, monitor application performance, and even observe individual requests related to components.
However, some private data plane customers may prefer to use third-party observability platforms they’re already familiar with or ones commonly used within the enterprise.
As the first step towards addressing such requirements, Choreo now allows you to observe private data planes with New Relic.
Figure 1: High-level architecture
This can be done at several levels. Infrastructure level monitoring allows you to assess the cluster that runs the private data plane. Monitoring the performance of individual components is crucial, and is possible with Pixie, which is built into New Relic. Pixie allows you to observe Choreo components in terms of metrics such as throughput, response time, error rate, and much more. Furthermore, logs of Choreo components would also help you gain insights into what’s occurring within components. All these observability capabilities of New Relic will help you maintain healthy Choreo components in your private data plane. This is illustrated by Figures 2 and 3.
Figure 2: Infrastructure observability
Figure 3: Application observability
Although New Relic is the first external observability platform to be supported by Choreo’s private data planes, it’s far from the last. Choreo will continue adding to its observability platforms list, so stay tuned for future announcements.

h2 -> Get Started
Setting up New Relic observability for your private data plane requires the help and support of the WSO2 team. Once you request this capability, WSO2 will set up the New Relic agent in the private data plane cluster. Observability data will then be published directly from the private data plane cluster to New Relic. To get started, please contact your WSO2 Account Manager or contact us here.

h2 -> Conclusion
Observing the private data plane and the components running in it is essential to ensure a healthy deployment. It’s now possible for you to use New Relic to observe Choreo private data planes. To learn more about Choreo, check the official Choreo documentation, including our Quick Start Guide.

h4 -> Follow us
",https://wso2.com/blogs/thesource/observing-choreo-private-data-planes-with-new-relic,696,B0
Build and Deploy Your Dockerfile in Choreo,Build and Deploy Your Dockerfile in Choreo,"
Nilesh Jayanandana 
|
20 Oct, 2022We’re happy to announce support for building and running your Dockerfiles in Choreo. This lets you deploy and run containerized microservices written in any language and leverage the operational benefits of Choreo.

h3 -> Why did we build Dockerfile support for Choreo?
Polyglot microservices, also known as multi-language microservices, are a type of microservice architecture (MSA) where developers use multiple programming languages and technologies for each microservice. Many cloud native applications are polyglot in nature as it allows developers to select the programming language that best suits their specific needs.
For example, think about building an e-commerce shopping application. You may have chosen Python to write the machine learning algorithms that generate predictions, NodeJS and MongoDB to create the inventory management system, and Go to create a few APIs. You may wish to reuse a few Java services that your team has written prior to this application, and also use Ballerina to create integrations and new APIs. All these polyglot services must communicate via an HTTP interface using REST, GRPC, and GraphQL to fulfill the business needs of your shopping application.
Containers have become the de facto standard for constructing microservices and their operation. Containers enable you to run your application and library code as a single unit, regardless of the environment you're working in. This simplifies the process of running and scaling your microservices, allowing you to focus on other aspects of your business.
With this release, you can now easily build, run, scale, and manage all your microservices, regardless of the programming language they’re written in, expose them as APIs and connect them together with API management capabilities in Choreo. The digital platform as a service now provides the same features for microservices written in any language that contains a Dockerfile like CI/CD pipelines, API management, deep observability, configuration management, environment promotions, DevOps, and more.
To learn more about how to run your Docker containers in Choreo, follow this tutorial.

h3 -> Conclusion
Modern applications are written with polyglot services to fulfill crucial business functions. All these services must be constructed, operated, and managed uniformly. With support for building and running Docker containers in Choreo, organizations can now develop the applications required for mission-critical business functions in their language of choice while retaining Choreo's key CI/CD, observability, scaling, API management, and DevOps capabilities.
This feature is now available to be used with REST API, Manual Trigger and Scheduled Task component types in Choreo. Find out more when you sign up to Choreo for free, today!

h4 -> Follow us
",https://wso2.com/blogs/thesource/build-and-deploy-your-dockerfile-in-choreo,581,B1
Introducing Observability for Polyglot Applications,Introducing Observability for Polyglot Applications,"
Nilushan Costa 
|
7 Feb, 2023Photo by Philippe Bout on Unsplash

h2 -> Introduction
With the recently introduced Build and Deploy Your Dockerfile feature, users can now create awesome digital experiences quickly, easily, and securely using any programming language they prefer. Once they develop their application and containerize it, Choreo will take care of the rest by building and deploying it to Kubernetes in minutes.
Irrespective of the language used to write applications, the ability to observe them is vital. While it’s possible to instrument applications and add observability capabilities, this takes time and requires domain expertise. With Choreo, users don’t need to set up language-specific agents or expose metrics using additional libraries, and they can leverage the platform’s observability capabilities without hassle.
Until now, Choreo provided observability only for components written using Ballerina. We’re happy to announce that it now provides the ability to observe components written in any language.

h2 -> Observing Polyglot Components
To view the information that is available for observing polyglot components, you first need to create a component with the Dockerfile build present and deploy it in Choreo. Refer to Figures 1 and 2 to see how this can be done.
Figure 1: Menu to create a REST API
Figure 2: Deploy view
After you send requests to the component, Choreo will show you observability data. You’ll be able to use several metrics to observe the component as shown in Figure 3. The throughput graph shows the processing rate of requests, while the latency graph shows the mean latency as well as 50th, 90th, and the 99th latency percentiles.
Figure 3: Choreo observability view: application performance and logs
The diagnostics view (as shown in Figure 4) makes it possible to correlate all metrics: error rate, throughput, latency, CPU usage, and memory usage. This correlation is useful for debugging issues in components. For example, a very high CPU usage could be the reason why the component is having a high request latency.
Figure 4: Diagnostic view of Choreo observability
In addition, Choreo also shows you logs from your containers as shown in Figure 5.
Figure 5: Logs view in Choreo observability

h2 -> How Does Choreo Do That?
Since Choreo doesn’t restrict the programming languages you can use, it would mean the platform would have to instrument a variety of them. This would have been complex. To solve this problem, Choreo uses extended Berkeley Packet Filter (eBPF) [1] to collect data about how your components are performing. eBPF makes it possible to run sandboxed programs at the Linux Kernel level without having to modify the Kernel or load additional Kernel modules. This makes it possible to use eBPF for many interesting use-cases like observability. It is this eBPF-based data collection capability that allows Choreo to gather observability data without language specific instrumentation.
Choreo uses Pixie to collect data on non-Ballerina components. Pixie is an open-source Kubernetes observability platform that uses eBPF along with other machine-level metrics to provide observability.
Choreo uses these metrics along with logs to provide a feature-rich observability view that users can use to gain valuable insights about how their components are running in Choreo.

h2 -> What’s Next?
In Choreo, when you work with components, you can use the component-level observability view as explained above to gain insights about a single component. A Choreo project is typically made up of several related components. Therefore, it is equally important to observe how different components interact. To make this possible, we will soon unveil new features to make project-level observability possible.

h2 -> Conclusion
In addition to providing deep observability for Ballerina components, we’ve expanded Choreo’s observability capabilities to non-Ballerina components as well. Developers now have the freedom to create components using their language of choice while being able to observe them without having to do any manual instrumentation.
Visit Choreo to sign up for an account and see how you can create awesome digital experiences quickly, easily, and securely.

h2 -> References
[1] - https://ebpf.io/

h4 -> Follow us
",https://wso2.com/choreo/blog/introducing-observability-for-polyglot-applications,952,B2
Introducing the Choreo API Sandbox,Introducing the Choreo API Sandbox,"Ruwini Wijesiri 
|
15 Feb, 2023",https://wso2.com/choreo/blog/introducing-the-choreo-api-sandbox,16,B3
Introducing the Choreo API Sandbox,Introduction,"APIs are the core of any application. Consequently, it’s important to test how well the application works with these APIs. With the introduction of API sandbox support, Choreo provides developers a safe zone to test their applications.",https://wso2.com/choreo/blog/introducing-the-choreo-api-sandbox,48,B4
Introducing the Choreo API Sandbox,What is an API Sandbox?,"Let’s look at a real-world example to get a better understanding of this concept.
Assume there is a payment API, and you need to develop an application to handle online payments. If you were to use the payment API during application development, you would be working with real money, and any failures during development would lead to monetary losses. It would also be difficult to reproduce edge case scenarios such as having insufficient funds for payment or transaction failures to assess how the application would behave in such scenarios. Wouldn’t it be great to do all this without using real money?
That’s where the API sandbox comes into play. This mirrors the production environment, and has the same functionality as the actual production environment. However, an API sandbox only works with synthetic data, whereas the production environment works with real data. Therefore, an API sandbox provides developers an environment to test their application by simulating the production environment and enabling them to test and evaluate how the application will perform in production use cases.
Now, let’s see how we can create and use an API sandbox in Choreo.",https://wso2.com/choreo/blog/introducing-the-choreo-api-sandbox,227,B5
Introducing the Choreo API Sandbox,How Can We Use an API Sandbox?,"Choreo supports using an API sandbox for three types of components: REST APIs, GraphQL APIs, and API proxies. Each deployment environment in Choreo has its own corresponding sandbox.
When deploying an API to an environment, developers can provide a sandbox endpoint. If an endpoint is configured, Choreo will generate two API URLs. One will be the primary API URL corresponding to the primary endpoint, and the other will be the sandbox API URL corresponding to the sandbox endpoint. This is illustrated in Figure 1 below.
Figure 1: Production and sandbox endpoints

h3 -> How to create an API Sandbox for a REST API
1. Open the Choreo Console and create a sample REST API named ‘Payments’.
2. Go to the Deploy page.
3. Click on Configure & Deploy in the build area. Configure a Sandbox endpoint and deploy it. Choreo will provision two endpoints for the API on the Dev environment. If you go to the Test page, you will see two URLs instead of one.
4. When promoting the build to Production, developers can provide a sandbox endpoint for the production environment. Choreo will provision two URLs, just like in step 3.
Figure 2: Configure sandbox endpoint
5. Go to the Lifecycle tab on the Manage page and publish the API to make it available to consumers.
API sandboxes can be used for GraphQL and API proxies as well.

h3 -> Test the API Sandbox
API developers must ensure the sandbox is working as expected and mirrors the production environment as closely as possible. To do this, API developers can test the sandbox API from the Choreo Console by following these steps.
Open the Choreo Console and open the API sandbox component.
Go to the Test page. The endpoint selector will list both primary and sandbox URLs for environments with a configured sandbox endpoint.
Select the endpoint you want to test and invoke the API.Figure 3: Test API sandbox

h3 -> Consuming the API Sandbox
Developers can discover APIs through the Choreo Developer Portal. When a sandbox is configured for an API, they will see two API URLs labeled as production and sandbox respectively. Application developers can use the sandbox during application development. Once it’s tested and evaluated in a development environment, the application can be promoted to production. When deploying it to production developers must change the API endpoint to the production URL of the API using these steps.
Open the Choreo Devportal.
Create an application and subscribe to the APISandbox API. Generate an access token.
Open the APISandbox API.
Go to the ‘Try Out’ page. The endpoint selector will list both production and sandbox URLs for environments with a configured sandbox endpoint.
Select the endpoint you want to test and invoke the API.Figure 4: Consume API sandbox",https://wso2.com/choreo/blog/introducing-the-choreo-api-sandbox,603,B6
Introducing the Choreo API Sandbox,Conclusion,"An API sandbox provides a pseudo-production environment where applications can be tested. It helps build confidence in the application’s real-world performance and therefore is essential for the application development process. Sign up to Choreo for free and try out its new API sandbox feature today!

h4 -> Follow us",https://wso2.com/choreo/blog/introducing-the-choreo-api-sandbox,64,B7
Manage Your Microservices with Choreo’s DevOps Portal,Manage Your Microservices with Choreo’s DevOps Portal,"
Nilesh Jayanandana 
|
20 Oct, 2022We’re thrilled to announce the release of the Choreo DevOps Portal to give users more control over managing the DevOps aspects of their microservices.
When you run microservices, sometimes the default configurations won’t meet your business goals and you will require more flexibility and control over how your services are run and managed. How you write your microservices will determine a variety of factors, including resource requirements like the minimum amount of CPU and memory, health checks, configuration management, and the ability to inject environment variables and mount configuration files. In Choreo, many of these factors are standardized for services that are written in the Ballerina programming language.
However, you might have, for example, a Java service that needs additional CPU and memory to run normally, some configurations to be mounted as files on runtime, and custom health check endpoints. Now, with the ability to build and run your Docker containers on Choreo, you don't have to worry about those things. The DevOps Portal lets you fine-tune the configurations of your microservices and ensure they operate at peak efficiency.
Choreo’s DevOps Portal enables you to:
Observe the state of the containers of your microservices in real-time.
Modify CPU and memory allocated for your microservice.
Mount configuration files to your containers at runtime.
Inject environment variables to your containers at runtime.
Add health checks to your application.
Configure scaling thresholds of your microservice.Figure 1 - DevOps Portal Overview page

h2 -> What’s Next?
The Choreo DevOps Portal is only the beginning for managing microservices in production. We are currently developing several exciting features that will give users like yourself greater flexibility and control over your microservices. Until then, sign up for free to find out more about Choreo.

h4 -> Follow us
",https://wso2.com/blogs/thesource/manage-your-microservices-with-choreo-devops-portal,409,B8
Introducing Choreo's Visual Data Mapper,Introducing Choreo's Visual Data Mapper,"Kavith Thiranga Lokuhewage 
|
28 Nov, 2022We are pleased to announce that we have introduced a Visual Data Mapper for Choreo. You can use it to convert data between input type(s) and an output type.
Data mapping lets you translate data from one form to another, such as from one JSON format to another. The data mapping process is crucial to enterprises as it’s needed for the following areas:
Data integration: This involves moving data from multiple sources to a centralized location (done at regular intervals) while removing redundant data fields and duplicate entries. The goal is to create a comprehensive data set that can be shared with users across the organization.
Data migration: This process is where we move data from one location to another as a one-time task with the goal of retiring the existing storage system and using the new location permanently after migration. For example, this occurs when an organization moves from an on-premise storage to a cloud provider.
Data transformation: This involves translating data from one format to another while cleansing, restructuring the data, and performing transformations such as aggregation, enrichment, etc. This is usually done to enable communication between different systems that expect different forms of the same data or to collect data in an appropriate format for analysis.
There are many types of visual data mapping tools available, and they often use template or configuration files to persist the logic. These files are fed into a template engine that handles the transformations. However, when it comes to complex conversions, users need to write custom functions and refer to them inside the template file. These files can be very complex and aren’t meant to be edited manually. Furthermore, custom functions may also need to be written as well.
On the other hand, any programming language can be used to implement a data mapper as a function. It can then be shared as a library or exposed as a web service. Programming languages offer more flexibility compared to template files, but they usually lack visual tools that help users with conversions without needing to touch the code. Choreo’s Visual Data Mapper offers the flexibility of a programming language plus the user friendliness of a visual tool.",https://wso2.com/blogs/thesource/introducing-choreo-visual-data-mapper,450,B9
Introducing Choreo's Visual Data Mapper,Visual Data Mapping is More Powerful Than Writing Code,"Visual data mapping enables you to map via an intuitive user interface and prevents the need to be aware of the programming logic underneath. In Choreo, the Visual Data Mapper can generate a Ballerina source code as you map via the user interface or vice versa. It allows developers to focus only on the business logic and hides the complexity of the programming language. This makes the data mapping process faster and less error prone.
The Ballerina source code is the single source of truth for the Visual Data Mapper. Hence, it lets you open and edit existing data mappings made via the source code without changing the user experience. This is shown in Figure 1 below.
Figure 1: Split View of Code and Diagram
Furthermore, it provides a powerful expression editor, which you can use to generate the required Ballerina expressions to map data with conditional values, execute type conversions, string manipulations, date-time parsing, and much more.
As shown by Figure 2, the Ballerina expression editor also lets you discover and call built-in Ballerina utility functions available to process values. Depending on the context, it can suggest any applicable fixes, expression templates, inputs, operators, and functions available.
Figure 2: Visual Expression Editor",https://wso2.com/blogs/thesource/introducing-choreo-visual-data-mapper,255,B10
Introducing Choreo's Visual Data Mapper,Data Mapping is Everywhere,"When you develop services or applications, it's common to talk to different internal and external systems or services. These systems expect or produce data in various forms and data mapping is required when you need to pass external data to these systems or when you need to expose the data from them to external parties.
While there may be several use cases, let’s focus on the given examples below.
Integrating different servicesWhen you are performing an integration between two different services, you must convert the response from one service to a different form, so the second service can be called with it.
For example, you may wish to review potential new leads from Salesforce and append them as rows to Google Sheets. Data mapping helps to convert the collection of Salesforce leads to a two dimensional string array which is the expected data format in the append rows API of Google Sheets.
Aggregating or segregatingOccasionally, you may need to create a new service which serves aggregated data from many other services. You may need to collect all the data from some services and parts from others. In this case, data mapping is needed to create the final output from several different inputs, by taking data from some as a whole and only a few selected fields of data from others.
Transforming the persistence layerLet’s say you want to develop a Create, Read, Update, and Delete (CRUD) service and you are using a relational database for persistence. The normalized database expects data to be in a non-redundant format to keep its integrity, but for the clients of the service, usually you need to serve or accept data in a different format for the best user experience. You will need data mapping to do these conversions for relational databases and every other persistence system.",https://wso2.com/blogs/thesource/introducing-choreo-visual-data-mapper,360,B11
Introducing Choreo's Visual Data Mapper,When Should you use Data Mapping in Choreo?,"Here are popular situations where you can use Choreo’s Visual Data Mapper.
Using connectorsIn Choreo, you can use connectors to communicate with external or internal services in your organization. These connectors define the request and response types for each of the APIs available.
When you create an integration using these connectors, once you have added the relevant connector actions, you can create a data mapper to convert the response from one connector action to a request to another.
Using webhooksYou can use built-in webhooks in Choreo to listen to events from popular cloud services. Like connectors, these webhooks already have defined data types of each event they can listen to. Once you configure a webhook within the event handler, you can access the event payload and use a data mapper to convert that into an expected format and call another service, using the built-in connector, with that data.
Creating servicesDevelopers can create REST or GraphQL services in Choreo. When creating these services, you can use the record editor to create data types to describe input and output payloads. Once you implement each resource, you can use data mapping to convert request payloads to process the inputs or prepare response payloads from other available data sources.",https://wso2.com/blogs/thesource/introducing-choreo-visual-data-mapper,261,B12
Introducing Choreo's Visual Data Mapper,Data Mappings Supported in Choreo’s Visual Data Mapper,"There are various types of conversions you can do, but they can all be categorized into three common categories.

h3 -> 1. One-to-one mappings
A source field can be directly mapped to a target field. If the data types of the source and target mismatch, use the expression editor to convert the input value to the expected type.
For example, as shown in Figure 3 below, an integer field from input is mapped to a string field in the output with the help of expression editor suggestions.
Figure 3: One-to-One Mapping

h3 -> 2. Many-to-one mappings
In this type of mapping, several input fields can be used to generate the value of an output field. The inputs can be combined using various operators available. For example, we can combine, or concatenate two string input fields to produce the output string as seen in Figure 4.
Figure 4: Many-to-One Mapping

h3 -> 3. Collection-to-collection mappings
This supports mapping between arrays and other collection types. Collection-to-collection mappings can be treated as a one-to-one mapping as well. However, the target collection often needs members to be in a different form than in the source collection. The Visual Data Mapper lets you easily achieve this as shown in Figure 5.
Figure 5: Collection-to-Collection Mapping",https://wso2.com/blogs/thesource/introducing-choreo-visual-data-mapper,293,B13
Introducing Choreo's Visual Data Mapper,Getting Started,"Open the Ballerina package for your component using Visual Studio Code. Make sure you have installed the Ballerina Extension (Ballerina - Visual Studio Marketplace) beforehand.
Go to the low-code editor, click the plus icon in the canvas and select “Data Mapper”.
Figure 6: Opening Visual Data Mapper
As seen in Figure 7, give a name for the data mapper and select input and output types. You can create these from scratch using samples or re-use existing types from the connector or webhook package.
Figure 7: Configuring Visual Data Mapper
Please follow the Data Mapper guide for detailed information.
Find out more today by signing up to Choreo for free!

h4 -> Follow us",https://wso2.com/blogs/thesource/introducing-choreo-visual-data-mapper,158,B14
Choreo iPaaS: The Integration Platform-as-a-Service for Developers,Choreo iPaaS: The Integration Platform-as-a-Service for Developers,"Asanka Abeyweera 
|
22 Feb, 2023Businesses today rely on a wide range of systems and applications to run their day-to-day operations, such as enterprise resource planning (ERP), customer relationship management (CRM), and human resources management (HRM) systems. These systems often store and process critical business data like customer information, financial transactions, and inventory levels. However, managing and integrating these different systems and applications can be complex and time-consuming because:
Data may be stored in multiple systems, making it difficult to access, analyze, and utilize effectively.
Various systems may have different data structures and formats, making integration even more challenging. 
Businesses often have different workflows, processes, and teams that need to access and use data stored in these systems, which can lead to delays, errors, and lost time.To address these challenges, we’re thrilled to announce the launch of Choreo iPaaS, an innovative solution that enables developers to easily and quickly integrate on-premise and cloud-based systems and applications. You can choose the development tools that work best for you and manage all your integrations within one platform. It doesn’t matter whether you use the Ballerina language, a low-code editor like WSO2 Integration Studio, or any other programming language.
Choreo iPaaS also offers a robust set of management and monitoring tools that provide visibility into the health and performance of your integrations. It is a true multi-cloud integration solution, supporting seamless integration between cloud and on-premises systems, as well as between multiple clouds. This means you can connect and manage your data and systems with ease, no matter where they reside. With its enterprise-grade full lifecycle API management and robust security features, you can be rest assured that your integrations are reliable, secure, and always up to the task. With all these features, you and your team can focus on your core business requirements and improve overall efficiency without having to directly manage the internal developer platform.",https://wso2.com/choreo/blog/choreo-ipaas-the-integration-platform-as-a-service-for-developers,422,B15
Choreo iPaaS: The Integration Platform-as-a-Service for Developers,Features of Choreo iPaaS,"Choreo iPaaS offers several unique and powerful features that sets it apart from other integration platforms in the market. These include:
Ability to work with integrations as code: Choreo iPaaS allows you to define integrations as code, making it easier to maintain and manage integrations over time. With the flexibility of using multiple integration development options, including polyglot integrations and low-code integrations, you can pick and choose the best integration toolset for your needs and manage everything within the same platform.Powerful connectivity: With support for thousands of connectors like HTTP APIs (OpenAPI), event APIs (AsyncAPI), GraphQL services, legacy systems, and data stores, you can easily move data to and from any system. And with the ability to share credentials in an environment-sensitive way, you can govern which integration projects have access to which systems, ensuring a secure and controlled integration process.Develop with tools you love: With Choreo iPaaS, you can continue to use the tools you already know and love. By treating integrations as code, the development process can effortlessly integrate into your existing developer workflow, bringing benefits such as version control and collaboration via GitHub code repositories. Additionally, as everything is written in code, you have the option to enhance your integration work with AI tools like GitHub copilot.Native support for Ballerina, the integration language: Ballerina is a unique and powerful programming language, designed specifically for network-oriented integration. Whether you prefer to work with code or visual representations, Ballerina offers the best of both worlds with its code-as-picture representation. The language enables you to edit the data mapping as text or as a visual, and even reuse mappings-as-a-service for greater efficiency.Multi-cloud support: You can deploy your integrations to any cloud, including Azure, AWS, and GCP, to keep them close to their dependencies while managing and operating them from one central platform. Additionally, Choreo iPaaS allows you to safely access legacy systems, existing APIs, data sources, and events as part of your integrations without having to navigate complex network security protocols. With one-click cloud native deployment and private data plane capabilities, Choreo iPaaS provides a flexible and secure solution for all your integration needs.Integrated API management and security: Choreo iPaaS gives you full control over your API management, allowing you to easily expose your integrations as managed APIs and promote reuse through the Choreo marketplace. With built-in identity management, either through WSO2’s identity provider Asgardeo, or your own identity provider, you can ensure secure access to your integrations with authentication and authorization. Deploy your integrations with peace of mind in a zero-trust environment with mTLS, RBAC, and more. Take your API management to the next level, with the ability to manage your integrations across multiple environments, regions, clouds, and even within different project teams and organizational structures.Provide a complete developer platform solution: Choreo iPaaS facilitates self-service integration development to improve developer productivity. The advanced observability features in Choreo iPaaS allow you to monitor and troubleshoot integrations in real-time, including deep-dive analytics and AI-based anomaly detection. The deployment and operation of integrations on Kubernetes are made easy and effortless, requiring no complex DevOps skills.&nbsp.",https://wso2.com/choreo/blog/choreo-ipaas-the-integration-platform-as-a-service-for-developers,712,B16
Choreo iPaaS: The Integration Platform-as-a-Service for Developers,An Example of an Integration Scenario with Choreo iPaaS,"One of the most common use-cases for Choreo iPaaS is integrating different systems and applications within an organization. For example, imagine a retail company wants to integrate its e-commerce platform, inventory management system, and financial systems. Using Choreo iPaaS, the company can easily create and manage integration flows that connect these different systems and synchronize data between them. This is illustrated by Figure 1 below.
Figure 1: Integration Solution Architecture
In this scenario, Choreo iPaaS would be used to create and manage integration flows that connect each system. The integration flows would be designed to perform tasks such as:
Synchronizing product data between the e-commerce platform and inventory management system to ensure that the same information is available in both systems.
Automatically updating inventory levels in the inventory management system when an order is placed on the e-commerce platform.
Automatically generating invoices and sending them to the financial systems when an order is fulfilled.Using Choreo iPaaS, the retail company could seamlessly create and manage these integration flows, without the need for a complex infrastructure setup or a dedicated integration team. This would also enhance data precision and make its business processes more efficient.",https://wso2.com/choreo/blog/choreo-ipaas-the-integration-platform-as-a-service-for-developers,249,B17
Choreo iPaaS: The Integration Platform-as-a-Service for Developers,Get Started,"Don't let integration challenges hold you back any longer. Start taking advantage of the power of Choreo iPaaS today, and see the difference it can make for your business. We’re ready to help you get started with writing your own integrations. Sign up for free today and experience the efficiency and productivity improvements that it can bring to your organization. You can also request a demo or contact us so we can help you understand how Choreo iPaaS can meet your enterprise’s integration needs.

h4 -> Follow us",https://wso2.com/choreo/blog/choreo-ipaas-the-integration-platform-as-a-service-for-developers,113,B18
WSO2 Partners with CData to Provide Developers  Access to Hundreds of New Cloud Data Sources,WSO2 Partners with CData to Provide Developers  Access to Hundreds of New Cloud Data Sources,"
Nuwan Dias 
|
12 Oct, 2022CData Connect Cloud, CData Software’s latest offering, is a cloud native data connectivity solution that provides real-time access to hundreds of cloud data sources, including databases, SaaS, APIs, NoSQL, and Big Data, to support BI and analytics, customer success, accounting, operations, and other business initiatives. This next-generation SaaS offering enables organizations to access their cloud data regardless of location, structure, or system, and empowers them to derive business insights and value from their data.
Choreo is a cloud native developer platform that enables developers to create, deploy, and run new digital components like APIs, microservices, and automations in serverless mode on any Kubernetes cluster. Choreo enables developers to shift their focus from operations to development by abstracting away the complexity of cloud native infrastructure so they can create new services in hours or days instead of weeks or months. When developers need to integrate applications that serve as the building blocks for their products, such as Salesforce, SAP, Hubspot, Quickbooks, and MongoDB, Choreo enables them to get it done seamlessly.
Choreo provides over 500 pre-built connectors through its Marketplace that enable developers to quickly get started with building integrations, and the partnership with CData Connect Cloud gives developers access to hundreds more data sources. WSO2 and CData have worked together to make a CData connector for Choreo available in Choreo’s Marketplace. This allows developers to use one connector to quickly integrate the applications they are building on Choreo with any of the data sources supported by CData Connect Cloud. The connector also provides developers with operations to execute a wide range of standard DDL Commands, SQL Commands, and SQL Functions for querying data sources.
This partnership between WSO2 and CData empowers developers to access many separate services through a single unified interface, removing the complexity of having to learn multiple interfaces and specifications. With more power at their fingertips, users can unlock the true value of their data by bringing it all together, leveraging it to build their applications faster, and providing better experiences for their customers, partners, and employees over time.
Find out more about how you can use the CData connector in Choreo here.

h4 -> Follow us
",https://wso2.com/blogs/thesource/wso2-partners-with-cdata,489,B19
Introducing Mediation Policies in Choreo,Introducing Mediation Policies in Choreo,"Menaka Jayawardena 
|
10 Feb, 2023Photo by Chris Liverani on Unsplash",https://wso2.com/choreo/blog/introducing-mediation-policies-in-choreo,24,B20
Introducing Mediation Policies in Choreo,Introduction,"API proxies are used to expose existing services as managed APIs. Depending on the business need, it’s sometimes necessary to conduct certain transformations before dispatching a request to the service or sending a response back to the client. These transformations can vary from simple tasks like adding custom authorization headers to the request to more complex scenarios like changing a response payload to a different schema.
With mediation policy support, Choreo lets users attach pre-defined policies to API proxies, allowing developers to transform requests and responses before sending them to the backend or the client. This also provides a framework for developing custom mediation policies that can be reused across the organization.",https://wso2.com/choreo/blog/introducing-mediation-policies-in-choreo,129,B21
Introducing Mediation Policies in Choreo,What is a Mediation Policy?,"A mediation policy is a basic transformation unit that usually performs a single task like adding headers, removing query parameters, or logging a message. If you look at the pre-packed policies in Choreo, you’ll notice distinct policies to perform each transformation mentioned earlier. You can attach these policies to requests, responses, or error flows of a resource in the API proxy.",https://wso2.com/choreo/blog/introducing-mediation-policies-in-choreo,76,B22
Introducing Mediation Policies in Choreo,What are Mediation Flows?,"Mediation policies occur under an API resource and can be separated into three logical flows:
Request flow: This is the message flow from an API client to the backend service. 
Response flow: This is the message flow from a backend service to the API client.
Fault flow: If an error occurs in the request or response flow, the execution falls back to the fault flow. Within the fault flow, the execution can be dropped, or a response can be sent back to the client. Figure 1 illustrates these flows.Figure 1: Mediation flows",https://wso2.com/choreo/blog/introducing-mediation-policies-in-choreo,113,B23
Introducing Mediation Policies in Choreo,Attaching Policies to an API Proxy,"As seen in Figure 2, the steps below are an example of how users can attach a policy to an API Proxy.
Login to the Choreo Console and click on Create an API Proxy. 
In the API Develop page, go to the Policies section. Here, you will see the API’s resource list. 
Click on a resource to expand it.
Under Response Flow, click the Attach Policy button. 
This opens the Policy List view, and all existing policies will be listed. Policies will be filtered by the flow selected. In this list, you’ll only see policies that can be attached to the Response Flow. 
Click on the Add Header (2.0.0) policy
Provide a name and value for the header, then click Add.
Click the Save button to keep your changes.Figure 2: Attaching mediation policies to an API proxy
You can also attach multiple policies to a flow, and they will be executed in the order that they are defined. As shown in Figure 3, the execution order can be altered by dragging and dropping the policies as needed.
Figure 3: Rearranging the order of the policies",https://wso2.com/choreo/blog/introducing-mediation-policies-in-choreo,242,B24
Introducing Mediation Policies in Choreo,Environment-Specific Policy Parameters,"Some policies require additional parameters. For example, the Add Header policy requires a header name and a header value. These parameters can be provided as static or dynamic values, which can then be specified when deploying the API to an environment.
To specify a parameter as dynamic, provide the parameter value in ${value} format.
E.g., Add header x-env that requires different header values for each environment, then set the Add Header policy parameters as shown in Figure 4:
Header Name: x-env
Header Value: ${xEnvValue}Figure 4: Policy Configuration
As seen in Figure 5, when deploying or promoting the API, you will be prompted to provide the value for xEnvEnvValue.
Figure 5: Environment specific configuration",https://wso2.com/choreo/blog/introducing-mediation-policies-in-choreo,155,B25
Introducing Mediation Policies in Choreo,Reading the Log Output,"Some built-in policies, like the log policy, produce logs. When writing custom policies, you can log certain inputs/outputs to validate the policy. These logs will appear under the observability section (the observability tab becomes active when policies are attached to the API).
Figure 6 shows a sample output produced by logging the payload using the log policy.
Figure 6: Mediation policy logs
An output will appear in the mediation tab, even if no log-producing policies have been attached. This is because the interceptor service that gets generated for executing policies produces standard logs. We’ll talk more about the Interceptor app in the next section.",https://wso2.com/choreo/blog/introducing-mediation-policies-in-choreo,135,B26
Introducing Mediation Policies in Choreo,How Does it Work?,"When you attach a mediation policy to an API proxy, Choreo deploys an application called the Interceptor app between the gateway and the backend to conduct transformations.
As seen in Figure 7, this is how requests are routed when there are no policies.
Figure 7: Default request response flow
Figure 8 shows how a request is routed when a policy is attached.
Figure 8: Request response flow with mediation",https://wso2.com/choreo/blog/introducing-mediation-policies-in-choreo,84,B27
Introducing Mediation Policies in Choreo,API Deployment,"When deploying an API proxy with mediation, the deployment occurs in two steps.

h3 -> Step 1: Generating the Interceptor App
When you deploy an API proxy that has policies, Choreo generates an interceptor app by looking at the policies you’ve specified. The app’s code is maintained in an internal Git repository. Since developers won’t edit the code directly, it is not visible to proxy developers. The code for the app is generated in Ballerina.
When deploying an API proxy, extra time is taken to generate the code for the app. When you first click the Deploy button, Choreo will generate the code, and the stages will be shown similar to Figure 9.
Figure 9: Interceptor app generation
If you’ve specified dynamic parameters while using policies, you’ll be prompted for them at the end of the code-generation step. Choreo will prompt you for the backend endpoints even if there are no dynamic parameters in place.

h3 -> Step 2: Building the Interceptor App
In step 1, we only generated the code for the app. The code is built and pushed to an internal image registry before it’s deployed on the runtime. If you’re familiar with deploying a REST API, you might find the console output similar to the stages you see there. As shown in Figures 10 and 11, neither the Interceptor app nor the API proxy configurations are deployed.
Figure 10: Interceptor app generation logs
Figure 11: Interceptor app build logs

h3 -> Step 3: Deployment
Once the app is built and pushed, the actual deployment takes place. In this phase, the proxy API will be deployed to the gateway by default (without mediation policies). If mediation policies are attached, the deployment will occur in two stages. First, the generated mediation service will be built and deployed. Then the API proxy will be deployed to the gateway. The steps of the deployment process can be seen in the right-hand side panel of Figure 12.
Figure 12: API deployment",https://wso2.com/choreo/blog/introducing-mediation-policies-in-choreo,431,B28
Introducing Mediation Policies in Choreo,API Invocation,"Once the deployment is complete, you can go to the test section and invoke the API. When a request is made, it’ll pass through the gateway and the app as seen in Figure 13. Read on to see what happens.
Figure 13: API invocation

h3 -> Request Flow
Once the request is received by the gateway, it is forwarded to the app. Then the mediation policies attached to the request flow are executed. Once the policies are successfully executed, the request is dispatched to the backed service.

h3 -> Response Flow
In the response flow, the app receives the backend response. Then the mediation policies attached to the response flow are executed. Once the policies are successfully executed, the response is forwarded to the gateway, which then sends the response back to the client.

h3 -> Fault Flow
If errors occur during the execution of the policies in request or response flows (i.e., if the policy function returns an error), the execution will halt, moving it into the fault flow. Then, if there are policies attached, those will be executed like the other flows (e.g., logging), and an error response will be sent to the client.",https://wso2.com/choreo/blog/introducing-mediation-policies-in-choreo,244,B29
Introducing Mediation Policies in Choreo,Implementing Custom Policies,"If you can’t achieve your use case with built-in mediation policies, you can write a custom policy to do it. Technically, a policy is a package written in Ballerina. Thus, the transformation must be written in the Ballerina language. Then, it must be published to Ballerina Central before it can be attached to an API. These custom policies can be published either as public (available for all users within the organization) or private (only available for the user that developed it).
When authoring custom policies, we have published a policy template, where users can easily create a mediation policy project, implement the functionality, test, and publish the policy to Ballerina Central with ease.
Please follow the Create a policy guide for more information.",https://wso2.com/choreo/blog/introducing-mediation-policies-in-choreo,159,B30
Introducing Mediation Policies in Choreo,Conclusion,"The ability to perform modifications to the request or response flows in API proxies is a vital requirement for many enterprise API management use cases. With the introduction of mediation policies in Choreo, users can now easily fulfill this requirement. Also, with the capability to implement custom policies, users receive greater control and more flexibility in implementing the mediation.
Find out more information about custom mediation by reviewing Choreo’s documentation. Sign up for Choreo for free today to try this out yourself!
.alt-wrap{text-align: center;}
    .cCenterImage{max-width: 300px !important;}
h4 -> Follow us",https://wso2.com/choreo/blog/introducing-mediation-policies-in-choreo,136,B31
Introducing GraphQL Support in Choreo,Introducing GraphQL Support in Choreo,"Miraj Abeysekara 
|
6 Oct, 2022We’re happy to announce the release of the GraphQL component type in Choreo, which allows you to develop, deploy, and manage GraphQL services.
GraphQL is widely used for modern mobile and web application backends as it solves many problems associated with REST APIs like over-fetching, under-fetching, and tight coupling between the frontend and the backend. With Choreo now supporting GraphQL components, users can leverage it to build better applications.
Let’s look at what GraphQL is, discuss why you should use it, and then review its capabilities in Choreo.",https://wso2.com/blogs/thesource/Introducing-graphql-support-in-choreo,144,B32
Introducing GraphQL Support in Choreo,What is GraphQL?,"GraphQL is a query language similar to SQL where you can query an API for specific data, rather than receiving an entire API payload. Like SQL, in addition to data queries, you can also manipulate data via GraphQL. HTTP is the most common way of exposing the GraphQL capabilities to the clients via a single endpoint. Once we expose these capabilities via the HTTP protocol, it becomes a GraphQL API, serving over HTTP.
GraphQL enables the client-side to control what data they require, which reduces data fetching overhead. It also allows client-side applications to evolve using existing data without changing the existing domain APIs.
Let’s discuss the benefits of using GraphQL compared to REST.",https://wso2.com/blogs/thesource/Introducing-graphql-support-in-choreo,143,B33
Introducing GraphQL Support in Choreo,Why Should You Use GraphQL Instead of a REST API?,"1. No over-fetching or under-fetching
Two common problems with REST APIs are over-fetching (getting more data than required), and under-fetching (having to make multiple requests to get all the data required). These can lead to higher bandwidth usage and power consumption, which is particularly troublesome in mobile devices. GraphQL solves these issues by taking a cue from SQL and letting developers select what data to fetch with each API call. This eliminates over and under-fetching issues and reduces client-side processing.
2. Strongly-typed schema
REST APIs lack a built-in, strongly-typed schema system. GraphQL has a built-in Schema Definition Language (SDL) to define the APIs. This empowers developers to use tools like code generators to increase productivity and reduce mistakes when developing GraphQL services.
3. Rapid application development
Frontend applications can evolve rapidly based on changing requirements and user feedback. This, in turn, can introduce different data requirements compared to previous versions. With REST APIs, developers would need to update both the frontend and backend to respond to these changes, slowing down development. Since GraphQL provides a single endpoint to query the necessary data, there is no need to wait for any backend changes. Further, GraphQL APIs can evolve without breaking existing clients, speeding up the development of both frontend and backend applications.",https://wso2.com/blogs/thesource/Introducing-graphql-support-in-choreo,290,B34
Introducing GraphQL Support in Choreo,Using Choreo for GraphQL APIs,"Choreo is a full lifecycle cloud native developer platform that enables building and running cloud native applications at scale. With the addition of GraphQL support, you can leverage all the benefits that Choreo offers including cloud development, multi-environment deployment, testing, and observability.
Let’s explore how you can use the above-mentioned capabilities to develop and manage GraphQL APIs.

h3 -> Develop GraphQL APIs Using the Built-in Code Editor
Choreo offers an online VS Code development environment for you and your team to build GraphQL APIs using the Ballerina programming language. Choreo’s VS Code editor comes with pre-installed tools to develop, test, and version control your GraphQL services, making it easier for you to start coding. This is shown in Figure 1.
Figure 1: Online VS Code editor with Ballerina language support

h3 -> Multi-Environment Deployment and Management
Similar to other component types (like REST APIs and Scheduled Tasks) you can leverage the multiple environments as shown in Figure 2 to test and conduct quality assurance before making your GraphQL API available to users. This can be done via Choreo’s default environments or pre-configured private environments.
Figure 2: Multi-environment deployment

h3 -> Query Generation and Testing
Once your GraphQL API is deployed to an environment, use the Test page for the built-in GraphQL IDE, which allows you to explore documentation, generate queries, and invoke the API. This is seen in Figure 3.
Figure 3: GraphQL IDE

h3 -> Operation Level Observability for GraphQL APIs
GraphQL API monitoring at the operation level is difficult compared to REST API resource level monitoring as GraphQL doesn’t use HTTP resource paths and always returns HTTP 200 (the request has succeeded), regardless of whether the query was successful or not. Usually, you need to use additional tools to monitor GraphQL APIs at an operational level.
Choreo offers GraphQL operation-level observability out-of-the-box. Therefore, you don’t need to invest in additional tooling for monitoring. Figure 4 shows the Throughput and Latency graphs for allTodos operation for a sample Todo service.
Figure 4: Observability view for the GraphQL APIs",https://wso2.com/blogs/thesource/Introducing-graphql-support-in-choreo,483,B35
Introducing GraphQL Support in Choreo,Get Started with GraphQL APIs in Choreo,"To create a GraphQL component, click on the GraphQL card on the “Create a new component” page after logging into the Choreo console as shown in Figure 5.
Figure 5: Create GraphQL component
Afterwards, see our GraphQL documentation to create your custom GraphQL APIs in Choreo.
If you are new to Choreo, visit Choreo and sign up for free!
.caption_text{display: none !important;}
h4 -> Follow us",https://wso2.com/blogs/thesource/Introducing-graphql-support-in-choreo,106,B36
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,"By Shehan Dias                        
 24 Aug, 2022Photo by Tom Crew on Unsplash
The Twelve-Factor Application is a methodology that describes principles and practices to create cloud native applications. Applications built following this methodology are portable across environments, can be deployed and scaled rapidly, and makes it easier to quickly react to market changes by adding new features.
Choreo is a digital platform-as-a-service (digital PaaS) that lets developers build cloud native applications that conform to the twelve-factor application methodology. Choreo makes developing and deploying applications simpler and faster by automating the steps to make applications cloud native.
In this article, we will look at how Choreo takes care of each element of the twelve-factor application methodology, plus three more factors that are important to modern cloud native application design.",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,193,R0
How to Perform a Root Cause Analysis by Monitoring Your APIs,How to Perform a Root Cause Analysis by Monitoring Your APIs - How to Perform a Root Cause Analysis by Monitoring Your APIs - part 1,"By Nadheesh Jihan 2 Sep, 2022Photo by Alfonso Scarpa on Unsplash Choreo allows developers to develop, test, deploy, and manage APIs, services, and integrations efficiently. It allows developers to implement production-grade apps following best practices while assisting them to minimize bugs through comprehensive testing. Irrespective of all this, sometimes things don’t go according to plan. Hence, comprehensive observability becomes essential for troubleshooting and fixing bugs once apps are in production. Choreo Observability is a comprehensive observability solution that assists developers to detect abnormal behaviors in production and perform root cause analysis (RCA) to pinpoint the cause of these abnormalities. In this tutorial, let's discuss how to perform an RCA for an instance where API users get an unsuccessful/bad response for their request to an API deployed via Choreo. This RCA can be initiated due to a failing health check or user complaints when they are unable to access the app’s services. 1. First, open the Choreo Observability view for your component. Click the Observe button in the left panel as shown in Figure 1 to navigate to the Observe tab. Then you will see the observability view shown in Figure 2. Figure 1: Navigate to the Observe tab of a selected component Figure 2: Observability view 2. Next, let’s focus on latency and throughput (processing rate) i) View the latency and throughput during the anomaly period As the first step of an RCA, we can analyze how the latency and throughput changed during the time where the abnormal behavior occurred. We can expand the graph in section A of Figure 2 by clicking and dragging the pointer over the period we want to drill down. Alternatively, we can also use the top panel to select a custom time range. We observed the abnormal behavior around June 16, at 2:20. Therefore, let’s select the region from 2:30 to 2:40. ii) Analyzing the drill-down throughput and latency graphs Once we have selected the time range, we can study the throughput and latency of the application for both successful and failed responses as shown in Figure 3. Figure 3: Expanded throughput and latency graphs We can see the following observations: a) At around 2:35:50 the throughput of successful requests has become zero, whereas the throughput for erroneous requests is 15 req/seconds. b) Before 2:36:00 and after 2:40:00 all requests have been successful with a throughput closer to 20 req/seconds. Therefore, it seems the abnormal behavior is temporary and the app has recovered after a few minutes. This could be an indication of failure in an I/O call or the network. Moreover, we can investigate the latency percentiles (50th, 95th, and 99th). The latency percentiles values of erroneous regions are similar to the percentiles observed for successful requests before observing the erroneous behavior. With this information, we can assume the error is not related to the connection to the application, since the application has tried to perform at the same level of processing even for erroneous requests. 3. Analyzing the application logs Since the error occurs within the application, we may find some useful information in the application logs (error logs) as shown in section B of Figure 2. Let’s go deeper into the logs that are shown below that show the throughput and latency plots as shown in Figure 4. Figure 4: Looking at the logs from the observability view Confirming",https://wso2.com/choreo/resources/how-to-perform-a-root-cause-analysis-by-monitoring-your-apis,718,R1
How to Run Your Docker Containers in Choreo,How to Run Your Docker Containers in Choreo,"
By Nilesh Jayanandana                        
 1 Nov, 2022Photo by Fejuz on Unsplash
Choreo is a full lifecycle cloud native developer platform that enables building and running cloud native applications at scale. With the addition of custom Dockerfile support, you can leverage the benefits offered by the platform including cloud development, multi-environment deployment, testing, and observability.
Let’s explore how you can use these capabilities to develop and manage a REST API written in Go.

h3 -> Setup your build configuration
Choreo merely requests that you connect your repository and provide minimal instructions to build your application. As shown in Figure 1, you simply need to provide the path to your Dockerfile, the build context relative to the root of your repository, the port on which your service is running, and the openAPI Spec if it is available in the repository. Choreo takes it from there.
Figure 1: Bring your Dockerfile build configuration

h3 -> Continuous Integration
Setting up CI/CD pipelines can be difficult, but as shown in Figure 2, Choreo automatically adds the relevant CI steps to your pipeline, such as image vulnerability scanning, code vulnerability scanning, and possible Dockerfile misconfigurations as soon as you create your component. All these steps ensure that your application is secure and has the necessary components to operate in a production environment.
Figure 2: CI pipeline of a non-Ballerina runtime application

h3 -> Multi-environment deployment
Before making your application available in the production environment, leverage the multiple environments depicted in Figure 3 to test and perform quality assurance. This can be done via Choreo's default environments or pre-configured private environments.
Figure 3: Multi-environment deployment

h3 -> Configuration management
In accordance with the concept of ""build once, deploy anywhere,"" containers require environment-specific variables to run. These variables are typically introduced into containers via environment variables or mounted files. Choreo’s DevOps Portal allows you to effortlessly mount files and inject environment variables into your application for each environment as illustrated by Figure 4.
Figure 4: Configuration management

h3 -> Testing
Choreo automatically recognizes the presence of an OpenAPI Spec in your repository and provides an API testing interface for testing your API as shown in Figure 5.
Figure 5: Rest API testing

h3 -> API management
Choreo's API management capabilities have been expanded to include components built with custom Dockerfiles, allowing you to manage the exposure of your APIs to consumers. This enables the configuration of API security settings, implementation rate limits, the association of usage plans, the provision of additional documentation, and the execution of additional API governance functions.

h3 -> DevOps portal
Choreo offers more functionality to both Ballerina and custom Dockerfiles through the DevOps portal, where you can set health checks, customize scaling rules, and view the observability of your application. More information about the DevOps portal can be found here.

h2 -> Get Started with Custom Dockerfiles in Choreo
You can easily bring an existing application that has a Dockerfile, or you can fork our sample applications repo in GitHub.
Head over to the Choreo Console and create a REST API, Scheduled Task, or Manual Trigger, which gives you the option to bring in a Dockerfile. This is shown in Figure 6.
Figure 6: Create component
Sign up to Choreo for free and try out this feature today!

h4 -> Table of Contents
",https://wso2.com/choreo/resources/how-to-run-your-docker-containers-in-choreo,760,R2
Performance Debugging with Choreo's AI-Assisted Capabilities,Performance Debugging with Choreo's AI-Assisted Capabilities,"By Nadheesh Jihan                        
 22 Nov, 2022",https://wso2.com/choreo/resources/performant-code-for-everyone-writing-better-code-with-ai-powered-performance-feedback,36,R3
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,1. Code Base,"A single codebase for each microservice, tracked with version control that can be deployed to many environments.
Each artifact created on Choreo is represented as a component under a given project, and each component gets its own source code repository on Github, out-of-the-box. Developers can connect their enterprise (or personal) Github repositories to maintain the source code of their components.
Choreo can deploy components developed to runtime environments (i.e., dev or prod) with a single click. Developers can pick commit IDs of the source repo to perform deployments, thereby allowing multiple deployments of the same source, including rolling back to earlier revisions as well. Figure 1 shows a component in Choreo.
Figure 1: Component in Choreo",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,154,R4
Performance Debugging with Choreo's AI-Assisted Capabilities,Why is Performance Debugging Important?,"The number of public APIs which expose organizational capabilities number in the tens of thousands and growing daily. Most current applications combine these APIs to create new user experiences. Integration-based development is the process of combining multiple services and APIs to create new applications that provide unique user experiences.
Understanding API performance is key to ensuring service level agreements (SLAs) to satisfy those consuming those services. Therefore, analyzing the performance of these APIs is crucial to provide valuable insight on their scalability and to optimize performance.
Integration-based development increases the risk of performance mistakes (e.g., a service call within a loop having a variable length) in the code compared to traditional programs that do not depend on external services. Since developers combine multiple services or APIs with unknown performance characteristics, these mistakes are usually missed out during development. Therefore, performance testing is a crucial aspect of integration-based development.
System performance can significantly impact its cost and feasibility. Consider a scenario where an organization must support a load of 100 transactions per second (TPS). They have two options.
An implementation with best performance practices that supports 100 TPS with a single server.
A scaled implementation with poor performance that handles 20 TPS per node, meaning they require at least five servers to achieve the 100 TPS load.The following table explains the differences between the two implementations:
Characteristics
100 TPS single node
20 TPS x 5 nodes
Complexity
Simple
Requires a single server application
Highly complex
Need to handle scalability and data consistency
Cost
Cheap
No need to worry about additional complexities and needs fewer computational resources
Expensive
Need a special mechanism and additional resources to handle the complexities and overheads
Errors
Fewer errors
Only application-level errors
More errors
Errors due to data inconsistencies, concurrency handling, and inter-node communications
Feasibility
Highly feasible
Scaling of certain services may not be feasible (e.g., scaling may not be possible with third-party services)
While scaling may be necessary at some point, scaling an application with poor performance practices can unnecessarily increase the complexity, cost, and errors while reducing the feasibility of achieving performance goals. The additional cost of scaling can be as high as 100x compared to the version of that application that follows best practices.
The costs will be incurred for additional resources and advanced technologies, more developing hours, hiring experts, and additional testing. Moreover, sometimes it can be less feasible to reach performance goals by just scaling the API if the bottleneck is an external service that is beyond the developer's control.",https://wso2.com/choreo/resources/performant-code-for-everyone-writing-better-code-with-ai-powered-performance-feedback,529,R5
How to Perform a Root Cause Analysis by Monitoring Your APIs,How to Perform a Root Cause Analysis by Monitoring Your APIs - How to Perform a Root Cause Analysis by Monitoring Your APIs - part 2,"the assumptions that we made by looking at the throughput and latency plots, we can see many error logs (as shown in red), that indicate the connection to the hr-service has failed. Unless we know the source code well, we won’t know much about which code snippets or actions raised this error. For now, we know it is a connection failure. 4. Inspecting diagnostics However, we still can’t be sure whether this is the only error that causes the behavior we have observed. Let’s switch to the Diagnostic View tab, which presents unique logs with their frequencies, application metrics, and system metrics as shown in Figure 5. Figure 5: System metrics and application metrics together, and the individual log counts On the left, we can see unique logs with their frequency, and on the right, we see the application metrics (error count, tps, latency, etc.), system metrics (CPU usage (milli-cores), and memory usage (MiB)) of the application. Although CPU and memory usage metrics aren’t that relevant for our analysis, they can detect any issue related to high CPU or memory leaks. For our scenario, we can see that almost all error logs indicate a failure in connecting to the hr-service. 5. Tracing the individual request If we know the source code well enough to understand which code segments are causing the issue, we can stop the RCA at this point. However, in most cases the actions or execution path that have led to the errors we encounter is unclear to the RCA engineers. To analyze this, we can dig deep into the execution path of each request using Section C in Figure 2 as illustrated in Figure 6. Figure 6: Tracing an individual request To identify the execution path that an erroneous request traveled in: a. Click on a point from the throughput or latency plots within the bad erroneous request region. b. From the pane that appears above the low-code diagram (as shown above), click on a single request as shown in Figure 6. c. We can now see the execution path of the request we selected and understand which code segments and actions have led to the system’s failure. This is shown in Figure 7. Figure 7: Traces for the individual requests are highlighted in green In Figure 7, we can see the execution path is highlighted in green. To improve the visibility, we have re-annotated it with red arrows. If we follow the execution of the request, we can see it calls an external service (hr-service) using HTTP GET. That service call seems to return an HTTP500 error code. This is shown in Figure 8. Figure 8: HTTP status codes are show for external calls Due to the unsuccessful request to the external service (hr-service), the app can’t continue the accepted path of its execution. Therefore, the root cause of this issue is the unavailability of the external hr-service due to an internal server error. This is why our app users kept receiving erroneous responses. This tutorial explains how to do a step-by-step RCA considering a scenario where users are unable to get the services from an app as intended due to unsuccessful requests. By following the above steps, we were able to pinpoint the reason why the application wasn’t working. To learn more about Choreo, check the official Choreo documentation, including our Quick Start",https://wso2.com/choreo/resources/how-to-perform-a-root-cause-analysis-by-monitoring-your-apis,695,R6
Performance Debugging with Choreo's AI-Assisted Capabilities,Why is Traditional Performance Debugging Expensive?,"Since integration platforms connect multiple web services while creating new applications, it’s difficult to anticipate the performance of such applications during the development stage until the APIs are tested and deployed. Moreover, it is challenging to understand the performance characteristics of APIs when changing the code or external service calls without rerunning performance experiments after each change. These experiments require additional time and resources and can cost more and extend deadlines.
Even after running experiments, finding the root cause is mostly done via educated guesswork; therefore, several other experiments will be required to verify the suspected root cause. An alternative is to avoid performance mistakes by hiring developers with experience in writing performant code. But developers who do so are difficult to find and highly expensive.
Modern architectures are forcing developers to play dual roles as programmers and system engineers. Developers can’t just write code, they must be responsible for the design, integration, and management of complex systems. New technologies such as graphical code development have reduced the coding effort while expanding the developer base and lowering costs.",https://wso2.com/choreo/resources/performant-code-for-everyone-writing-better-code-with-ai-powered-performance-feedback,206,R7
How to Perform a Root Cause Analysis by Monitoring Your APIs,How to Perform a Root Cause Analysis by Monitoring Your APIs - How to Perform a Root Cause Analysis by Monitoring Your APIs - part 3,Guide.,https://wso2.com/choreo/resources/how-to-perform-a-root-cause-analysis-by-monitoring-your-apis,2,R8
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,2. Dependencies,"Each microservice should isolate and package its own dependencies.
Choreo packages all executables into self-contained containers. This ensures that no implicit dependencies leak into the application runtime. Containerization of code happens transparently from the developer and therefore places no burden on the developer, nor does it require the developer to have any knowledge about this process. Developers can also take the code and run it elsewhere without issues.
Ballerina provides a dependency declaration manifest for developers who use Ballerina to implement components on Choreo. Ballerina executables pack all dependencies into a single Ballerina archive, which provides dependency isolation. All dependencies and their versions are declared in a configuration file. The dependencies are illustrated by Figure 2.
Figure 2: Dependencies in Choreo",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,158,R9
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,3. Config,"Configuration information should be externalized and moved out of the microservice.
Choreo provides a first-class mechanism to externalize configurations from the source code. When developing components on Choreo using Ballerina, developers can declare configurable parameters using a special variable type called configurables.
Configurables are intended to hold values that are sensitive or values that can change based on environments. The component runtime engine in Choreo ensures that:
Configurations are externalized from the source code.
Values for the configurations are provided before a component starts. 
Configuration values are encrypted and stored securely.This saves a lot of developer time that would otherwise be spent figuring out how to externalize configurations, secure them, and inject them at runtime. Figure 3 shows an image of what configurables look like in Choreo.
Figure 3: Configurables",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,179,R10
Performance Debugging with Choreo's AI-Assisted Capabilities,Enter Choreo,"Choreo is a full lifecycle cloud native developer platform that allows developers to rapidly develop and deploy cloud native enterprise applications. The unique AI-assisted graphical code development platform is beneficial to expedite development workflows while bringing in best practices for deployment and operations. It also includes cloud integration tools to successfully integrate your application with other apps- internal or external, as well as proven API integration tools and techniques to define and govern the APIs of your application.",https://wso2.com/choreo/resources/performant-code-for-everyone-writing-better-code-with-ai-powered-performance-feedback,90,R11
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,4. Backing services,"Backing services should be treated as attached resources.
Most services developed today depend on one or more attached resources such as a database, caching service, messaging service, or another API that can be accessed over the network. Choreo’s built-in Marketplace allows developers to easily discover and program using such attached resources.
The Choreo Marketplace contains third-party APIs, datastores, caches, message brokers, and more. Everything in the Marketplace has its own addressable URL that decouples it from the service it uses. By using the configurables support mentioned above, attached resources to a service can be easily swapped at runtime with no code changes and more importantly, without any burden on the developer as well. Figure 4 illustrates the Marketplace.
Figure 4: Marketplace",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,160,R12
Performance Debugging with Choreo's AI-Assisted Capabilities,Helping Everyone to be a 10X Effective Engineer,"With the help of artificial intelligence (AI), integrated development environments (IDE) can take up the burden of helping engineers to write performant code. Choreo does this at two levels for services being developed using the Choreo graphical code editor.
Figure 1: Performance feedback in Choreo's graphical editor
As shown in Figure 1, Choreo provides feedback as-it-occurs on the status of the “performance-critical path” in the service being developed. A request can flow through multiple execution paths. The “performance critical path” is the one estimated to incur in the highest response time for a single request. This does not require deploying the service, as Choreo utilizes historical metrics collected from deployed applications to determine the new service’s performance.
The estimated performance metrics will include how latency and throughput can vary when the number of users accessing the service is increased from a single user to a certain limit. This limit is determined based on the confidence of the performance estimations. For example, if the estimations are assigned low confidence due to the lack of historical data, the limit will automatically drop to a lower user count. The ranges of user count, latency, and throughput for the performance-critical path are displayed in the top banner as shown in Figure 1. With the help of estimated performance metrics shown by the top banner, Choreo developers can understand the performance (throughput, average latency, etc.) of the application after each change made to the performance critical path.
Apart from the overall estimated performance, the estimated latency ranges for the individual API invocations appear next to those calls in the graphical editor as given by Figure 1. With the latency estimations for individual API invocations, Choreo developers can identify the bottleneck API calls that govern the processing rate of the whole service. Whichever API invocation has the highest latency will become the bottleneck for a particular execution path. Moreover, this information is combined with overall performance estimations to help developers identify any performance anti-patterns in the performance critical path. This allows developers to efficiently mitigate performance bottlenecks and anti-patterns since they receive constant feedback with each change they make to the source code of the service.",https://wso2.com/choreo/resources/performant-code-for-everyone-writing-better-code-with-ai-powered-performance-feedback,452,R13
Performance Debugging with Choreo's AI-Assisted Capabilities,Diving Into Performance Feedback,"Although performance feedback is given for the performance critical path, that path is not highlighted in the graphical code editor by default. A service can have multiple execution paths, which account for the performance of the service. As shown in Figure 2, clicking the link on the top banner highlights the performance-critical path in the graphical code editor and opens a panel to the right side of the editor with controllers to select other execution paths.
Figure 2: Exploring the performance of other execution paths via the performance analyzer panel
With the new panel, developers can investigate the performance of each execution path that has at least a single API invocation. Also, the latency and throughput plots that appear below the path selector help us understand how the selected path behaves when changing the number of users accessing the system. This information is useful to conduct capacity planning by understanding the volume of users that the service can support while conducting external API calls. Finally, through performance feedback, Choreo trains developers in a programming style consisting of well-established Enterprise Integration Patterns (EIPs), that naturally yield good performance, known as Artificial intelligence-assisted (AI) development.
˘These types of analysis with the help of AI-powered performance feedback in Choreo can help both inexperienced and expert-level (e.g., enterprise integration architects) developers to identify and resolve performance mistakes efficiently during development. It can also reduce the cost of performance testing while enabling them to develop high-quality APIs.",https://wso2.com/choreo/resources/performant-code-for-everyone-writing-better-code-with-ai-powered-performance-feedback,294,R14
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,"5. Build, Release, Run","Build and run stages should be strictly separated.
The built-in CI/CD pipeline in Choreo ensures that any component developed on Choreo goes through a build → release → run workflow before it’s deployed to a runtime environment. Within Choreo, the build phase compiles the code, the release phase binds values to the relevant configurations, and the run phase deploys and starts (or schedules) the component in the relevant runtime environment. All this is done with just one click.
In addition, releases of Choreo components are immutable. Any change to the code base needs to be deployed as a new release. Each release comes with a unique build ID, which allows you to roll back to any previous build as well. Figure 5 shows what the build, release, and run workflow looks like.
Figure 5: Build, Release, Run",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,177,R15
Performance Debugging with Choreo's AI-Assisted Capabilities,How Does it Work?,"AI is already used in many domains to model already-established behaviors and forecast new behaviors based on previously observed patterns. AI and machine learning (ML) have shown significant success in the domain of performance forecasting of applications.
Choreo has taken this knowledge into account and combined theoretical performance models to build an algorithm to estimate the performance of service-oriented architectures.
The idea is simple: use historical data from different web service calls to build performance characteristic models for services and APIs that are already in use. Using these characteristic models, Choreo tries to satisfy a theoretical model that represents each execution path with service invocations from the considered application.
The performance values that satisfy the theoretical model for the application are the possible performance numbers for a particular execution path.
Therefore, with the above approach, Choreo only needs to build the theoretical model for each change developers make to the application, and within milliseconds, Choreo can produce an accurate performance forecast of that application without running any new performance experiments.",https://wso2.com/choreo/resources/performant-code-for-everyone-writing-better-code-with-ai-powered-performance-feedback,202,R16
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,6. Processes,"The application should be executed as one or more stateless processes isolated from other running processes.
Each component you develop and deploy in Choreo will be independent of other components. Choreo tracks each component’s state and runs it in its own Docker container as an isolated process. Choreo provides easy access to backing services through its Marketplace and configurables, encouraging developers to easily externalize states and configurations.
Processes in Choreo are created as components. These components can be of different types such as microservices, different types of APIs, scheduled jobs, or triggers (integrations). This factor is particularly important for microservices and APIs, for which autoscaling is a key requirement.",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,145,R17
Performance Debugging with Choreo's AI-Assisted Capabilities,"Finally, What a Relief!","Writing performant code has become a challenge. Developers need to run multiple performance tests to tune the performance of an application. When it comes to integration-based applications, performance anti-patterns can reduce the performance of the application drastically. In such cases, scaling the application can be complex, expensive, and less feasible. Scaling an application with performance mistakes can increase the cost by at least 100x. While testing applications for performance mistakes is expensive and time-consuming.
With Choreo, developers can use feedback from the performance forecast tools to develop performant code efficiently while identifying performance anti-patterns. This saves both money and time while ensuring the quality of the code. Also, inexperienced developers can create better applications using AI-based performance feedback provided by the Choreo editor. This opens the door for inexperienced developers to use graphical code editors with confidence while minimizing the likelihood of mistakes.
Choreo offers a graphical code editor specially designed for cloud native development processes. So, any developer who wants to use this platform can get the benefits of the performance debugging tools.
Sign up to Choreo for free and try out this feature today!

h4 -> Table of Contents",https://wso2.com/choreo/resources/performant-code-for-everyone-writing-better-code-with-ai-powered-performance-feedback,241,R18
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,7. Port Binding,"Each service should be self-contained and exported via port binding.
Each service in Choreo gets bound to a port by default, without any explicit attention required by the developer. Each service is completely self-contained and does not require runtime injection of a web server. At development, the service can be accessed via a URL that looks like https://localhost:8090. When the service is deployed into its relevant environments, a routing layer handles routing requests from a public facing host to the port bound address.",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,103,R19
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,8. Concurrency,"Services should be scaled horizontally on demand across multiple identical processes.
Every service you deploy on Choreo runs on a container in a Kubernetes cluster. Choreo provides a platform where every service you deploy on it can scale horizontally when needed. So, if you have a sudden surge of traffic to your service, Choreo will scale out your service by increasing the number of replicas it runs. When traffic returns to normal, Choreo will scale your service back in by gracefully shutting down the extra replicas it spawned. Choreo inherits the auto-scaling functionality offered by Kubernetes to make services horizontally scalable. It also supports auto-healing. In the event a service instance crashes, it would be brought back up based on the number of minimal replicas requested by the configuration.",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,169,R20
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,9. Disposability,"Maximize robustness with fast startup and graceful shutdown.
Services deployed on Choreo can be started or stopped at a moment’s notice. Choreo’s concept of projects and components guides developers to design right-sized (usually smaller) microservices that makes them easier to boot up fast.
When Choreo receives a shutdown (undeploy) signal, Choreo components stop receiving any new traffic to the service and complete serving whatever requests it has already accepted. This way, developers get graceful shutdowns for their services out of the box. Inheriting Kubernetes capabilities, Choreo supports rolling updates which allows developers to make changes to their services with no impact on user traffic.",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,147,R21
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,10. Dev/Prod Parity,"Keep development, staging, and production environments as similar as possible.
The twelve-factor app highlights three major challenges with having multiple environments.
Choreo provides clean solutions that automatically tackles all three challenges seamlessly.
Choreo deploys code into environments in minutes, so developers don’t have to wait to test their changes. They can deploy code with a single click that triggers a CI/CD process and deploys the code. Also, promotions across environments are fast since they don’t involve compiling code.
Developers get full access to a development environment plus other environments if they have the required access. Developers have full access to the logs of the component, allowing them to see exactly what’s going on.
By default, Choreo provides two environments, dev and prod. Developers can use connectors from the Marketplace to connect to various backing services such as databases (e.g., a Postgres connector won’t connect to a MySQL database). This forces developers to use the same backing services across environments. While Choreo developers have the freedom to write boilerplate code and connect to any backing service, this method is discouraged by design.Figure 6 displays the environments in Choreo.
Figure 6: Environments in Choreo",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,259,R22
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,11. Logs,"Treat logs generated by services as event streams.
Developers on Choreo do not have to concern themselves with routing or storage of the output stream of their services. Instead, Choreo writes each event stream to stdout, which is then streamed to a log processing engine for storage and indexing. Developers get a comprehensive UI for viewing, searching, and even downloading logs of their services, all with no extra effort. Figure 7 shows an image of the logs.
Figure 7: Log",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,101,R23
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,12. Admin Processes,"Run admin/management tasks as one-off processes.
Every component developed on Choreo is deployed on a Kubernetes cluster either as a service or a job. Jobs can be scheduled to run periodically or as one-time tasks. The twelve-factor app defines admin processes as one-time execution tasks that should be run. Choreo supports these out-of-the-box as one-time execution jobs, and they can be run on the same environments as other services. Figure 8 shows an admin process.
Figure 8: An Admin Process
In addition to the above factors discussed in the Twelve-Factor application methodology, we believe there are three more that should be considered. These come from the book, Beyond the Twelve-Factor App. Let’s find out what they are and how Choreo incorporates them.",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,172,R24
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,13. API First,"Make everything a service.
Any service-type component created in Choreo has an interface. These could be REST, GraphQL, gRPC, WebSockets, etc. Developers must associate the interface specification to the type of service they are developing. Choreo also allows exposing these services to either internal or external consumers.",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,68,R25
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,14. Telemetry,"Include monitoring domain specific and health/system data.
Choreo provides deep observability that provides logs, tracing, and metrics to troubleshoot your components. Choreo represents these data visually to make it easy for the developer to troubleshoot their components. It also provides business insights to help organizations relate technical KPIs to business performance. This is shown by Figure 9.
Figure 9: Observability in Choreo",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,88,R26
Building a Cloud Native Twelve-Factor App on Choreo: Just Write the Code,15. Authentication/Authorization,"Implement identity from the start.
Security is not an afterthought on Choreo. Instead, it gives organizations a zero-trust environment by making every component deployed on Choreo secured by default. Choreo enforces security on components without requiring explicit attention by developers, even for those with little or no knowledge about how to secure their components, Choreo assumes default levels of security and applies them so their components are always secure.
Choreo comes with two API gateways out-of-the-box: one for internal API exposure and one for external API exposure. When exposing APIs, Choreo supports API keys and OAuth2.0 security. For end-user authentication of APIs, Choreo allows you to use Asgardeo or any other IDP as shown by Figure 10.
Figure 10: External IDPs in Choreo
Conclusion
Choreo aspires to make cloud native application development simple and efficient. It allows application developers to focus on their business logic code while automating everything else. Choreo takes care of all the factors presented by the Twelve-factor application methodology plus three more. Applications built on Choreo are portable across environments and cloud providers.
If you want to learn more about Choreo, watch our webinar, Delivering New Digital Experiences Fast or sign up by visiting Choreo today!
$(document).ready(function () {
var cLibraryContentInfo = '<ul class=""cLibraryContentInfo"">' +
                          '<li class=""cFirstItem""><div class=""cSubmitted""><span>By&nbsp;</span>Nuwan Dias and Kavishka Fernando</div></li>' +
                          '</ul>' ;
 $('.cSubmitted').replaceWith(cLibraryContentInfo);
 });
h4 -> Table of Contents",https://wso2.com/choreo/resources/building-a-cloud-native-twelve-factor-app-on-choreo-just-write-the-code,437,R27
